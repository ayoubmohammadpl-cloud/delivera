<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠÙ„ â€” ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ§Ø¬Ø±</title>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<style>
    :root{--primary:#4285F4;--card-bg:#fff;--muted:#666;}
    body { font-family: Arial, sans-serif; direction: rtl; padding: 20px; background: #f3f6fb; color:#222; }
    h2 { text-align: center; margin-bottom: 10px; }

    /* language switcher (ÙÙ‚Ø· ÙÙŠ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„/Ø§Ù„Ø¯Ø®ÙˆÙ„) */
    .lang-switcher {
      max-width: 520px;
      margin: 0 auto 10px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .lang-switcher select {
      width: auto;
      min-width: 120px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fff;
    }

    .tabs { display: flex; justify-content: center; gap:10px; margin-bottom: 20px; }
    .tab { padding: 10px 18px; border-radius: 8px; cursor: pointer; background: #e6eefc; color: #124; }
    .tab.active { background: var(--primary); color: #fff; box-shadow: 0 2px 8px rgba(66,133,244,0.3); }
    .card { background: var(--card-bg); border-radius: 10px; padding: 14px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); margin-bottom: 12px; }
    form { max-width: 520px; margin: 0 auto 10px; padding: 16px; border-radius: 10px; background: #fff; box-shadow: 0 1px 6px rgba(0,0,0,0.04); }
    input, select, button, textarea { width: 100%; padding: 10px; margin: 8px 0; border-radius: 8px; border: 1px solid #ddd; box-sizing: border-box; }
    button { background: var(--primary); color: #fff; border: none; cursor: pointer; }
    button.secondary { background: #fff; color: var(--primary); border: 1px solid #cde; }
    .hidden { display:none; }
    /* Merchant dashboard layout */
    #merchantDashboard { max-width: 1200px; margin: 0 auto; }
    .dashboard-top { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:12px; }
    .merchant-info { display:flex; gap:12px; align-items:center; }
    .stat { background:#fff; padding:10px 14px; border-radius:10px; min-width:120px; text-align:center; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }
    .main-row { display:flex; gap:18px; }
    .map-col { flex: 1.4; min-height:500px; border-radius:10px; overflow:hidden; }
    #map { width:100%; height:100%; min-height:500px; }
    .side-col { flex: 0.9; display:flex; flex-direction:column; gap:12px; min-width:320px; }
    .orders-list { max-height: 240px; overflow:auto; padding:10px; background:#fff; border-radius:10px; }
    .order-card { border:1px solid #eef; padding:10px; margin-bottom:8px; border-radius:8px; cursor:pointer; }
    .order-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    .controls { display:flex; gap:8px; align-items:center; }
    .small { font-size:13px; color:var(--muted); }
    /* modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:90%; max-width:520px; background:#fff; padding:18px; border-radius:12px; }
    .flex-between { display:flex; justify-content:space-between; align-items:center; }
    .btn-row { display:flex; gap:8px; margin-top:10px; }
   
    @media(max-width:980px){
        .main-row{ flex-direction:column; }
        .side-col{ min-width:auto; }
        form{ width:95%; }
    }
	/* ========== ÙˆØ¶Ø¹ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø­Ø¯ÙŠØ«Ø© (Ø®Ø±ÙŠØ·Ø© ÙƒØ§Ù…Ù„Ø© + Ø´Ø±ÙŠØ· Ø¹Ù„ÙˆÙŠ + Ù‚Ø§Ø¦Ù…Ø© Ø¬Ø§Ù†Ø¨ÙŠØ©) ========== */

body.merchant-mode {
  margin: 0;
  padding: 0;
}

/* Ù†Ù„ØºÙŠ Ø´ÙƒÙ„ Ø§Ù„ÙƒØ±Øª Ø¹Ù† Ù„ÙˆØ­Ø© Ø§Ù„ØªØ§Ø¬Ø± */
#merchantDashboard.merchant-dashboard {
  max-width: none;
  margin: 0;
  padding: 0;
  background: transparent;
  box-shadow: none;
}

/* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ø®Ø±ÙŠØ·Ø© */
.merchant-map-wrapper {
  position: relative;
  width: 100%;
  height: 100vh; /* Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© */
  overflow: hidden;
}

/* Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ù†ÙØ³Ù‡Ø§ */
.merchant-map-wrapper #map {
  width: 100%;
  height: 100%;
}

/* Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ Ø§Ù„Ø¹Ø§Ø¦Ù… ÙÙˆÙ‚ Ø§Ù„Ø®Ø±ÙŠØ·Ø© */
.merchant-topbar {
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: row-reverse; /* ÙŠØ®Ù„ÙŠ Ø²Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ† ÙˆØ§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø± */
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  background: rgba(15, 23, 42, 0.92);
  color: #fff;
  border-radius: 999px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.6);
  z-index: 10;
}

.merchant-topbar button,
.merchant-topbar .topbar-earnings {
  border: none;
  outline: none;
}

/* Ø²Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© (Ø§Ù„Ù‡Ø§Ù…Ø¨Ø±ØºØ±) */
.topbar-btn {
  width: 34px;
  height: 34px;
  border-radius: 999px;
  background: #111827;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 18px;
}

/* Ø²Ø± Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† / Ø£ÙˆÙÙ„Ø§ÙŠÙ† */
.topbar-toggle {
  min-width: 90px;
  padding: 6px 14px;
  border-radius: 999px;
  background: #6b7280; /* Ø£ÙˆÙÙ„Ø§ÙŠÙ† */
  cursor: pointer;
  font-size: 14px;
}

.topbar-toggle[data-state="online"] {
  background: #22c55e; /* Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† */
}
/* ÙˆÙ…ÙŠØ¶ Ø²Ø± Ø§Ù„Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†/Ø£ÙˆÙÙ„Ø§ÙŠÙ† Ù„Ù„ØªØ§Ø¬Ø± */
@keyframes merchant-blink {
  0%,100% { opacity: 1; }
  50%     { opacity: 0.3; }
}
.blink {
  animation: merchant-blink 0.8s linear infinite;
}

/* ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ ÙÙŠ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ */
.topbar-earnings {
  font-size: 11px;
  line-height: 1.3;
  padding: 4px 10px;
  border-radius: 999px;
  background: #0f172a;
  text-align: center;
  white-space: nowrap;
}
.topbar-earnings strong {
  font-size: 14px;
}
/* ÙƒØ±Øª Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¦Ù‚ÙŠÙ† Ø§Ù„Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† (Ù…Ù†ÙØµÙ„ Ø¹Ù† Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ) */
.online-drivers-card {
  position: absolute;
  top: 2px;
  left: -150px;
  background: #ffffff;
  color: #111827;
  padding: 6px 12px;
  border-radius: 16px;
  box-shadow: 0 20px 25px rgba(15, 23, 42, 0.35);
  font-size: 13px;
  line-height: 1.4;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  z-index: 11;
  direction: rtl;
  text-align: center;
  overflow: visible;
}

.online-drivers-card .label {
  color: #4b5563;
  font-size: 14px;
}

.online-drivers-card .count {
  font-weight: 700;
  font-size: 18px;
  color: #22c55e;
}

/* Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© (ÙŠÙ…ÙŠÙ†) */
.merchant-side-panel {
  position: fixed;
  top: 0;
  right: 0;
  width: 380px;
  max-width: 80%;
  height: 100vh;
  background: #020617;
  color: #e5e7eb;
  box-shadow: -16px 0 40px rgba(0, 0, 0, 0.6);
  transform: translateX(100%);
  transition: transform 0.25s ease-out;
  z-index: 20;
  display: flex;
  flex-direction: column;
}

.merchant-side-panel.open {
  transform: translateX(0);
}

/* Ø®Ù„ÙÙŠØ© Ø´ÙØ§ÙØ© ÙˆØ±Ø§Ø¡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© */
.merchant-side-panel-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.35);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-out;
  z-index: 15;
}

.merchant-side-panel-backdrop.visible {
  opacity: 1;
  pointer-events: auto;
}

/* Ù‡ÙŠØ¯Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© */
.side-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 14px 6px;
  border-bottom: 1px solid rgba(15, 23, 42, 0.9);
}
.merchant-info-box {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.merchant-info-box .merchant-name {
  font-weight: 700;
}
.merchant-info-box .merchant-city {
  font-size: 13px;
  color: #9ca3af;
}
.icon-btn {
  width: 30px;
  height: 30px;
  border-radius: 999px;
  background: #111827;
  color: #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: none;
}

/* Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© (ØªÙ…Ø±ÙŠØ± Ø¹Ù…ÙˆØ¯ÙŠ) */
.side-panel-scroll {
  flex: 1;
  padding: 10px 14px 16px;
  overflow-y: auto;
}

/* ØµÙ Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª */
.stat-row {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}
.merchant-side-panel .stat {
  flex: 1;
  background: #020617;
  border-radius: 10px;
  padding: 8px 10px;
  min-width: 0;
  text-align: center;
  box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  border: 1px solid #111827;
  font-size: 12px;
}
.merchant-side-panel .stat strong {
  font-size: 16px;
}

/* Ø£Ù‚Ø³Ø§Ù… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© */
.panel-section {
  background: #020617;
  border-radius: 10px;
  padding: 10px 10px 8px;
  margin-bottom: 12px;
  border: 1px solid #111827;
}

.panel-section .flex-between {
  margin-bottom: 6px;
}

/* ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ù„ØªÙ†Ø§Ø³Ø¨ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¯Ø§ÙƒÙ†Ø© */
.merchant-side-panel .orders-list {
  max-height: 220px;
  padding: 6px;
  background: transparent;
  border-radius: 8px;
}
.merchant-side-panel .order-card {
  border: 1px solid #111827;
  background: #020617;
  color: #e5e7eb;
}
.merchant-side-panel .order-card:hover {
  box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  border-color: #1d4ed8;
}

/* Ø£Ø²Ø±Ø§Ø± Ø«Ø§Ù†ÙˆÙŠØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© */
.merchant-side-panel button.secondary {
  background: #020617;
  color: #e5e7eb;
  border-color: #1f2937;
}

/* Ø²Ø± Ø®Ø±ÙˆØ¬ Ù…Ù…ØªØ¯ */
.full-width {
  width: 100%;
  margin-top: 4px;
}
/* ==== Toast notifications ==== */
.toast-container {
  position: fixed;
  bottom: 18px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
}

.toast {
  min-width: 220px;
  max-width: 320px;
  background: rgba(15, 23, 42, 0.97);
  color: #f9fafb;
  padding: 10px 14px;
  border-radius: 999px;
  font-size: 13px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.7);
  display: flex;
  align-items: center;
  gap: 8px;
  direction: rtl;
  opacity: 1;
  transition: opacity 0.4s ease-out, transform 0.4s ease-out;
}

.toast-success {
  border: 1px solid #22c55e;
}

.toast-error {
  border: 1px solid #ef4444;
}

.toast-icon {
  font-size: 16px;
}

.toast.fade-out {
  opacity: 0;
  transform: translateY(8px);
}
/* Ø²Ø± Ù…Ù†Ø§Ø¯Ø§Ø© Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨Ø§Ù„ÙˆÙ† */
.call-btn {
  color: #fff !important;
  font-weight: 700;
}

</style>
</head>
<body>

<h2 id="mainHeader">Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠÙ„ â€” ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ§Ø¬Ø±</h2>

<!-- language switcher (ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„/Ø§Ù„Ø¯Ø®ÙˆÙ„) -->
<div id="langSwitcher" class="lang-switcher">
  <label id="langLabel" for="langSelect">Ø§Ù„Ù„ØºØ©:</label>
  <select id="langSelect">
    <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
    <option value="de">Deutsch</option>
    <option value="en">English</option>
    <option value="tr">TÃ¼rkÃ§e</option>
  </select>
</div>

<!-- Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª -->
<div class="tabs" id="authTabs">
    <div class="tab active" id="registerTab">ØªØ³Ø¬ÙŠÙ„</div>
    <div class="tab" id="loginTab">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</div>
</div>

<!-- SECTION: Register (ØªØ§Ø¬Ø± ÙÙ‚Ø·) -->
<div id="registerSection" class="card">
    <form id="merchantForm" autocomplete="off">
        <h3>ØªØ³Ø¬ÙŠÙ„ ØªØ§Ø¬Ø±</h3>
        <input type="text" id="storeName" placeholder="Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¬Ø±" required />
        <input type="text" id="storeAddress" placeholder="Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…ØªØ¬Ø±" required />
        <input type="text" id="storeCity" placeholder="Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" required />
        <input type="text" id="storePhone" placeholder="Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø§Ù„Ù…ØªØ¬Ø±" required />
        <input type="text" id="contactName" placeholder="Ø§Ø³Ù… Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„" required />
        <input type="text" id="contactPhone" placeholder="Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„" required />
        <input type="email" id="contactEmail" placeholder="Ø§ÙŠÙ…ÙŠÙ„ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„" required />
        <input type="password" id="merchantPassword" placeholder="ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± (6+ Ø­Ø±ÙˆÙ)" required />
        <button type="submit">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ§Ø¬Ø±</button>
    </form>
</div>

<!-- SECTION: Login -->
<div id="loginSection" class="card hidden">
    <form id="loginForm" autocomplete="off">
        <h3>ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ (ØªØ§Ø¬Ø±)</h3>
        <input type="email" id="loginEmail" placeholder="Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ" required />
        <input type="password" id="loginPassword" placeholder="ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±" required />
        <button type="submit">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</button>
    </form>
</div>

<!-- SECTION: Merchant Dashboard -->
<div id="merchantDashboard" class="hidden merchant-dashboard">
  <div class="merchant-map-wrapper">
    <!-- Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© -->
    <div id="map"></div>

    <!-- Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ Ø§Ù„Ø¹Ø§Ø¦Ù…: ÙŠÙ…ÙŠÙ† Ø²Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©ØŒ ÙˆØ³Ø· Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†/Ø£ÙˆÙÙ„Ø§ÙŠÙ†ØŒ ÙŠØ³Ø§Ø± Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ -->
    <div class="merchant-topbar">
      <button id="merchantMenuBtn" class="topbar-btn" type="button">â˜°</button>
      <button id="merchantOnlineToggle" class="topbar-toggle" type="button" data-state="offline">
        Ø£ÙˆÙÙ„Ø§ÙŠÙ†
      </button>
      <div id="merchantEarnings" class="topbar-earnings">
        Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙˆØµÙŠÙ„<br><strong>0 â‚¬</strong>
      </div>
      <!-- ØµÙ†Ø¯ÙˆÙ‚ Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¦Ù‚ÙŠÙ† Ø§Ù„Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† -->
      <div id="onlineDriversBadge" class="online-drivers-card">
        <span class="label">Ø§Ù„Ø³Ø§Ø¦Ù‚ÙˆÙ† Ø§Ù„Ù…ØªØ§Ø­ÙˆÙ†</span>
        <span class="count">0</span>
      </div>
    </div>

    <!-- Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© -->
    <aside id="merchantSidePanel" class="merchant-side-panel">
      <div class="side-panel-header">
        <div class="merchant-info-box">
          <div id="merchantName" class="merchant-name">Ø§Ø³Ù… Ø§Ù„ØªØ§Ø¬Ø±</div>
          <div id="merchantCity" class="merchant-city small">Ø§Ù„Ø¹Ù†ÙˆØ§Ù†</div>
        </div>
        <button id="closeSidePanel" class="icon-btn" type="button">âœ•</button>
      </div>

      <div class="side-panel-scroll">
        <!-- Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª -->
        <div class="stat-row">
          <div class="stat" id="countActive">
            Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø´Ø·Ø©<br /><strong>0</strong>
          </div>
          <div class="stat" id="countCompleted">
            Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©<br /><strong>0</strong>
          </div>
          <div class="stat" id="totalDelivery">
            ØªÙƒØ§Ù„ÙŠÙ Ø§Ù„ØªÙˆØµÙŠÙ„<br /><strong>0</strong>
          </div>
        </div>

        <!-- Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø© -->
        <div class="panel-section">
          <div class="flex-between">
            <div><strong id="activeOrdersTitle">Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©</strong></div>
            <div class="controls">
              <select id="filterDriver">
                <option value="">Ø§Ù„Ø¬Ù…ÙŠØ¹</option>
              </select>
              <select id="sortActive">
                <option value="date_desc">Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹</option>
                <option value="date_asc">Ø§Ù„Ø£Ù‚Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹</option>
                <option value="driver_asc">Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø£-ÙŠ</option>
                <option value="driver_desc">Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙŠ-Ø£</option>
              </select>
            </div>
          </div>
          <div id="activeOrders" class="orders-list"></div>
        </div>

        <!-- Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© -->
        <div class="panel-section">
          <div class="flex-between">
            <div><strong id="completedOrdersTitle">Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©</strong></div>
            <div class="controls">
              <button id="exportCsv" class="secondary">ØªØµØ¯ÙŠØ± CSV</button>
              <button id="printBtn" class="secondary">Ø·Ø¨Ø§Ø¹Ø©</button>
              <select id="sortCompleted">
                <option value="date_desc">Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹</option>
                <option value="date_asc">Ø§Ù„Ø£Ù‚Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹</option>
                <option value="driver_asc">Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø£-ÙŠ</option>
                <option value="driver_desc">Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙŠ-Ø£</option>
              </select>
            </div>
          </div>
          <div id="completedOrders" class="orders-list"></div>
        </div>

        <!-- Ø²Ø± Ø§Ù„Ø®Ø±ÙˆØ¬ -->
        <button id="logoutBtn" class="secondary full-width">ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬</button>
      </div>
    </aside>

    <!-- Ø®Ù„ÙÙŠØ© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© -->
    <div id="merchantSidePanelBackdrop" class="merchant-side-panel-backdrop"></div>
  </div>
</div>

<!-- ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨ (Ù…ÙˆØ¯Ø§Ù„) -->
<div id="orderModal" class="hidden">
    <div class="modal-backdrop" id="modalBackdrop" style="display:none;">
        <div class="modal">
            <div class="flex-between">
                <h3>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨</h3>
                
            </div>
            <div id="modalContent" style="margin-top:12px;"></div>
        </div>
    </div>
</div>


<!-- ØµÙˆØª Ø¹Ù†Ø¯ Ø§Ù„ØªØ­ÙˆÙ„ Ø¥Ù„Ù‰ Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† Ù„Ù„ØªØ§Ø¬Ø± -->
<audio id="merchantOnlineSound" src="online1.mp3" preload="auto"></audio>
<!-- ØµÙˆØª Ø¹Ù†Ø¯ Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø·Ù„Ø¨ Ù…Ù† Ø§Ù„Ø³Ø§Ø¦Ù‚ -->
<audio id="callAcceptedSound" src="send.mp3" preload="auto"></audio>

<!-- ØµÙˆØª Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ ØªÙˆØ¬Ù‡ Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø¥Ù„Ù‰ Ø§Ù„ØªØ§Ø¬Ø± -->
<audio id="driverOnWaySound" src="unterwegs.mp3" preload="auto"></audio>

<!-- ØµÙˆØª Ù‚Ø¨Ù„ Ø¯Ù‚ÙŠÙ‚Ø© Ù…Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ø£Ùˆ Ø¶Ù…Ù† 500Ù… -->
<audio id="driverNearSound" src="1m.mp3" preload="auto"></audio>

<audio id="merchantCallSound" src="send.mp3" preload="auto"></audio>
<audio id="customerDeliveredSound" src="Geliefert.mp3" preload="auto"></audio>

<!-- Toast notifications -->
<div id="toastContainer" class="toast-container"></div>

<!-- Google Maps API -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCUMgXQwwe7afBlRpp6zrXunbTVSCXfSqQ&libraries=geometry"></script>

<script>
/* ========== Ø§Ù„ØªØ±Ø¬Ù…Ø© (i18n) Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ========== */
const I18N = {
  ar: {
    pageTitle: "Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠÙ„ â€” ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ§Ø¬Ø±",
    mainHeader: "Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠÙ„ â€” ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ§Ø¬Ø±",
    languageLabel: "Ø§Ù„Ù„ØºØ©:",
    tabRegister: "ØªØ³Ø¬ÙŠÙ„",
    tabLogin: "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
    registerTitle: "ØªØ³Ø¬ÙŠÙ„ ØªØ§Ø¬Ø±",
    storeNamePlaceholder: "Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¬Ø±",
    storeAddressPlaceholder: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…ØªØ¬Ø±",
    storeCityPlaceholder: "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©",
    storePhonePlaceholder: "Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø§Ù„Ù…ØªØ¬Ø±",
    contactNamePlaceholder: "Ø§Ø³Ù… Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„",
    contactPhonePlaceholder: "Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„",
    contactEmailPlaceholder: "Ø§ÙŠÙ…ÙŠÙ„ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„",
    merchantPasswordPlaceholder: "ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± (6+ Ø­Ø±ÙˆÙ)",
    registerSubmit: "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ§Ø¬Ø±",
    loginTitle: "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ (ØªØ§Ø¬Ø±)",
    loginEmailPlaceholder: "Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
    loginPasswordPlaceholder: "ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±",
    loginSubmit: "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
    topbarOnline: "Ù…ØªØµÙ„",
    topbarOffline: "ØºÙŠØ± Ù…ØªØµÙ„",
    topbarTotalDelivery: "ØªÙƒØ§Ù„ÙŠÙ Ø§Ù„ØªÙˆØµÙŠÙ„",
    onlineDriversLabel: "Ø§Ù„Ø³Ø§Ø¦Ù‚ÙˆÙ† Ø§Ù„Ù…ØªØ§Ø­ÙˆÙ†",
    statsActiveCalls: "Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø´Ø·Ø©",
    statsPastCalls: "Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©",
    statsTotalDelivery: "ØªÙƒØ§Ù„ÙŠÙ Ø§Ù„ØªÙˆØµÙŠÙ„",
    activeOrdersTitle: "Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø´Ø·Ø©",
    completedOrdersTitle: "Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©",
    filterAllDrivers: "Ø§Ù„Ø¬Ù…ÙŠØ¹",
    sortDateDesc: "Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹",
    sortDateAsc: "Ø§Ù„Ø£Ù‚Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹",
    sortDriverAsc: "Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø£-ÙŠ",
    sortDriverDesc: "Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙŠ-Ø£",
    exportCsv: "ØªØµØ¯ÙŠØ± CSV",
    print: "Ø·Ø¨Ø§Ø¹Ø©",
    logout: "ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬",
        callStatusLabel: "Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¯Ø§Ø¡",
    toastNoMerchant: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ù†Ø¯Ø§Ø¡: Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ.",
    toastOffline: "Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ù†Ø¯Ø§Ø¡Ø§Øª ÙˆØ£Ù†Øª ÙÙŠ ÙˆØ¶Ø¹ Ø£ÙˆÙÙ„Ø§ÙŠÙ†. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† Ø£ÙˆÙ„Ø§Ù‹.",
    toastDriverBusy: "Ø§Ù„Ø³Ø§Ø¦Ù‚ Ù…Ø´ØºÙˆÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ù…Ù†Ø§Ø¯Ø§ØªÙ‡.",
    toastCallSentPrefix: "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù†Ø¯Ø§Ø¡ Ù„Ù„Ø³Ø§Ø¦Ù‚",
    toastErrorSendCallPrefix: "Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Ø¯Ø§Ø¡:",
    toastDriverHeadingMerchantWithName: "Ø§Ù„Ø³Ø§Ø¦Ù‚ {{name}} ÙÙŠ Ø·Ø±ÙŠÙ‚Ù‡ Ø¥Ù„ÙŠÙƒ",
    toastDriverHeadingMerchantNoName: "Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙÙŠ Ø·Ø±ÙŠÙ‚Ù‡ Ø¥Ù„ÙŠÙƒ",
    toastDriverHeadingCustomerWithName: "Ø§Ù„Ø³Ø§Ø¦Ù‚ {{name}} ÙÙŠ Ø·Ø±ÙŠÙ‚Ù‡ Ù„Ù„Ø¹Ù…ÙŠÙ„",
    toastDriverHeadingCustomerNoName: "Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙÙŠ Ø·Ø±ÙŠÙ‚Ù‡ Ù„Ù„Ø¹Ù…ÙŠÙ„",
// === CSV / Print ===
    csvHeaderId: "Ø§Ù„Ù…Ø¹Ø±Ù‘Ù",
    csvHeaderDriverId: "Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø³Ø§Ø¦Ù‚",
    csvHeaderDriverName: "Ø§Ø³Ù… Ø§Ù„Ø³Ø§Ø¦Ù‚",
    csvHeaderStatus: "Ø§Ù„Ø­Ø§Ù„Ø©",
    csvHeaderRequestTime: "ÙˆÙ‚Øª Ø§Ù„Ø·Ù„Ø¨",
    csvHeaderResponseTime: "ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©",
    csvHeaderMerchantName: "Ø§Ø³Ù… Ø§Ù„ØªØ§Ø¬Ø±",
    csvHeaderMerchantCity: "Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„ØªØ§Ø¬Ø±",

    alertNoExportForDriver: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø³Ø§Ø¨Ù‚Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø³Ø§Ø¦Ù‚ Ù„Ù„ØªØµØ¯ÙŠØ±.",
    alertNoExportAll: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±.",
    alertNoPrintForDriver: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø³Ø§Ø¨Ù‚Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø³Ø§Ø¦Ù‚ Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©.",
    alertNoPrintAll: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©.",

    printCallsTitle: "Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù†Ø¯Ø§Ø¡Ø§Øª",
    printCallsHeadingAll: "Ø§Ù„Ù†Ø¯Ø§Ø¡Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©",
    printCallsHeadingForDriver: "Ø§Ù„Ù†Ø¯Ø§Ø¡Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© â€” {{driverName}}",
    printMerchantLabel: "Ø§Ù„Ù…ØªØ¬Ø±",

    printSingleOrderTitlePrefix: "Ø·Ù„Ø¨",
    printSingleOrderHeadingPrefix: "Ø·Ù„Ø¨",
    printSingleOrderDriverLabel: "Ø§Ù„Ø³Ø§Ø¦Ù‚",
    printSingleOrderDriverPhoneLabel: "Ù‡Ø§ØªÙ Ø§Ù„Ø³Ø§Ø¦Ù‚",
    printSingleOrderCustomerLabel: "Ø§Ù„Ø¹Ù…ÙŠÙ„",
    printSingleOrderAddressLabel: "Ø§Ù„Ø¹Ù†ÙˆØ§Ù†",
    printSingleOrderCostLabel: "Ø§Ù„ØªÙƒÙ„ÙØ©",
	    // === Order details modal ===
    orderDetailsModalTitle: "ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨",
    orderDetailsHeadingPrefix: "Ø·Ù„Ø¨ / Ù†Ø¯Ø§Ø¡",
    orderDetailsStatusLabel: "Ø§Ù„Ø­Ø§Ù„Ø©",
    orderDetailsDateLabel: "ØªØ§Ø±ÙŠØ®",
    orderDetailsDriverLabel: "Ø§Ù„Ø³Ø§Ø¦Ù‚",
    orderDetailsDriverPhoneLabel: "Ù‡Ø§ØªÙ Ø§Ù„Ø³Ø§Ø¦Ù‚",
    orderDetailsCityLabel: "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©",
    orderDetailsCustomerNameLabel: "Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„",
    orderDetailsAddressLabel: "Ø§Ù„Ø¹Ù†ÙˆØ§Ù†",
    orderDetailsTotalDistanceLabel: "Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ÙƒÙ„ÙŠØ© Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹Ø©",
    orderDetailsSegmentDistancesLabel: "Ù…Ù† Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø¥Ù„Ù‰ Ø§Ù„ØªØ§Ø¬Ø±: {{d1}} / Ù…Ù† Ø§Ù„ØªØ§Ø¬Ø± Ø¥Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ³Ù„ÙŠÙ…: {{d2}}",
    orderDetailsDeliveryCostLabel: "ØªÙƒÙ„ÙØ© Ø§Ù„ØªÙˆØµÙŠÙ„",
    orderDetailsNotesLabel: "Ù…Ù„Ø§Ø­Ø¸Ø§Øª",
    orderDetailsPrintBtn: "Ø·Ø¨Ø§Ø¹Ø©",
    orderDetailsCancelBtn: "Ø¥Ù„ØºØ§Ø¡",
    orderDetailsCloseBtn: "Ø¥ØºÙ„Ø§Ù‚",

    // Alerts / confirm
    confirmCancelOrder: "Ù‡Ù„ ØªØ±ØºØ¨ ÙØ¹Ù„Ø§Ù‹ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ØŸ",
    alertMerchantNotSet: "Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ§Ø¬Ø±.",
    alertOrderNotFound: "Ø·Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯",
    alertCancelOrderErrorPrefix: "Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨: ",

  },
  en: {
    pageTitle: "Delivery System â€” Merchant Interface",
    mainHeader: "Delivery System â€” Merchant Interface",
    languageLabel: "Language:",
    tabRegister: "Register",
    tabLogin: "Login",
    registerTitle: "Merchant registration",
    storeNamePlaceholder: "Store name",
    storeAddressPlaceholder: "Store address",
    storeCityPlaceholder: "City",
    storePhonePlaceholder: "Store phone number",
    contactNamePlaceholder: "Contact person name",
    contactPhonePlaceholder: "Contact person phone",
    contactEmailPlaceholder: "Contact email",
    merchantPasswordPlaceholder: "Password (6+ characters)",
    registerSubmit: "Register merchant",
    loginTitle: "Login (merchant)",
    loginEmailPlaceholder: "Email",
    loginPasswordPlaceholder: "Password",
    loginSubmit: "Login",
    topbarOnline: "Online",
    topbarOffline: "Offline",
    topbarTotalDelivery: "Total delivery",
    onlineDriversLabel: "Available drivers",
    statsActiveCalls: "Active calls",
    statsPastCalls: "Past calls",
    statsTotalDelivery: "Total delivery",
    activeOrdersTitle: "Active orders",
    completedOrdersTitle: "Past orders",
    filterAllDrivers: "All",
    sortDateDesc: "Newest first",
    sortDateAsc: "Oldest first",
    sortDriverAsc: "Driver Aâ€“Z",
    sortDriverDesc: "Driver Zâ€“A",
    exportCsv: "Export CSV",
    print: "Print",
    logout: "Logout",
    
	    callStatusLabel: "Call status",
    toastNoMerchant: "Cannot send a call: current merchant is not set.",
    toastOffline: "You can't send calls while you are offline. Please switch to online first.",
    toastDriverBusy: "The driver is currently busy and cannot be called.",
    toastCallSentPrefix: "Call sent to driver",
    toastErrorSendCallPrefix: "Error while sending the call:",
    toastDriverHeadingMerchantWithName: "Driver {{name}} is on the way to you",
    toastDriverHeadingMerchantNoName: "The driver is on the way to you",
    toastDriverHeadingCustomerWithName: "Driver {{name}} is on the way to the customer",
    toastDriverHeadingCustomerNoName: "The driver is on the way to the customer",
// === CSV / Print ===
    csvHeaderId: "ID",
    csvHeaderDriverId: "Driver ID",
    csvHeaderDriverName: "Driver name",
    csvHeaderStatus: "Status",
    csvHeaderRequestTime: "Request time",
    csvHeaderResponseTime: "Response time",
    csvHeaderMerchantName: "Merchant name",
    csvHeaderMerchantCity: "Merchant city",

    alertNoExportForDriver: "There are no past orders for this driver to export.",
    alertNoExportAll: "There are no orders to export.",
    alertNoPrintForDriver: "There are no past orders for this driver to print.",
    alertNoPrintAll: "There are no past orders to print.",

    printCallsTitle: "Print calls",
    printCallsHeadingAll: "Past calls",
    printCallsHeadingForDriver: "Past calls â€” {{driverName}}",
    printMerchantLabel: "Merchant",

    printSingleOrderTitlePrefix: "Order",
    printSingleOrderHeadingPrefix: "Order",
    printSingleOrderDriverLabel: "Driver",
    printSingleOrderDriverPhoneLabel: "Driver phone",
    printSingleOrderCustomerLabel: "Customer",
    printSingleOrderAddressLabel: "Address",
    printSingleOrderCostLabel: "Cost",
	    // === Order details modal ===
    orderDetailsModalTitle: "Order details",
    orderDetailsHeadingPrefix: "Order / Call",
    orderDetailsStatusLabel: "Status",
    orderDetailsDateLabel: "Date",
    orderDetailsDriverLabel: "Driver",
    orderDetailsDriverPhoneLabel: "Driver phone",
    orderDetailsCityLabel: "City",
    orderDetailsCustomerNameLabel: "Customer name",
    orderDetailsAddressLabel: "Address",
    orderDetailsTotalDistanceLabel: "Total distance travelled",
    orderDetailsSegmentDistancesLabel: "Driver â†’ merchant: {{d1}} / Merchant â†’ drop-off: {{d2}}",
    orderDetailsDeliveryCostLabel: "Delivery cost",
    orderDetailsNotesLabel: "Notes",
    orderDetailsPrintBtn: "Print",
    orderDetailsCancelBtn: "Cancel",
    orderDetailsCloseBtn: "Close",

    // Alerts / confirm
    confirmCancelOrder: "Do you really want to cancel this order?",
    alertMerchantNotSet: "Merchant is not set.",
    alertOrderNotFound: "Order not found.",
    alertCancelOrderErrorPrefix: "Error while cancelling the order: ",

  },
  de: {
    pageTitle: "Liefersystem â€” HÃ¤ndleroberflÃ¤che",
    mainHeader: "Liefersystem â€” HÃ¤ndleroberflÃ¤che",
    languageLabel: "Sprache:",
    tabRegister: "Registrieren",
    tabLogin: "Anmelden",
    registerTitle: "HÃ¤ndler registrieren",
    storeNamePlaceholder: "Name des GeschÃ¤fts",
    storeAddressPlaceholder: "Adresse des GeschÃ¤fts",
    storeCityPlaceholder: "Stadt",
    storePhonePlaceholder: "Telefon des GeschÃ¤fts",
    contactNamePlaceholder: "Ansprechperson",
    contactPhonePlaceholder: "Telefon der Ansprechperson",
    contactEmailPlaceholder: "E-Mail der Ansprechperson",
    merchantPasswordPlaceholder: "Passwort (mind. 6 Zeichen)",
    registerSubmit: "HÃ¤ndler registrieren",
    loginTitle: "Anmeldung (HÃ¤ndler)",
    loginEmailPlaceholder: "E-Mail",
    loginPasswordPlaceholder: "Passwort",
    loginSubmit: "Anmelden",
    topbarOnline: "Online",
    topbarOffline: "Offline",
    topbarTotalDelivery: "Lieferkosten",
    onlineDriversLabel: "VerfÃ¼gbare Fahrer",
    statsActiveCalls: "Aktive Lieferung",
    statsPastCalls: "Alte Lieferung",
    statsTotalDelivery: "Lieferkosten",
    activeOrdersTitle: "Aktive Lieferung",
    completedOrdersTitle: "Alte Lieferungen",
    filterAllDrivers: "Alle",
    sortDateDesc: "Neueste zuerst",
    sortDateAsc: "Ã„lteste zuerst",
    sortDriverAsc: "Fahrer Aâ€“Z",
    sortDriverDesc: "Fahrer Zâ€“A",
    exportCsv: "CSV exportieren",
    print: "Drucken",
    logout: "Abmelden",
        callStatusLabel: "Anfragestatus",
    toastNoMerchant: "Anfrage kann nicht gesendet werden: aktueller HÃ¤ndler ist nicht festgelegt.",
    toastOffline: "Sie kÃ¶nnen keine Anfragen senden, wÃ¤hrend Sie offline sind. Bitte gehen Sie zuerst online.",
    toastDriverBusy: "Der Fahrer ist momentan beschÃ¤ftigt und kann nicht angefragt werden.",
    toastCallSentPrefix: "Anfrage an Fahrer gesendet",
    toastErrorSendCallPrefix: "Fehler beim Senden der Anfrage:",
    toastDriverHeadingMerchantWithName: "Fahrer {{name}} ist auf dem Weg zu Ihnen",
    toastDriverHeadingMerchantNoName: "Der Fahrer ist auf dem Weg zu Ihnen",
    toastDriverHeadingCustomerWithName: "Fahrer {{name}} ist auf dem Weg zum Kunden",
    toastDriverHeadingCustomerNoName: "Der Fahrer ist auf dem Weg zum Kunden",
// === CSV / Print ===
    csvHeaderId: "ID",
    csvHeaderDriverId: "Fahrer-ID",
    csvHeaderDriverName: "Fahrername",
    csvHeaderStatus: "Status",
    csvHeaderRequestTime: "Anfragezeit",
    csvHeaderResponseTime: "Antwortzeit",
    csvHeaderMerchantName: "HÃ¤ndlername",
    csvHeaderMerchantCity: "HÃ¤ndlerstadt",

    alertNoExportForDriver: "FÃ¼r diesen Fahrer gibt es keine frÃ¼heren Bestellungen zum Exportieren.",
    alertNoExportAll: "Es gibt keine Bestellungen zum Exportieren.",
    alertNoPrintForDriver: "FÃ¼r diesen Fahrer gibt es keine frÃ¼heren Bestellungen zum Drucken.",
    alertNoPrintAll: "Es gibt keine frÃ¼heren Bestellungen zum Drucken.",

    printCallsTitle: "Anfragen drucken",
    printCallsHeadingAll: "FrÃ¼here Anfragen",
    printCallsHeadingForDriver: "FrÃ¼here Anfragen â€” {{driverName}}",
    printMerchantLabel: "HÃ¤ndler",

    printSingleOrderTitlePrefix: "Bestellung",
    printSingleOrderHeadingPrefix: "Bestellung",
    printSingleOrderDriverLabel: "Fahrer",
    printSingleOrderDriverPhoneLabel: "Fahrertelefon",
    printSingleOrderCustomerLabel: "Kunde",
    printSingleOrderAddressLabel: "Adresse",
    printSingleOrderCostLabel: "Kosten",
	    // === Order details modal ===
    orderDetailsModalTitle: "Bestelldetails",
    orderDetailsHeadingPrefix: "Bestellung / Anfrage",
    orderDetailsStatusLabel: "Status",
    orderDetailsDateLabel: "Datum",
    orderDetailsDriverLabel: "Fahrer",
    orderDetailsDriverPhoneLabel: "Fahrertelefon",
    orderDetailsCityLabel: "Stadt",
    orderDetailsCustomerNameLabel: "Kundenname",
    orderDetailsAddressLabel: "Adresse",
    orderDetailsTotalDistanceLabel: "Gesamt zurÃ¼ckgelegte Strecke",
    orderDetailsSegmentDistancesLabel: "Vom Fahrer zum HÃ¤ndler: {{d1}} / Vom HÃ¤ndler zum Ziel: {{d2}}",
    orderDetailsDeliveryCostLabel: "Lieferkosten",
    orderDetailsNotesLabel: "Notizen",
    orderDetailsPrintBtn: "Drucken",
    orderDetailsCancelBtn: "Stornieren",
    orderDetailsCloseBtn: "SchlieÃŸen",

    // Alerts / confirm
    confirmCancelOrder: "MÃ¶chten Sie diese Bestellung wirklich stornieren?",
    alertMerchantNotSet: "HÃ¤ndler ist nicht gesetzt.",
    alertOrderNotFound: "Bestellung nicht gefunden.",
    alertCancelOrderErrorPrefix: "Fehler beim Stornieren der Bestellung: ",

  },
  tr: {
    pageTitle: "Teslimat Sistemi â€” Ä°ÅŸletme ArayÃ¼zÃ¼",
    mainHeader: "Teslimat Sistemi â€” Ä°ÅŸletme ArayÃ¼zÃ¼",
    languageLabel: "Dil:",
    tabRegister: "KayÄ±t ol",
    tabLogin: "GiriÅŸ yap",
    registerTitle: "Ä°ÅŸletme kaydÄ±",
    storeNamePlaceholder: "Ä°ÅŸletme adÄ±",
    storeAddressPlaceholder: "Ä°ÅŸletme adresi",
    storeCityPlaceholder: "Åehir",
    storePhonePlaceholder: "Ä°ÅŸletme telefonu",
    contactNamePlaceholder: "Yetkili kiÅŸi adÄ±",
    contactPhonePlaceholder: "Yetkili telefonu",
    contactEmailPlaceholder: "Yetkili e-posta",
    merchantPasswordPlaceholder: "Åifre (en az 6 karakter)",
    registerSubmit: "Ä°ÅŸletmeyi kaydet",
    loginTitle: "GiriÅŸ (iÅŸletme)",
    loginEmailPlaceholder: "E-posta",
    loginPasswordPlaceholder: "Åifre",
    loginSubmit: "GiriÅŸ yap",
    topbarOnline: "Ã‡evrimiÃ§i",
    topbarOffline: "Ã‡evrimdÄ±ÅŸÄ±",
    topbarTotalDelivery: "Toplam teslimat",
    onlineDriversLabel: "MÃ¼sait sÃ¼rÃ¼cÃ¼ler",
    statsActiveCalls: "Aktif Ã§aÄŸrÄ±lar",
    statsPastCalls: "GeÃ§miÅŸ Ã§aÄŸrÄ±lar",
    statsTotalDelivery: "Toplam teslimat",
    activeOrdersTitle: "Aktif sipariÅŸler",
    completedOrdersTitle: "GeÃ§miÅŸ sipariÅŸler",
    filterAllDrivers: "TÃ¼mÃ¼",
    sortDateDesc: "En yeni Ã¶nce",
    sortDateAsc: "En eski Ã¶nce",
    sortDriverAsc: "SÃ¼rÃ¼cÃ¼ Aâ€“Z",
    sortDriverDesc: "SÃ¼rÃ¼cÃ¼ Zâ€“A",
    exportCsv: "CSV dÄ±ÅŸa aktar",
    print: "YazdÄ±r",
    logout: "Ã‡Ä±kÄ±ÅŸ yap",
        callStatusLabel: "Ã‡aÄŸrÄ± durumu",
    toastNoMerchant: "Ã‡aÄŸrÄ± gÃ¶nderilemiyor: geÃ§erli iÅŸletme tanÄ±mlÄ± deÄŸil.",
    toastOffline: "Ã‡evrimdÄ±ÅŸÄ±yken Ã§aÄŸrÄ± gÃ¶nderemezsiniz. LÃ¼tfen Ã¶nce Ã§evrimiÃ§i moda geÃ§in.",
    toastDriverBusy: "SÃ¼rÃ¼cÃ¼ ÅŸu anda meÅŸgul, Ã§aÄŸrÄ± gÃ¶nderilemez.",
    toastCallSentPrefix: "SÃ¼rÃ¼cÃ¼ye Ã§aÄŸrÄ± gÃ¶nderildi",
    toastErrorSendCallPrefix: "Ã‡aÄŸrÄ± gÃ¶nderilirken hata oluÅŸtu:",
    toastDriverHeadingMerchantWithName: "SÃ¼rÃ¼cÃ¼ {{name}} size doÄŸru yolda",
    toastDriverHeadingMerchantNoName: "SÃ¼rÃ¼cÃ¼ size doÄŸru yolda",
    toastDriverHeadingCustomerWithName: "SÃ¼rÃ¼cÃ¼ {{name}} mÃ¼ÅŸteriye doÄŸru yolda",
    toastDriverHeadingCustomerNoName: "SÃ¼rÃ¼cÃ¼ mÃ¼ÅŸteriye doÄŸru yolda",
// === CSV / Print ===
    csvHeaderId: "ID",
    csvHeaderDriverId: "SÃ¼rÃ¼cÃ¼ ID",
    csvHeaderDriverName: "SÃ¼rÃ¼cÃ¼ adÄ±",
    csvHeaderStatus: "Durum",
    csvHeaderRequestTime: "Ã‡aÄŸrÄ± zamanÄ±",
    csvHeaderResponseTime: "YanÄ±t zamanÄ±",
    csvHeaderMerchantName: "Ä°ÅŸletme adÄ±",
    csvHeaderMerchantCity: "Ä°ÅŸletme ÅŸehri",

    alertNoExportForDriver: "Bu sÃ¼rÃ¼cÃ¼ iÃ§in dÄ±ÅŸa aktarÄ±lacak geÃ§miÅŸ sipariÅŸ yok.",
    alertNoExportAll: "DÄ±ÅŸa aktarÄ±lacak sipariÅŸ yok.",
    alertNoPrintForDriver: "Bu sÃ¼rÃ¼cÃ¼ iÃ§in yazdÄ±rÄ±lacak geÃ§miÅŸ sipariÅŸ yok.",
    alertNoPrintAll: "YazdÄ±rÄ±lacak geÃ§miÅŸ sipariÅŸ yok.",

    printCallsTitle: "Ã‡aÄŸrÄ±larÄ± yazdÄ±r",
    printCallsHeadingAll: "GeÃ§miÅŸ Ã§aÄŸrÄ±lar",
    printCallsHeadingForDriver: "GeÃ§miÅŸ Ã§aÄŸrÄ±lar â€” {{driverName}}",
    printMerchantLabel: "Ä°ÅŸletme",

    printSingleOrderTitlePrefix: "SipariÅŸ",
    printSingleOrderHeadingPrefix: "SipariÅŸ",
    printSingleOrderDriverLabel: "SÃ¼rÃ¼cÃ¼",
    printSingleOrderDriverPhoneLabel: "SÃ¼rÃ¼cÃ¼ telefonu",
    printSingleOrderCustomerLabel: "MÃ¼ÅŸteri",
    printSingleOrderAddressLabel: "Adres",
    printSingleOrderCostLabel: "Ãœcret",
	    // === Order details modal ===
    orderDetailsModalTitle: "SipariÅŸ detaylarÄ±",
    orderDetailsHeadingPrefix: "SipariÅŸ / Ã‡aÄŸrÄ±",
    orderDetailsStatusLabel: "Durum",
    orderDetailsDateLabel: "Tarih",
    orderDetailsDriverLabel: "SÃ¼rÃ¼cÃ¼",
    orderDetailsDriverPhoneLabel: "SÃ¼rÃ¼cÃ¼ telefonu",
    orderDetailsCityLabel: "Åehir",
    orderDetailsCustomerNameLabel: "MÃ¼ÅŸteri adÄ±",
    orderDetailsAddressLabel: "Adres",
    orderDetailsTotalDistanceLabel: "Toplam gidilen mesafe",
    orderDetailsSegmentDistancesLabel: "SÃ¼rÃ¼cÃ¼ â†’ iÅŸletme: {{d1}} / Ä°ÅŸletme â†’ teslimat noktasÄ±: {{d2}}",
    orderDetailsDeliveryCostLabel: "Teslimat Ã¼creti",
    orderDetailsNotesLabel: "Notlar",
    orderDetailsPrintBtn: "YazdÄ±r",
    orderDetailsCancelBtn: "Ä°ptal et",
    orderDetailsCloseBtn: "Kapat",

    // Alerts / confirm
    confirmCancelOrder: "Bu sipariÅŸi gerÃ§ekten iptal etmek istiyor musunuz?",
    alertMerchantNotSet: "Ä°ÅŸletme tanÄ±mlÄ± deÄŸil.",
    alertOrderNotFound: "SipariÅŸ bulunamadÄ±.",
    alertCancelOrderErrorPrefix: "SipariÅŸ iptal edilirken hata oluÅŸtu: ",

  }
};

let currentLang = "ar";
function t(key) {
  const dict = I18N[currentLang] || I18N.ar;
  if (dict && Object.prototype.hasOwnProperty.call(dict, key)) {
    return dict[key];
  }
  if (I18N.ar && Object.prototype.hasOwnProperty.call(I18N.ar, key)) {
    return I18N.ar[key];
  }
  return key;
}
// === ØªØ±Ø¬Ù…Ø© Ø¨Ø§Ù„ÙˆÙ† Ø§Ù„Ù€ ETA Ø­Ø³Ø¨ currentLang ===
function getEtaArrivedText() {
  const lang = currentLang || "ar";
  switch (lang) {
    case "en":
      return "Arriving now";
    case "de":
      return "Kommt gleich an";
    case "tr":
      return "Neredeyse geldi";
    default: // ar
      return "ÙˆØµÙ„ ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹";
  }
}

function getEtaLabelText(remainingSeconds) {
  const lang = currentLang || "ar";
  const mins = Math.floor(remainingSeconds / 60);
  const secs = remainingSeconds % 60;
  const mmss = `${mins}:${String(secs).padStart(2, "0")}`;

  switch (lang) {
    case "en":
      return `ğŸ•’ ETA in ${mmss} min`;
    case "de":
      return `ğŸ•’ Voraussichtliche Ankunft in ${mmss} Min`;
    case "tr":
      return `ğŸ•’ Tahmini varÄ±ÅŸ ${mmss} dk iÃ§inde`;
    default: // ar
      return `ğŸ•’ Ù…ØªÙˆÙ‚Ø¹ Ø®Ù„Ø§Ù„ ${mmss} Ø¯Ù‚ÙŠÙ‚Ø©`;
  }
}

function getNearCountdownText(secondsLeft) {
  const lang = currentLang || "ar";
  const mins = Math.floor(secondsLeft / 60);
  const secs = secondsLeft % 60;
  const mmss = `${mins}:${String(secs).padStart(2, "0")}`;

  switch (lang) {
    case "en":
      return `â³ Arriving in ${mmss}`;
    case "de":
      return `â³ Ankunft in ${mmss}`;
    case "tr":
      return `â³ YaklaÅŸÄ±k ${mmss} iÃ§inde varÄ±r`;
    default: // ar
      return `â³ ÙŠØµÙ„ Ø®Ù„Ø§Ù„ ${mmss}`;
  }
}

/* ========== Ø¥Ø¹Ø¯Ø§Ø¯ Firebase ========== */
const firebaseConfig = {
  apiKey: "AIzaSyBhiKPw7M3NMCOhzoBJJyI9enOa6qZQnHc",
  authDomain: "delivera-7pq7jc.firebaseapp.com",
  projectId: "delivera-7pq7jc",
  storageBucket: "delivera-7pq7jc.appspot.com",
  messagingSenderId: "186649231022",
  appId: "1:186649231022:web:18e76b00018fbb5d68773f"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
// Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
const BASE_DELIVERY_FEE = 3.5; // EUR
// Ù…Ø³Ø§Ø± Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù…Ø§Ø±ÙƒØ± Ø§Ù„ØªØ§Ø¬Ø± (ØºÙŠÙ‘Ø±Ù‡ Ù„Ù…Ø§ ÙŠÙ†Ø§Ø³Ø¨Ùƒ)
const MERCHANT_MARKER_ICON_PATH = "markt 1.png";
// Ù…Ø³Ø§Ø± Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù…Ø§Ø±ÙƒØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ (ØºÙŠÙ‘Ø±Ù‡ Ù„Ù…Ø§ ÙŠÙ†Ø§Ø³Ø¨Ùƒ)
const CUSTOMER_MARKER_ICON_PATH = "kunde.png";

/* ========== Ø¹Ù†Ø§ØµØ± DOM ========== */
const registerTab = document.getElementById("registerTab");
const loginTab = document.getElementById("loginTab");
const registerSection = document.getElementById("registerSection");
const loginSection = document.getElementById("loginSection");

const merchantForm = document.getElementById("merchantForm");
const loginForm = document.getElementById("loginForm");

const merchantDashboard = document.getElementById("merchantDashboard");
const merchantNameEl = document.getElementById("merchantName");
const merchantCityEl = document.getElementById("merchantCity");
const logoutBtn = document.getElementById("logoutBtn");

const mapContainer = document.getElementById("map");
const activeOrdersEl = document.getElementById("activeOrders");
const completedOrdersEl = document.getElementById("completedOrders");
const countActiveEl = document.getElementById("countActive");
const countCompletedEl = document.getElementById("countCompleted");

const filterDriver = document.getElementById("filterDriver");
const sortActive = document.getElementById("sortActive");
const sortCompleted = document.getElementById("sortCompleted");
const exportCsvBtn = document.getElementById("exportCsv");
const printBtn = document.getElementById("printBtn");

const modalBackdrop = document.getElementById("modalBackdrop");
const modalContent = document.getElementById("modalContent");

const orderModalEl = document.getElementById("orderModal");
/* ========== Toast helper ========== */
const toastContainer = document.getElementById("toastContainer");

function showToast(message, type = "success") {
  if (!toastContainer) return;

  const toast = document.createElement("div");
  toast.className = "toast " + (type === "error" ? "toast-error" : "toast-success");

  const iconSpan = document.createElement("span");
  iconSpan.className = "toast-icon";
  iconSpan.textContent = type === "error" ? "âš ï¸" : "âœ…";

  const textSpan = document.createElement("span");
  textSpan.textContent = message;

  toast.appendChild(iconSpan);
  toast.appendChild(textSpan);
  toastContainer.appendChild(toast);

  setTimeout(() => {
    toast.classList.add("fade-out");
    toast.addEventListener("transitionend", () => {
      toast.remove();
    });
  }, 2500);
}

/* Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ + Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©) */
const merchantMenuBtn = document.getElementById("merchantMenuBtn");
const merchantOnlineToggle = document.getElementById("merchantOnlineToggle");
const merchantEarningsTopEl = document.getElementById("merchantEarnings");
const onlineDriversBadge = document.getElementById("onlineDriversBadge");

const merchantSidePanel = document.getElementById("merchantSidePanel");
const merchantSidePanelBackdrop = document.getElementById("merchantSidePanelBackdrop");
const closeSidePanelBtn = document.getElementById("closeSidePanel");
// ØµÙˆØª Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† Ù„Ù„ØªØ§Ø¬Ø± + Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†
const merchantOnlineSoundEl = document.getElementById("merchantOnlineSound");
const merchantCallSoundEl   = document.getElementById("merchantCallSound");
const callAcceptedSoundEl     = document.getElementById("callAcceptedSound");
const driverOnWaySoundEl      = document.getElementById("driverOnWaySound");
const driverNearSoundEl       = document.getElementById("driverNearSound");
// ØµÙˆØª ØªØ³Ù„ÙŠÙ… Ø§Ù„Ø·Ù„Ø¨ (Ù„Ø±Ø­Ù„Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„)
const customerDeliveredSoundEl = document.getElementById("customerDeliveredSound");

let merchantCurrentOnline = false;
let playMerchantOnlineSoundNext = false;
/* ========== Ù…ØªØºÙŠÙ‘Ø±Ø§Øª Ø§Ù„Ø®Ø±ÙŠØ·Ø© ÙˆØ§Ù„Ø³Ø§Ø¦Ù‚ÙŠÙ† ========== */
let map;
let driverMarkers = {};
let merchantMarker = null;
let ordersListenerUnsub = null;
let driversListenerUnsub = null;
let merchantCallsListenerUnsub = null;
let currentMerchantId = null;
let cachedDrivers = {}; // id -> data
let lastCallsCache = [];
function hasActiveCallForDriver(driverId) {
  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  return lastCallsCache.some((c) => {
    if (c.driverId !== driverId) return false;
    const st = (c.status || "pending").toLowerCase();
    return !completedStatuses.includes(st);
  });
}

let merchantLocationLat = null;
let merchantLocationLng = null;
let directionsService = null;

let currentTrackedCallId = null;
let currentTrackedDriverId = null;

const driverHaloState = {};
const multiTrackingByDriver = {};
const multiCustomerMarkers = {};

let trackedDriverId = null;
let trackedRoutePolyline = null;
let trackedRouteFullPath = [];
let trackedEtaInfoWindow = null;
let trackedEtaTimerId = null;
let trackedEtaSeconds = null;
let trackedEtaUpdatedAt = null;
let trackedNearAlertPlayed = false;
let lastDriverRouteRequestAt = 0;
let nearCountdownTimerId = null;
let nearCountdownSeconds = null;

let trackedLastDistanceMeters = null;
let driverRouteAvgSpeedMps = null;

const MAX_DRIVER_TO_MERCHANT_DIRECTIONS = 2;
let driverToMerchantDirectionsCountByCall = {};

let currentDestinationLat = null;
let currentDestinationLng = null;
let currentDestinationType = null;
let currentDestinationAddress = null;

let customerMarker = null;
let currentCustomerName = "";

let directionsRequestedForCurrentLeg = false;
let mapFittedForCurrentLeg = false;

let lastCallsById = {};

/* ========== ÙØªØ­/Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ§Ø¬Ø± ========== */
if (merchantMenuBtn && merchantSidePanel && merchantSidePanelBackdrop) {
  merchantMenuBtn.addEventListener("click", () => {
    merchantSidePanel.classList.add("open");
    merchantSidePanelBackdrop.classList.add("visible");
  });
}

if (closeSidePanelBtn) {
  closeSidePanelBtn.addEventListener("click", () => {
    merchantSidePanel.classList.remove("open");
    merchantSidePanelBackdrop.classList.remove("visible");
  });
}

if (merchantSidePanelBackdrop) {
  merchantSidePanelBackdrop.addEventListener("click", () => {
    merchantSidePanel.classList.remove("open");
    merchantSidePanelBackdrop.classList.remove("visible");
  });
}

/* ========== Ø²Ø± Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† / Ø£ÙˆÙÙ„Ø§ÙŠÙ† Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„ØªØ§Ø¬Ø± (Ù…Ø±ØªØ¨Ø· Ø¨Ù€ Firestore + ØµÙˆØª) ========== */
function updateMerchantOnlineBtn() {
  if (!merchantOnlineToggle) return;

  if (merchantCurrentOnline) {
    merchantOnlineToggle.textContent = t("topbarOnline");
    merchantOnlineToggle.dataset.state = "online";
  } else {
    merchantOnlineToggle.textContent = t("topbarOffline");
    merchantOnlineToggle.dataset.state = "offline";
  }

  merchantOnlineToggle.classList.remove("blink");

  if (merchantCurrentOnline && playMerchantOnlineSoundNext && merchantOnlineSoundEl) {
    try {
      merchantOnlineSoundEl.currentTime = 0;
      merchantOnlineSoundEl.play();
    } catch (e) {
      console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† Ø§Ù„ØªØ§Ø¬Ø±:", e);
    }
  }

  playMerchantOnlineSoundNext = false;

  if (merchantCurrentOnline) {
    ensureMerchantMarkerOnMap();
  } else {
    hideMerchantMarker();
  }
}

if (merchantOnlineToggle) {
  merchantOnlineToggle.addEventListener("click", async () => {
    if (!currentMerchantId) {
      alert("Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ.");
      return;
    }

    const goingOnline = !merchantCurrentOnline;
    merchantCurrentOnline = goingOnline;

    if (goingOnline) {
      playMerchantOnlineSoundNext = true;
      merchantOnlineToggle.classList.add("blink");
    }

    try {
      const updateData = goingOnline
        ? {
            online: true,
            lastOnline: firebase.firestore.FieldValue.serverTimestamp()
          }
        : {
            online: false
          };

      await db.collection("merchants").doc(currentMerchantId).update(updateData);

      updateMerchantOnlineBtn();
    } catch (err) {
      merchantCurrentOnline = !goingOnline;
      playMerchantOnlineSoundNext = false;
      merchantOnlineToggle.classList.remove("blink");
      alert("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ§Ø¬Ø±: " + err.message);
    }
  });

  updateMerchantOnlineBtn();
}

/* ========== ØªØ¨ÙˆÙŠØ¨Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„/Ø§Ù„Ø¯Ø®ÙˆÙ„ ========== */
registerTab.addEventListener("click", () => {
  registerTab.classList.add("active");
  loginTab.classList.remove("active");
  registerSection.classList.remove("hidden");
  loginSection.classList.add("hidden");
});
loginTab.addEventListener("click", () => {
  loginTab.classList.add("active");
  registerTab.classList.remove("active");
  loginSection.classList.remove("hidden");
  registerSection.classList.add("hidden");
});

/* ========== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ§Ø¬Ø± ========== */
merchantForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const storeName = document.getElementById("storeName").value.trim();
  const storeAddress = document.getElementById("storeAddress").value.trim();
  const storeCity = document.getElementById("storeCity").value.trim();
  const storePhone = document.getElementById("storePhone").value.trim();
  const contactName = document.getElementById("contactName").value.trim();
  const contactPhone = document.getElementById("contactPhone").value.trim();
  const contactEmail = document.getElementById("contactEmail").value.trim();
  const password = document.getElementById("merchantPassword").value;
  if (password.length < 6) return alert("ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.");
  try {
    const userCredential = await auth.createUserWithEmailAndPassword(
      contactEmail,
      password
    );
    const uid = userCredential.user.uid;
    await db.collection("merchants").doc(uid).set({
      storeName,
      storeAddress,
      storeCity,
      storePhone,
      contactName,
      contactPhone,
      contactEmail,
      role: "merchant",
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    alert("ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ§Ø¬Ø± Ø¨Ù†Ø¬Ø§Ø­!");
    merchantForm.reset();
  } catch (err) {
    alert("Ø®Ø·Ø£: " + err.message);
  }
});

/* ========== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ (ØªØ§Ø¬Ø± ÙÙ‚Ø·) ========== */
loginForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const email = document.getElementById("loginEmail").value.trim();
  const password = document.getElementById("loginPassword").value;

  try {
    const userCredential = await auth.signInWithEmailAndPassword(
      email,
      password
    );
    const uid = userCredential.user.uid;

    const merchantDoc = await db.collection("merchants").doc(uid).get();

    if (merchantDoc.exists) {
      const merchantData = merchantDoc.data();
      merchantNameEl.textContent =
        merchantData.storeName || merchantData.contactName || "ØªØ§Ø¬Ø±";

      merchantCityEl.textContent =
        merchantData.storeAddress || merchantData.storeCity || "";

      merchantCurrentOnline = !!merchantData.online;
      updateMerchantOnlineBtn();

      registerSection.classList.add("hidden");
      loginSection.classList.add("hidden");
      merchantDashboard.classList.remove("hidden");
      document.getElementById("mainHeader").classList.add("hidden");
      document.getElementById("authTabs").classList.add("hidden");
      const langSwitcher = document.getElementById("langSwitcher");
      if (langSwitcher) langSwitcher.classList.add("hidden");

      initMapAndData(uid);
      document.body.classList.add("merchant-mode");
    } else {
      await auth.signOut();
      alert("Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ù…Ø®ØµØµØ© Ù„Ù„ØªØ¬Ø§Ø± ÙÙ‚Ø·. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ø§Ø¨Ø· ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø¥Ù† ÙƒÙ†Øª Ø³Ø§Ø¦Ù‚Ø§Ù‹.");
    }

    loginForm.reset();
  } catch (err) {
    alert("Ø®Ø·Ø£: " + err.message);
  }
});

/* ========== ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬ Ø§Ù„ØªØ§Ø¬Ø± ========== */
logoutBtn.addEventListener("click", async () => {
  await auth.signOut();

  merchantCurrentOnline = false;
  updateMerchantOnlineBtn();

  merchantDashboard.classList.add("hidden");
  registerSection.classList.remove("hidden");
  loginSection.classList.remove("hidden");
  document.getElementById("mainHeader").classList.remove("hidden");
  document.getElementById("authTabs").classList.remove("hidden");
  const langSwitcher = document.getElementById("langSwitcher");
  if (langSwitcher) langSwitcher.classList.remove("hidden");
  document.body.classList.remove("merchant-mode");
});

function createCircleIcon(color, scale) {
  return {
    path: google.maps.SymbolPath.CIRCLE,
    fillColor: color,
    fillOpacity: 0.9,
    scale: scale,
    strokeColor: "#ffffff",
    strokeWeight: 3
  };
}
function getMerchantMarkerIcon() {
  if (typeof google === "undefined" || !google.maps) return null;
  return {
    url: MERCHANT_MARKER_ICON_PATH,
    scaledSize: new google.maps.Size(52, 52),
    origin: new google.maps.Point(0, 0),
    anchor: new google.maps.Point(26, 46)
  };
}

function ensureMerchantMarkerOnMap() {
  if (!map) return;
  if (merchantLocationLat == null || merchantLocationLng == null) return;

  const pos = { lat: merchantLocationLat, lng: merchantLocationLng };

  if (!merchantMarker) {
    merchantMarker = new google.maps.Marker({
      position: pos,
      map,
      title: merchantNameEl.textContent || "Ø§Ù„Ù…Ø·Ø¹Ù…",
      icon: getMerchantMarkerIcon()
    });
  } else {
    merchantMarker.setPosition(pos);
    merchantMarker.setMap(map);
  }
}

function hideMerchantMarker() {
  if (merchantMarker) {
    merchantMarker.setMap(null);
  }
}
function getCustomerMarkerIcon() {
  if (typeof google === "undefined" || !google.maps) return null;
  return {
    url: CUSTOMER_MARKER_ICON_PATH,
    scaledSize: new google.maps.Size(46, 46),
    origin: new google.maps.Point(0, 0),
    anchor: new google.maps.Point(23, 40)
  };
}
function mtEnsureCustomerMarker(driverId, lat, lng, label) {
  if (!map || lat == null || lng == null) return;
  const pos = { lat, lng };
  let marker = multiCustomerMarkers[driverId];

  if (!marker) {
    marker = new google.maps.Marker({
      position: pos,
      map,
      title: label || "Ø§Ù„Ø¹Ù…ÙŠÙ„",
      icon: getCustomerMarkerIcon()
    });
    multiCustomerMarkers[driverId] = marker;
  } else {
    marker.setPosition(pos);
    marker.setMap(map);
  }
}

function mtHideCustomerMarkerForDriver(driverId) {
  const m = multiCustomerMarkers[driverId];
  if (m) {
    m.setMap(null);
    delete multiCustomerMarkers[driverId];
  }
}
function mtStartTrackingToMerchant(driverId, callId) {
  if (!driverMarkers[driverId] || !driverMarkers[driverId].marker) return;

  const tr = multiTrackingByDriver[driverId] || {};
  multiTrackingByDriver[driverId] = tr;

  tr.callId = callId;
  tr.leg = "merchant";
  tr.destinationType = "merchant";
  tr.destinationLat = merchantLocationLat;
  tr.destinationLng = merchantLocationLng;
  tr.destinationAddress = null;
  tr.customerName = "";
  tr.nearAlertPlayed = false;
  tr.directionsRequestedForCurrentLeg = false;
  tr.mapFittedForCurrentLeg = false;
  tr.lastRouteRequestAt = 0;

  if (tr.routePolyline) {
    tr.routePolyline.setMap(null);
    tr.routePolyline = null;
  }
  tr.routeFullPath = [];

  if (tr.etaInfoWindow) {
    tr.etaInfoWindow.close();
    tr.etaInfoWindow = null;
  }
  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }
  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }
  tr.etaSeconds = null;
  tr.etaUpdatedAt = null;
  tr.nearCountdownSeconds = null;

  mtUpdateRouteAndEta(driverId);
}

function mtStartTrackingToCustomer(driverId, callId, callData) {
  if (!driverMarkers[driverId] || !driverMarkers[driverId].marker) return;

  const tr = multiTrackingByDriver[driverId] || {};
  multiTrackingByDriver[driverId] = tr;

  mtHideCustomerMarkerForDriver(driverId);

  tr.callId = callId;
  tr.leg = "customer";
  tr.destinationType = "customer";
  tr.destinationLat = null;
  tr.destinationLng = null;
  tr.destinationAddress = callData.deliveryAddress || "";
  tr.customerName = (callData.customerName || "").trim();
  tr.nearAlertPlayed = false;
  tr.directionsRequestedForCurrentLeg = false;
  tr.mapFittedForCurrentLeg = false;
  tr.lastRouteRequestAt = 0;

  if (tr.routePolyline) {
    tr.routePolyline.setMap(null);
    tr.routePolyline = null;
  }
  tr.routeFullPath = [];

  if (tr.etaInfoWindow) {
    tr.etaInfoWindow.close();
    tr.etaInfoWindow = null;
  }
  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }
  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }
  tr.etaSeconds = null;
  tr.etaUpdatedAt = null;
  tr.nearCountdownSeconds = null;

  mtUpdateRouteAndEta(driverId);
}

function mtUpdateRouteProgress(driverId, currentLatLng) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || !tr.routePolyline) return;
  if (!tr.routeFullPath || tr.routeFullPath.length === 0) return;
  if (!google.maps || !google.maps.geometry || !google.maps.geometry.spherical)
    return;

  let closestIndex = 0;
  let minDist = Infinity;

  for (let i = 0; i < tr.routeFullPath.length; i++) {
    const p = tr.routeFullPath[i];
    const d = google.maps.geometry.spherical.computeDistanceBetween(
      currentLatLng,
      p
    );
    if (d < minDist) {
      minDist = d;
      closestIndex = i;
    }
  }

  if (minDist > 80) return;

  const remaining = tr.routeFullPath.slice(closestIndex);
  tr.routeFullPath = remaining;
  tr.routePolyline.setPath(remaining);
}

function mtUpdateRouteAndEta(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || !tr.destinationType) return;
  if (!map) return;

  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  const origin = markerState.marker.getPosition();
  if (!origin) return;

  mtUpdateRouteProgress(driverId, origin);

  const isCustomerLeg = tr.destinationType === "customer";

  let distanceMetersGeo = null;
  if (
    tr.destinationLat != null &&
    tr.destinationLng != null &&
    google.maps &&
    google.maps.geometry &&
    google.maps.geometry.spherical
  ) {
    const destLatLng = new google.maps.LatLng(tr.destinationLat, tr.destinationLng);
    distanceMetersGeo =
      google.maps.geometry.spherical.computeDistanceBetween(origin, destLatLng);
  }

  if (!tr.nearAlertPlayed && distanceMetersGeo != null && distanceMetersGeo <= 300) {
    tr.nearAlertPlayed = true;

    if (tr.destinationType === "merchant") {
      if (driverNearSoundEl) {
        try {
          driverNearSoundEl.currentTime = 0;
          driverNearSoundEl.play();
        } catch (e) {
          console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª Ù‚Ø±Ø¨ Ø§Ù„ÙˆØµÙˆÙ„:", e);
        }
      }

      if (tr.routePolyline) {
        tr.routePolyline.setMap(null);
        tr.routePolyline = null;
      }
      stopDriverHalo(driverId);

      if (tr.etaTimerId) {
        clearInterval(tr.etaTimerId);
        tr.etaTimerId = null;
      }
      tr.etaSeconds = null;
      tr.etaUpdatedAt = null;

      mtStartNearArrivalCountdown(driverId);
      return;
    } else if (tr.destinationType === "customer") {
      if (tr.etaTimerId) {
        clearInterval(tr.etaTimerId);
        tr.etaTimerId = null;
      }
      tr.etaSeconds = null;
      tr.etaUpdatedAt = null;

      mtStartNearArrivalCountdown(driverId);
      return;
    }
  }

  if (tr.nearAlertPlayed) return;

  if (!directionsService) {
    directionsService = new google.maps.DirectionsService();
  }

  const now = Date.now();
  if (!isCustomerLeg) {
    if (tr.lastRouteRequestAt && now - tr.lastRouteRequestAt < 10000) {
      return;
    }
    tr.lastRouteRequestAt = now;
  } else {
    if (tr.directionsRequestedForCurrentLeg) {
      return;
    }
    tr.directionsRequestedForCurrentLeg = true;
  }

  let destination;
  if (tr.destinationLat != null && tr.destinationLng != null) {
    destination = { lat: tr.destinationLat, lng: tr.destinationLng };
  } else if (tr.destinationAddress) {
    destination = tr.destinationAddress;
  } else if (
    tr.destinationType === "merchant" &&
    merchantLocationLat != null &&
    merchantLocationLng != null
  ) {
    destination = {
      lat: merchantLocationLat,
      lng: merchantLocationLng
    };
  } else {
    return;
  }

  directionsService.route(
    {
      origin,
      destination,
      travelMode: google.maps.TravelMode.DRIVING
    },
    (result, status) => {
      if (
        status !== "OK" ||
        !result.routes ||
        !result.routes[0] ||
        !result.routes[0].legs ||
        !result.routes[0].legs[0]
      ) {
        console.warn("ØªØ¹Ø°Ø± Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø± Ø§Ù„Ø³Ø§Ø¦Ù‚:", status, result);
        return;
      }

      const leg = result.routes[0].legs[0];
      const durationSeconds = leg.duration ? leg.duration.value : null;

      if (tr.destinationType === "customer" && leg.end_location) {
        tr.destinationLat = leg.end_location.lat();
        tr.destinationLng = leg.end_location.lng();
        mtEnsureCustomerMarker(
          driverId,
          tr.destinationLat,
          tr.destinationLng,
          tr.customerName || "Ø§Ù„Ø¹Ù…ÙŠÙ„"
        );
      } else if (
        tr.destinationType === "merchant" &&
        leg.end_location &&
        (tr.destinationLat == null || tr.destinationLng == null)
      ) {
        tr.destinationLat = leg.end_location.lat();
        tr.destinationLng = leg.end_location.lng();
      }

      if (!tr.mapFittedForCurrentLeg && map && origin) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend(origin);

        if (tr.destinationLat != null && tr.destinationLng != null) {
          bounds.extend(
            new google.maps.LatLng(tr.destinationLat, tr.destinationLng)
          );
        } else if (leg.end_location) {
          bounds.extend(leg.end_location);
        }

        map.fitBounds(bounds);
        tr.mapFittedForCurrentLeg = true;
      }

      const overviewPath = result.routes[0].overview_path;
      if (overviewPath && overviewPath.length) {
        tr.routeFullPath = overviewPath.slice();

        if (!tr.routePolyline) {
          tr.routePolyline = new google.maps.Polyline({
            map,
            path: tr.routeFullPath,
            strokeColor: "#22c55e",
            strokeOpacity: 0.8,
            strokeWeight: 4
          });
        } else {
          tr.routePolyline.setPath(tr.routeFullPath);
        }

        mtUpdateRouteProgress(driverId, origin);
      }

      if (durationSeconds != null) {
        tr.etaSeconds = durationSeconds;
        tr.etaUpdatedAt = Date.now();

        if (!tr.etaInfoWindow) {
          tr.etaInfoWindow = new google.maps.InfoWindow({
            pixelOffset: new google.maps.Size(0, -40),
            disableAutoPan: true
          });
        } else {
          tr.etaInfoWindow.setOptions({ disableAutoPan: true });
        }

        mtUpdateEtaBubble(driverId);

        if (!tr.etaTimerId) {
          tr.etaTimerId = setInterval(
            () => mtUpdateEtaBubble(driverId),
            1000
          );
        }
      }
    }
  );
}

function mtGetEtaSeconds(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || tr.etaSeconds == null || tr.etaUpdatedAt == null) return null;
  const elapsed = (Date.now() - tr.etaUpdatedAt) / 1000;
  return Math.max(0, Math.round(tr.etaSeconds - elapsed));
}

function mtUpdateEtaBubble(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || !tr.etaInfoWindow) return;

  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  const remaining = mtGetEtaSeconds(driverId);
  if (remaining == null) return;

  if (remaining <= 0) {
    const arrivedText = getEtaArrivedText();
    tr.etaInfoWindow.setContent(`
      <div style="
        background:#0f172a;
        color:#bbf7d0;
        padding:4px 8px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #22c55e;
      ">
        ${arrivedText}
      </div>
    `);
    tr.etaInfoWindow.open(map, markerState.marker);
    return;
  }

  const etaText = getEtaLabelText(remaining);

  const html = `
    <div style="
      background:#0f172a;
      color:#f9fafb;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      box-shadow:0 4px 12px rgba(15,23,42,0.6);
      border:1px solid #22c55e;
      white-space:nowrap;
    ">
      ${etaText}
    </div>
  `;
  tr.etaInfoWindow.setContent(html);
  tr.etaInfoWindow.open(map, markerState.marker);
}

function mtStartNearArrivalCountdown(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr) return;

  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }

  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }

  tr.nearCountdownSeconds = 60;

  if (!tr.etaInfoWindow) {
    tr.etaInfoWindow = new google.maps.InfoWindow({
      pixelOffset: new google.maps.Size(0, -40),
      disableAutoPan: true
    });
  } else {
    tr.etaInfoWindow.setOptions({ disableAutoPan: true });
  }

  const render = () => {
    const st = driverMarkers[driverId];
    if (!st || !st.marker || !st.marker.getMap()) {
      if (tr.nearCountdownTimerId) {
        clearInterval(tr.nearCountdownTimerId);
        tr.nearCountdownTimerId = null;
      }
      tr.nearCountdownSeconds = null;
      if (tr.etaInfoWindow) tr.etaInfoWindow.close();
      return;
    }

    if (tr.nearCountdownSeconds == null || tr.nearCountdownSeconds <= 0) {
      if (tr.etaInfoWindow) tr.etaInfoWindow.close();
      if (tr.nearCountdownTimerId) {
        clearInterval(tr.nearCountdownTimerId);
        tr.nearCountdownTimerId = null;
      }
      tr.nearCountdownSeconds = null;
      return;
    }

    const countdownText = getNearCountdownText(tr.nearCountdownSeconds);

    const html = `
      <div style="
        background:#0f172a;
        color:#fecaca;
        padding:4px 10px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #ef4444;
        white-space:nowrap;
        animation: merchant-blink 0.8s linear infinite;
      ">
        ${countdownText}
      </div>
    `;
    tr.etaInfoWindow.setContent(html);
    tr.etaInfoWindow.open(map, st.marker);
  };

  render();

  tr.nearCountdownTimerId = setInterval(() => {
    if (tr.nearCountdownSeconds != null) {
      tr.nearCountdownSeconds -= 1;
      render();
    }
  }, 1000);
}

function mtStopTrackingForDriver(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr) return;

  if (tr.routePolyline) {
    tr.routePolyline.setMap(null);
    tr.routePolyline = null;
  }
  tr.routeFullPath = [];

  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }
  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }

  if (tr.etaInfoWindow) {
    tr.etaInfoWindow.close();
    tr.etaInfoWindow = null;
  }

  tr.etaSeconds = null;
  tr.etaUpdatedAt = null;
  tr.nearCountdownSeconds = null;
  tr.nearAlertPlayed = false;
  tr.directionsRequestedForCurrentLeg = false;
  tr.mapFittedForCurrentLeg = false;

  mtHideCustomerMarkerForDriver(driverId);

  delete multiTrackingByDriver[driverId];
}

function ensureCustomerMarkerOnMap(lat, lng, label) {
  if (!map || lat == null || lng == null) return;
  const pos = { lat, lng };

  if (!customerMarker) {
    customerMarker = new google.maps.Marker({
      position: pos,
      map,
      title: label || "Ø§Ù„Ø¹Ù…ÙŠÙ„",
      icon: getCustomerMarkerIcon()
    });
  } else {
    customerMarker.setPosition(pos);
    customerMarker.setMap(map);
  }
}

function hideCustomerMarker() {
  if (customerMarker) {
    customerMarker.setMap(null);
  }
}

function getRouteDistanceKm(origin, destination) {
  return new Promise((resolve) => {
    if (!directionsService) {
      directionsService = new google.maps.DirectionsService();
    }
    directionsService.route(
      {
        origin: origin,
        destination: destination,
        travelMode: google.maps.TravelMode.DRIVING
      },
      (result, status) => {
        if (
          status === "OK" &&
          result.routes &&
          result.routes.length > 0 &&
          result.routes[0].legs &&
          result.routes[0].legs.length > 0 &&
          result.routes[0].legs[0].distance
        ) {
          resolve(result.routes[0].legs[0].distance.value / 1000);
        } else {
          console.error("ÙØ´Ù„ Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø± Google Maps", status, result);
          resolve(0);
        }
      }
    );
  });
}

function initMapAndData(merchantId) {
  currentMerchantId = merchantId;

  if (!map) {
    const geocoder = new google.maps.Geocoder();
    const merchantAddress =
      merchantNameEl.textContent + ", " + merchantCityEl.textContent;

    map = new google.maps.Map(mapContainer, {
      center: { lat: 25.276987, lng: 55.296249 },
      zoom: 14,
      styles: [
        { elementType: "geometry", stylers: [{ color: "#f5f5f5" }] },
        { elementType: "labels.text.fill", stylers: [{ color: "#616161" }] },
        { elementType: "labels.text.stroke", stylers: [{ color: "#f5f5f5" }] },
        {
          featureType: "road",
          elementType: "geometry",
          stylers: [{ color: "#e0e0e0" }]
        },
        {
          featureType: "road",
          elementType: "labels.text.fill",
          stylers: [{ color: "#4b5563" }]
        },
        {
          featureType: "poi",
          stylers: [{ visibility: "off" }]
        }
      ],
      fullscreenControl: false,
      zoomControl: false,
      streetViewControl: false,
      mapTypeControl: false,
      gestureHandling: "greedy"
    });

    geocoder.geocode({ address: merchantAddress }, (results, status) => {
      if (status === "OK" && results[0]) {
        const location = results[0].geometry.location;
        map.setCenter(location);

        merchantLocationLat = location.lat();
        merchantLocationLng = location.lng();

        currentDestinationLat = merchantLocationLat;
        currentDestinationLng = merchantLocationLng;
        currentDestinationType = "merchant";
        currentDestinationAddress = null;
        directionsRequestedForCurrentLeg = false;

        const circle = new google.maps.Circle({
          center: location,
          radius: 3000
        });
        map.fitBounds(circle.getBounds());

        if (merchantCurrentOnline) {
          ensureMerchantMarkerOnMap();
        } else {
          hideMerchantMarker();
        }
      } else {
        console.error("Ø®Ø·Ø£ ÙÙŠ Ø¬ÙŠÙˆÙƒÙˆØ¯ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: " + status);
      }
    });

    if (!directionsService) {
      directionsService = new google.maps.DirectionsService();
    }
  }

  if (driversListenerUnsub) driversListenerUnsub();
  driversListenerUnsub = db
    .collection("drivers")
    .where("online", "==", true)
    .onSnapshot((snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const id = change.doc.id;
        const data = change.doc.data();
        cachedDrivers[id] = data;

        if (change.type === "added") {
          if (data.lat && data.lng) addDriverMarker(id, data);
        } else if (change.type === "modified") {
          updateDriverMarker(id, data);
        } else if (change.type === "removed") {
          removeDriverMarker(id);
        }
      });

      refreshDriverFilterOptions();

      if (onlineDriversBadge) {
        const countEl = onlineDriversBadge.querySelector(".count");
        if (countEl) {
          countEl.textContent = snapshot.size;
        }
      }
    });

  if (merchantCallsListenerUnsub) merchantCallsListenerUnsub();
  merchantCallsListenerUnsub = db
    .collection("merchants")
    .doc(merchantId)
    .collection("calls")
    .orderBy("createdAt", "desc")
    .onSnapshot((snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const id = change.doc.id;
        const newData = change.doc.data() || {};
        const oldData = lastCallsById[id] || {};
        const oldStatus = (oldData.status || "").toLowerCase();
        const newStatus = (newData.status || "").toLowerCase();

        if (oldStatus !== "accepted" && newStatus === "accepted") {
          playCallAcceptedForMerchant(newData);
        }

        const wasHeadingMerchant = isStatusHeadingToMerchant(oldStatus);
        const nowHeadingMerchant = isStatusHeadingToMerchant(newStatus);
        if (!wasHeadingMerchant && nowHeadingMerchant) {
          handleDriverHeadingToMerchant(id, newData);
        }

        const wasHeadingCustomer = isStatusHeadingToCustomer(oldStatus);
        const nowHeadingCustomer = isStatusHeadingToCustomer(newStatus);
        if (!wasHeadingCustomer && nowHeadingCustomer) {
          handleDriverHeadingToCustomer(id, newData);
        }

        if (
          newStatus === "completed" ||
          newStatus === "finished" ||
          newStatus === "delivered" ||
          newStatus === "cancelled" ||
          newStatus === "rejected"
        ) {
          if (newStatus === "delivered" && customerDeliveredSoundEl) {
            try {
              customerDeliveredSoundEl.currentTime = 0;
              customerDeliveredSoundEl.play();
            } catch (e) {
              console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„ØªØ³Ù„ÙŠÙ…:", e);
            }
          }

          stopTrackingDriverForCall(id);
        }

        lastCallsById[id] = newData;
      });

      const calls = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        calls.push({ id: doc.id, ...data });
        lastCallsById[doc.id] = data;
      });
      renderMerchantCalls(calls);
    });
}

function buildDriverInfoContent(id, data) {
  const lang = currentLang || "ar";

  const firstName =
    data.firstName ||
    (data.fullName || "").split(" ")[0] ||
    (lang === "en"
      ? "Driver"
      : lang === "de"
      ? "Fahrer"
      : lang === "tr"
      ? "SÃ¼rÃ¼cÃ¼"
      : "Ø³Ø§Ø¦Ù‚");

  const isBusy = !!data.busy;

  // ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø­Ø³Ø¨ Ø§Ù„Ù„ØºØ© (ÙØ§ØµÙ„Ø© Ù„Ù„Ø¹Ø±Ø¨ÙŠ/Ø£ÙˆØ±ÙˆØ¨ÙŠ Ø£Ùˆ Ù†Ù‚Ø·Ø© Ù„Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ)
  const formatAmount = (num) => {
    const s = Number(num).toFixed(2);
    if (lang === "de" || lang === "tr") return s.replace(".", ",");
    return s;
  };

  let texts;

  switch (lang) {
    case "en":
      texts = {
        phoneLabel: "Phone:",
        cityLabel: "City:",
        pricingLabel: "Pricing:",
        busy: "The driver is currently busy",
        offline: "You are offline â€” you cannot send a call",
        callBtn: "Call driver",
        noPricing: "No pricing set yet",
        baseFeeBothSame: (base, perKm) =>
          `Base fee ${base}â‚¬ + ${perKm}â‚¬/km (from driver to merchant and from merchant to drop-off point)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `Base fee ${base}â‚¬ + ${toMer}â‚¬/km (driver â†’ merchant) + ${perKm}â‚¬/km (merchant â†’ drop-off point)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `Base fee ${base}â‚¬ + ${perKm}â‚¬/km (merchant â†’ drop-off point)`,
        freeKm: (km) => `First ${km} km free`
      };
      break;

    case "de":
      texts = {
        phoneLabel: "Telefon:",
        cityLabel: "Stadt:",
        pricingLabel: "Tarif:",
        busy: "Der Fahrer ist derzeit beschÃ¤ftigt",
        offline: "Du bist offline â€“ du kannst keinen Ruf senden",
        callBtn: "Fahrer rufen",
        noPricing: "Noch kein Tarif festgelegt",
        baseFeeBothSame: (base, perKm) =>
          `GrundgebÃ¼hr ${base}â‚¬ + ${perKm}â‚¬/km (vom Fahrer zum HÃ¤ndler und vom HÃ¤ndler zum Lieferort)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `GrundgebÃ¼hr ${base}â‚¬ + ${toMer}â‚¬/km (Fahrer â†’ HÃ¤ndler) + ${perKm}â‚¬/km (HÃ¤ndler â†’ Lieferort)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `GrundgebÃ¼hr ${base}â‚¬ + ${perKm}â‚¬/km (HÃ¤ndler â†’ Lieferort)`,
        freeKm: (km) => `Die ersten ${km} km kostenlos`
      };
      break;

    case "tr":
      texts = {
        phoneLabel: "Telefon:",
        cityLabel: "Åehir:",
        pricingLabel: "FiyatlandÄ±rma:",
        busy: "SÃ¼rÃ¼cÃ¼ ÅŸu anda meÅŸgul",
        offline: "Ã‡evrimdÄ±ÅŸÄ± moddasÄ±nÄ±z â€” Ã§aÄŸrÄ± gÃ¶nderemezsiniz",
        callBtn: "SÃ¼rÃ¼cÃ¼yÃ¼ Ã§aÄŸÄ±r",
        noPricing: "HenÃ¼z fiyatlandÄ±rma tanÄ±mlanmadÄ±",
        baseFeeBothSame: (base, perKm) =>
          `Temel Ã¼cret ${base}â‚¬ + ${perKm}â‚¬/km (sÃ¼rÃ¼cÃ¼den iÅŸletmeye ve iÅŸletmeden teslimat noktasÄ±na)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `Temel Ã¼cret ${base}â‚¬ + ${toMer}â‚¬/km (sÃ¼rÃ¼cÃ¼ â†’ iÅŸletme) + ${perKm}â‚¬/km (iÅŸletme â†’ teslimat noktasÄ±)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `Temel Ã¼cret ${base}â‚¬ + ${perKm}â‚¬/km (iÅŸletme â†’ teslimat noktasÄ±)`,
        freeKm: (km) => `Ä°lk ${km} km Ã¼cretsiz`
      };
      break;

    default: // ar
      texts = {
        phoneLabel: "Ø§Ù„Ù‡Ø§ØªÙ:",
        cityLabel: "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©:",
        pricingLabel: "Ø§Ù„ØªØ³Ø¹ÙŠØ±Ø©:",
        busy: "Ø§Ù„Ø³Ø§Ø¦Ù‚ Ù…Ø´ØºÙˆÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹",
        offline: "Ø£Ù†Øª ÙÙŠ ÙˆØ¶Ø¹ Ø£ÙˆÙÙ„Ø§ÙŠÙ† â€” Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ù†Ø¯Ø§Ø¡",
        callBtn: "Ù…Ù†Ø§Ø¯Ø§Ø©",
        noPricing: "Ù„Ù… ÙŠØ­Ø¯Ø¯ ØªØ³Ø¹ÙŠØ±Ø© Ø¨Ø¹Ø¯",
        baseFeeBothSame: (base, perKm) =>
          `Ø±Ø³ÙˆÙ… Ø£Ø³Ø§Ø³ÙŠØ© ${base}â‚¬ + ${perKm}â‚¬/ÙƒÙ… (Ù…Ù† Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø¥Ù„Ù‰ Ø§Ù„ØªØ§Ø¬Ø± ÙˆÙ…Ù† Ø§Ù„ØªØ§Ø¬Ø± Ø¥Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ³Ù„ÙŠÙ…)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `Ø±Ø³ÙˆÙ… Ø£Ø³Ø§Ø³ÙŠØ© ${base}â‚¬ + ${toMer}â‚¬/ÙƒÙ… (Ù…Ù† Ø§Ù„Ø³Ø§Ø¦Ù‚ Ø¥Ù„Ù‰ Ø§Ù„ØªØ§Ø¬Ø±) + ${perKm}â‚¬/ÙƒÙ… (Ù…Ù† Ø§Ù„ØªØ§Ø¬Ø± Ø¥Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ³Ù„ÙŠÙ…)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `Ø±Ø³ÙˆÙ… Ø£Ø³Ø§Ø³ÙŠØ© ${base}â‚¬ + ${perKm}â‚¬/ÙƒÙ… (Ù…Ù† Ø§Ù„ØªØ§Ø¬Ø± Ø¥Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ³Ù„ÙŠÙ…)`,
        freeKm: (km) => `Ø£ÙˆÙ„ ${km} ÙƒÙ… Ù…Ø¬Ø§Ù†Ø§Ù‹`
      };
      break;
  }

  let actionHtml = "";
  if (isBusy) {
    actionHtml = `<span class="small" style="color:#d93025;">${texts.busy}</span>`;
  } else if (!merchantCurrentOnline) {
    actionHtml = `<span class="small" style="color:#9ca3af;">${texts.offline}</span>`;
  } else {
    actionHtml = `<button id="callBtn_${id}" class="small call-btn">${texts.callBtn}</button>`;
  }

  let pricingHtml = texts.noPricing;

  const hasDeliveryPrice =
    typeof data.pricePerKmDelivery === "number" &&
    data.pricePerKmDelivery > 0;

  const includeToMerchant = !!data.includeToMerchantSegment;
  const useSameForBoth = data.useSamePriceForBoth !== false;
  const freeKm =
    typeof data.freeKm === "number" ? data.freeKm : 0;

  if (hasDeliveryPrice) {
    const baseFeeStr = formatAmount(BASE_DELIVERY_FEE);
    const deliveryStr = formatAmount(data.pricePerKmDelivery);

    let line = texts.baseFeeMerchantOnly(baseFeeStr, deliveryStr);

    if (includeToMerchant) {
      const toMerchantPrice =
        typeof data.pricePerKmToMerchant === "number" &&
        !useSameForBoth
          ? data.pricePerKmToMerchant
          : data.pricePerKmDelivery;

      const toMerStr = formatAmount(toMerchantPrice);

      if (useSameForBoth) {
        line = texts.baseFeeBothSame(baseFeeStr, deliveryStr);
      } else {
        line = texts.baseFeeTwoSegments(baseFeeStr, toMerStr, deliveryStr);
      }
    } else {
      line = texts.baseFeeMerchantOnly(baseFeeStr, deliveryStr);
    }

    if (freeKm > 0) {
      line += `<br/>${texts.freeKm(freeKm)}`;
    }

    pricingHtml = line;
  }

  const isRtl = lang === "ar";

  const container = document.createElement("div");
  container.style.direction = isRtl ? "rtl" : "ltr";
  container.style.textAlign = isRtl ? "right" : "left";

  container.innerHTML = `
    <div style="min-width:220px">
      <strong>${escapeHtml(firstName)}</strong><br/>
      <div class="small">${texts.phoneLabel} ${escapeHtml(data.phone || "")}</div>
      <div class="small">${texts.cityLabel} ${escapeHtml(data.city || "")}</div>
      <div class="small" style="margin-top:4px;">
        ${texts.pricingLabel}<br/>${pricingHtml}
      </div>
      <div style="margin-top:8px; display:flex; gap:6px; justify-content:${isRtl ? "flex-end" : "flex-start"};">
        ${actionHtml}
      </div>
    </div>
  `;

  return container;
}

function addDriverMarker(id, data) {
  if (!data.lat || !data.lng) return;

  const isBusy = !!data.busy;
  const color = isBusy ? "#d93025" : "#28a745";
  const baseScale = 9;

  if (driverMarkers[id]) {
    const state = driverMarkers[id];
    state.marker.setPosition({ lat: data.lat, lng: data.lng });
    state.color = color;
    state.baseScale = baseScale;
    const newContent = buildDriverInfoContent(id, data);
    state.info.setContent(newContent);
    return;
  }

  const marker = new google.maps.Marker({
    position: { lat: data.lat, lng: data.lng },
    map,
    title: (data.firstName || "") + " " + (data.lastName || "")
  });

  marker.setIcon(createCircleIcon(color, baseScale));

  const info = new google.maps.InfoWindow();
  const content = buildDriverInfoContent(id, data);
  info.setContent(content);

  marker.addListener("click", () => {
    info.open(map, marker);
    setTimeout(() => {
      const btn = document.getElementById(`callBtn_${id}`);
      if (btn) {
        btn.onclick = () => createCallForDriver(id);
      }
    }, 80);
  });

  const state = {
    marker,
    info,
    color,
    baseScale,
    growing: true,
    currentScale: baseScale
  };

  const pulseInterval = setInterval(() => {
    if (!state.marker.getMap()) {
      clearInterval(pulseInterval);
      return;
    }
    const maxScale = state.baseScale + 3;
    const minScale = state.baseScale - 1;
    if (state.growing) {
      state.currentScale += 0.25;
      if (state.currentScale >= maxScale) state.growing = false;
    } else {
      state.currentScale -= 0.25;
      if (state.currentScale <= minScale) state.growing = true;
    }
    state.marker.setIcon(
      createCircleIcon(state.color, state.currentScale)
    );
  }, 80);

  state.pulseInterval = pulseInterval;
  driverMarkers[id] = state;
}

function updateDriverMarker(id, data) {
  if (!driverMarkers[id]) {
    addDriverMarker(id, data);
    return;
  }
  const state = driverMarkers[id];
  if (data.lat && data.lng) {
    state.marker.setPosition({ lat: data.lat, lng: data.lng });
  }
  state.color = data.busy ? "#d93025" : "#28a745";
  const newContent = buildDriverInfoContent(id, data);
  state.info.setContent(newContent);

  if (multiTrackingByDriver[id]) {
    mtUpdateRouteAndEta(id);
  }

  if (!data.busy && multiTrackingByDriver[id] && !hasActiveCallForDriver(id)) {
    stopDriverHalo(id);
    mtStopTrackingForDriver(id);
  }
}

function removeDriverMarker(id) {
  const state = driverMarkers[id];
  if (!state) return;
  state.marker.setMap(null);
  state.info.close();
  if (state.pulseInterval) clearInterval(state.pulseInterval);
  delete driverMarkers[id];

  stopDriverHalo(id);
  if (multiTrackingByDriver[id]) {
    mtStopTrackingForDriver(id);
  }
}

function closeDriverInfoWindow(driverId) {
  const state = driverMarkers[driverId];
  if (state && state.info) {
    state.info.close();
  }
}
function isStatusHeadingToMerchant(status) {
  if (!status) return false;
  const s = String(status).toLowerCase();
  return (
    s === "heading_to_merchant" ||
    s === "going_to_merchant" ||
    s === "to_merchant" ||
    s === "in_progress"
  );
}
function isStatusHeadingToCustomer(status) {
  if (!status) return false;
  const s = String(status).toLowerCase();
  return (
    s === "heading_to_customer" ||
    s === "going_to_customer" ||
    s === "to_customer" ||
    s === "to_client" ||
    s === "heading_to_client"
  );
}

function playCallAcceptedForMerchant(callData) {
  if (callAcceptedSoundEl) {
    try {
      callAcceptedSoundEl.currentTime = 0;
      callAcceptedSoundEl.play();
    } catch (e) {
      console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø·Ù„Ø¨:", e);
    }
  }
}

function startDriverHalo(driverId) {
  if (!map) return;
  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  const pos = markerState.marker.getPosition();
  if (!pos) return;

  if (driverHaloState[driverId]) return;

  const baseScale = 18;
  const maxScale  = 32;

  const haloMarker = new google.maps.Marker({
    position: pos,
    map,
    clickable: false,
    zIndex: (markerState.marker.getZIndex() || 100) - 1,
    icon: {
      path: google.maps.SymbolPath.CIRCLE,
      fillColor: "#3b82f6",
      fillOpacity: 0.45,
      strokeColor: "#3b82f6",
      strokeOpacity: 0.9,
      strokeWeight: 1.5,
      scale: baseScale,
    },
  });

  const state = {
    haloMarker,
    baseScale,
    maxScale,
    currentScale: baseScale,
    intervalId: null,
  };

  state.intervalId = setInterval(() => {
    const mState = driverMarkers[driverId];
    if (!mState || !mState.marker || !mState.marker.getMap()) {
      stopDriverHalo(driverId);
      return;
    }

    const curPos = mState.marker.getPosition();
    if (curPos) state.haloMarker.setPosition(curPos);

    state.currentScale += 0.8;
    if (state.currentScale > state.maxScale) {
      state.currentScale = state.baseScale;
    }

    const progress =
      (state.currentScale - state.baseScale) /
      (state.maxScale - state.baseScale);

    const fillOpacity   = 0.45 * (1 - progress);
    const strokeOpacity = 0.9 * (1 - progress * 0.7);

    state.haloMarker.setIcon({
      path: google.maps.SymbolPath.CIRCLE,
      fillColor: "#3b82f6",
      fillOpacity,
      strokeColor: "#3b82f6",
      strokeOpacity,
      strokeWeight: 1.5,
      scale: state.currentScale,
    });
  }, 80);

  driverHaloState[driverId] = state;
}
function stopDriverHalo(driverId) {
  const state = driverHaloState[driverId];
  if (!state) return;
  if (state.intervalId) clearInterval(state.intervalId);
  if (state.haloMarker) state.haloMarker.setMap(null);
  delete driverHaloState[driverId];
}

function startTrackingDriverToMerchant(driverId) {
  trackedDriverId = driverId;
  trackedNearAlertPlayed = false;

  currentDestinationType = "merchant";
  currentDestinationLat = merchantLocationLat;
  currentDestinationLng = merchantLocationLng;
  currentDestinationAddress = null;
  directionsRequestedForCurrentLeg = false;
  mapFittedForCurrentLeg = false;

  if (currentTrackedCallId) {
    driverToMerchantDirectionsCountByCall[currentTrackedCallId] = 0;
  }
  driverRouteAvgSpeedMps = null;

  if (trackedRoutePolyline) {
    trackedRoutePolyline.setMap(null);
    trackedRoutePolyline = null;
  }
  trackedRouteFullPath = [];

  if (trackedEtaInfoWindow) {
    trackedEtaInfoWindow.close();
    trackedEtaInfoWindow = null;
  }

  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }
  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }
  nearCountdownSeconds = null;

  updateDriverRouteAndEta();
}
function startTrackingDriverToCustomer(callData) {
  trackedDriverId = callData.driverId || null;
  trackedNearAlertPlayed = false;

  currentDestinationType = "customer";
  currentDestinationLat = null;
  currentDestinationLng = null;
  currentDestinationAddress = callData.deliveryAddress || "";
  currentCustomerName = (callData.customerName || "").trim();
  directionsRequestedForCurrentLeg = false;
  mapFittedForCurrentLeg = false;

  driverRouteAvgSpeedMps = null;

  if (trackedRoutePolyline) {
    trackedRoutePolyline.setMap(null);
    trackedRoutePolyline = null;
  }
  trackedRouteFullPath = [];

  if (trackedEtaInfoWindow) {
    trackedEtaInfoWindow.close();
    trackedEtaInfoWindow = null;
  }
  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }
  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }
  nearCountdownSeconds = null;

  hideCustomerMarker();

  updateDriverRouteAndEta();
}

function stopTrackingDriverToMerchant() {
  trackedDriverId = null;
  trackedNearAlertPlayed = false;

  if (trackedRoutePolyline) {
    trackedRoutePolyline.setMap(null);
    trackedRoutePolyline = null;
  }
  trackedRouteFullPath = [];

  if (trackedEtaInfoWindow) {
    trackedEtaInfoWindow.close();
    trackedEtaInfoWindow = null;
  }

  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }

  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }
  nearCountdownSeconds = null;
}

function getCurrentEtaSeconds() {
  if (trackedEtaSeconds == null || trackedEtaUpdatedAt == null) return null;

  let baseRemaining = Math.max(
    Math.round(trackedEtaSeconds - (Date.now() - trackedEtaUpdatedAt) / 1000),
    0
  );

  if (
    trackedDriverId &&
    map &&
    currentDestinationLat != null &&
    currentDestinationLng != null &&
    driverRouteAvgSpeedMps &&
    driverRouteAvgSpeedMps > 0 &&
    google.maps &&
    google.maps.geometry &&
    google.maps.geometry.spherical
  ) {
    const state = driverMarkers[trackedDriverId];
    if (state && state.marker) {
      const pos = state.marker.getPosition();
      if (pos) {
        const dest = new google.maps.LatLng(
          currentDestinationLat,
          currentDestinationLng
        );
        const distanceMeters =
          google.maps.geometry.spherical.computeDistanceBetween(pos, dest);

        trackedLastDistanceMeters = distanceMeters;

        const seconds = distanceMeters / driverRouteAvgSpeedMps;
        return Math.max(Math.round(seconds), 0);
      }
    }
  }

  return baseRemaining;
}

function updateEtaBubble() {
  if (!trackedEtaInfoWindow || !trackedDriverId) return;

  const markerState = driverMarkers[trackedDriverId];
  if (!markerState || !markerState.marker) return;

  const remaining = getCurrentEtaSeconds();
  if (remaining == null) return;

  if (remaining <= 0) {
    const arrivedText = getEtaArrivedText();
    trackedEtaInfoWindow.setContent(`
      <div style="
        background:#0f172a;
        color:#bbf7d0;
        padding:4px 8px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #22c55e;
      ">
        ${arrivedText}
      </div>
    `);
    trackedEtaInfoWindow.open(map, markerState.marker);
    return;
  }

  const etaText = getEtaLabelText(remaining);

  const html = `
    <div style="
      background:#0f172a;
      color:#f9fafb;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      box-shadow:0 4px 12px rgba(15,23,42,0.6);
      border:1px solid #22c55e;
      white-space:nowrap;
    ">
      ${etaText}
    </div>
  `;
  trackedEtaInfoWindow.setContent(html);
  trackedEtaInfoWindow.open(map, markerState.marker);
}

function startNearArrivalCountdown(driverId) {
  const state = driverMarkers[driverId];
  if (!state || !state.marker) return;

  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }

  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }

  nearCountdownSeconds = 60;

  if (!trackedEtaInfoWindow) {
    trackedEtaInfoWindow = new google.maps.InfoWindow({
      pixelOffset: new google.maps.Size(0, -40),
      disableAutoPan: true
    });
  } else {
    trackedEtaInfoWindow.setOptions({ disableAutoPan: true });
  }

  const render = () => {
    const currentState = driverMarkers[driverId];
    if (!currentState || !currentState.marker || !currentState.marker.getMap()) {
      if (nearCountdownTimerId) {
        clearInterval(nearCountdownTimerId);
        nearCountdownTimerId = null;
      }
      nearCountdownSeconds = null;
      if (trackedEtaInfoWindow) trackedEtaInfoWindow.close();
      return;
    }

    if (nearCountdownSeconds == null || nearCountdownSeconds <= 0) {
      if (trackedEtaInfoWindow) trackedEtaInfoWindow.close();
      if (nearCountdownTimerId) {
        clearInterval(nearCountdownTimerId);
        nearCountdownTimerId = null;
      }
      nearCountdownSeconds = null;
      return;
    }

    const countdownText = getNearCountdownText(nearCountdownSeconds);

    const html = `
      <div style="
        background:#0f172a;
        color:#fecaca;
        padding:4px 10px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #ef4444;
        white-space:nowrap;
        animation: merchant-blink 0.8s linear infinite;
      ">
        ${countdownText}
      </div>
    `;

    trackedEtaInfoWindow.setContent(html);
    trackedEtaInfoWindow.open(map, currentState.marker);
  };

  render();

  nearCountdownTimerId = setInterval(() => {
    if (nearCountdownSeconds != null) {
      nearCountdownSeconds -= 1;
      render();
    }
  }, 1000);
}

function updateRouteProgressAlongPath(currentLatLng) {
  if (!trackedRoutePolyline) return;
  if (!trackedRouteFullPath || trackedRouteFullPath.length === 0) return;
  if (
    !google.maps ||
    !google.maps.geometry ||
    !google.maps.geometry.spherical
  ) {
    return;
  }

  let closestIndex = 0;
  let minDist = Infinity;

  for (let i = 0; i < trackedRouteFullPath.length; i++) {
    const p = trackedRouteFullPath[i];
    const d = google.maps.geometry.spherical.computeDistanceBetween(
      currentLatLng,
      p
    );
    if (d < minDist) {
      minDist = d;
      closestIndex = i;
    }
  }

  if (minDist > 80) return;

  const remaining = trackedRouteFullPath.slice(closestIndex);
  trackedRouteFullPath = remaining;
  trackedRoutePolyline.setPath(remaining);
}

function updateDriverRouteAndEta() {
  if (!trackedDriverId) return;
  if (!map) return;
  if (!currentDestinationType) return;

  const markerState = driverMarkers[trackedDriverId];
  if (!markerState || !markerState.marker) return;

  const origin = markerState.marker.getPosition();
  if (!origin) return;

  updateRouteProgressAlongPath(origin);

  const isCustomerLeg = currentDestinationType === "customer";

  let distanceMetersGeo = null;
  if (
    currentDestinationLat != null &&
    currentDestinationLng != null &&
    google.maps &&
    google.maps.geometry &&
    google.maps.geometry.spherical
  ) {
    const destLatLng = new google.maps.LatLng(
      currentDestinationLat,
      currentDestinationLng
    );
    distanceMetersGeo =
      google.maps.geometry.spherical.computeDistanceBetween(origin, destLatLng);
    trackedLastDistanceMeters = distanceMetersGeo;
  }

  if (
    !trackedNearAlertPlayed &&
    distanceMetersGeo != null &&
    distanceMetersGeo <= 300
  ) {
    trackedNearAlertPlayed = true;

    if (currentDestinationType === "merchant") {
      if (driverNearSoundEl) {
        try {
          driverNearSoundEl.currentTime = 0;
          driverNearSoundEl.play();
        } catch (e) {
          console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª Ù‚Ø±Ø¨ Ø§Ù„ÙˆØµÙˆÙ„:", e);
        }
      }

      if (trackedRoutePolyline) {
        trackedRoutePolyline.setMap(null);
        trackedRoutePolyline = null;
      }
      stopDriverHalo(trackedDriverId);

      if (trackedEtaTimerId) {
        clearInterval(trackedEtaTimerId);
        trackedEtaTimerId = null;
      }
      trackedEtaSeconds = null;
      trackedEtaUpdatedAt = null;

      startNearArrivalCountdown(trackedDriverId);
      return;
    }

    if (currentDestinationType === "customer") {
      if (trackedEtaTimerId) {
        clearInterval(trackedEtaTimerId);
        trackedEtaTimerId = null;
      }
      trackedEtaSeconds = null;
      trackedEtaUpdatedAt = null;

      startNearArrivalCountdown(trackedDriverId);
      return;
    }
  }

  if (trackedNearAlertPlayed) return;

  if (!directionsService) {
    directionsService = new google.maps.DirectionsService();
  }

  if (!isCustomerLeg) {
    const now = Date.now();
    if (now - lastDriverRouteRequestAt < 10000) return;
    lastDriverRouteRequestAt = now;
  } else {
    if (directionsRequestedForCurrentLeg) {
      return;
    }
    directionsRequestedForCurrentLeg = true;
  }

  let destination;
  if (currentDestinationLat != null && currentDestinationLng != null) {
    destination = {
      lat: currentDestinationLat,
      lng: currentDestinationLng
    };
  } else if (currentDestinationAddress) {
    destination = currentDestinationAddress;
  } else if (
    currentDestinationType === "merchant" &&
    merchantLocationLat != null &&
    merchantLocationLng != null
  ) {
    destination = {
      lat: merchantLocationLat,
      lng: merchantLocationLng
    };
  } else {
    return;
  }

  directionsService.route(
    {
      origin,
      destination,
      travelMode: google.maps.TravelMode.DRIVING
    },
    (result, status) => {
      if (
        status !== "OK" ||
        !result.routes ||
        !result.routes[0] ||
        !result.routes[0].legs ||
        !result.routes[0].legs[0]
      ) {
        console.warn("ØªØ¹Ø°Ø± Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø± Ø§Ù„Ø³Ø§Ø¦Ù‚:", status, result);
        return;
      }

      const leg = result.routes[0].legs[0];
      const distanceMeters = leg.distance ? leg.distance.value : null;
      const durationSeconds = leg.duration ? leg.duration.value : null;

      if (distanceMeters != null) {
        trackedLastDistanceMeters = distanceMeters;
      }
      if (
        distanceMeters != null &&
        durationSeconds != null &&
        durationSeconds > 0
      ) {
        driverRouteAvgSpeedMps = distanceMeters / durationSeconds;
      }

      if (currentDestinationType === "customer" && leg.end_location) {
        currentDestinationLat = leg.end_location.lat();
        currentDestinationLng = leg.end_location.lng();
        ensureCustomerMarkerOnMap(
          currentDestinationLat,
          currentDestinationLng,
          currentCustomerName || "Ø§Ù„Ø¹Ù…ÙŠÙ„"
        );
      } else if (
        currentDestinationType === "merchant" &&
        leg.end_location &&
        (currentDestinationLat == null || currentDestinationLng == null)
      ) {
        currentDestinationLat = leg.end_location.lat();
        currentDestinationLng = leg.end_location.lng();
      }

      if (!mapFittedForCurrentLeg && map && origin) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend(origin);

        if (currentDestinationLat != null && currentDestinationLng != null) {
          bounds.extend(
            new google.maps.LatLng(currentDestinationLat, currentDestinationLng)
          );
        } else if (leg.end_location) {
          bounds.extend(leg.end_location);
        }

        map.fitBounds(bounds);
        mapFittedForCurrentLeg = true;
      }

      const overviewPath = result.routes[0].overview_path;
      if (overviewPath && overviewPath.length) {
        trackedRouteFullPath = overviewPath.slice();

        if (!trackedRoutePolyline) {
          trackedRoutePolyline = new google.maps.Polyline({
            map,
            path: trackedRouteFullPath,
            strokeColor: "#22c55e",
            strokeOpacity: 0.8,
            strokeWeight: 4
          });
        } else {
          trackedRoutePolyline.setPath(trackedRouteFullPath);
        }

        updateRouteProgressAlongPath(origin);
      }

      if (durationSeconds != null) {
        trackedEtaSeconds = durationSeconds;
        trackedEtaUpdatedAt = Date.now();

        if (!trackedEtaInfoWindow) {
          trackedEtaInfoWindow = new google.maps.InfoWindow({
            pixelOffset: new google.maps.Size(0, -40),
            disableAutoPan: true
          });
        } else {
          trackedEtaInfoWindow.setOptions({ disableAutoPan: true });
        }

        updateEtaBubble();

        if (!trackedEtaTimerId) {
          trackedEtaTimerId = setInterval(updateEtaBubble, 1000);
        }
      }
    }
  );
}

function handleDriverHeadingToMerchant(callId, callData) {
  const driverId = callData.driverId || null;
  if (!driverId) return;

  if (driverOnWaySoundEl) {
    try {
      driverOnWaySoundEl.currentTime = 0;
      driverOnWaySoundEl.play();
    } catch (e) {
      console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª (Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙÙŠ Ø§Ù„Ø·Ø±ÙŠÙ‚):", e);
    }
  }

  if (typeof showToast === "function") {
    const driverName = (
      (callData.driverFirstName || "") +
      " " +
      (callData.driverLastName || "")
    ).trim();

    const label = driverName
      ? t("toastDriverHeadingMerchantWithName").replace("{{name}}", driverName)
      : t("toastDriverHeadingMerchantNoName");

    showToast(label);
  }

  startDriverHalo(driverId);
  mtStartTrackingToMerchant(driverId, callId);
}

function handleDriverHeadingToCustomer(callId, callData) {
  const driverId = callData.driverId || null;
  if (!driverId) return;

  if (driverOnWaySoundEl) {
    try {
      driverOnWaySoundEl.currentTime = 0;
      driverOnWaySoundEl.play();
    } catch (e) {
      console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª (Ø§Ù„Ø³Ø§Ø¦Ù‚ ÙÙŠ Ø§Ù„Ø·Ø±ÙŠÙ‚ Ù„Ù„Ø¹Ù…ÙŠÙ„):", e);
    }
  }

  if (typeof showToast === "function") {
    const driverName = (
      (callData.driverFirstName || "") +
      " " +
      (callData.driverLastName || "")
    ).trim();

    const label = driverName
      ? t("toastDriverHeadingCustomerWithName").replace("{{name}}", driverName)
      : t("toastDriverHeadingCustomerNoName");

    showToast(label);
  }

  startDriverHalo(driverId);
  mtStartTrackingToCustomer(driverId, callId, callData);
}

function stopTrackingDriverForCall(callId) {
  Object.keys(multiTrackingByDriver).forEach((driverId) => {
    const tr = multiTrackingByDriver[driverId];
    if (tr && tr.callId === callId) {
      stopDriverHalo(driverId);
      mtStopTrackingForDriver(driverId);
    }
  });
}

/* ========== Merchant CALLS rendering ========== */
function renderMerchantCalls(allCalls) {
  lastCallsCache = allCalls.map((c) => {
    if (c.createdAt && c.createdAt.toDate) {
      c._date = c.createdAt.toDate();
    } else {
      c._date = c.createdAt ? new Date(c.createdAt) : new Date();
    }
    return c;
  });

  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  const active = lastCallsCache.filter((c) =>
    !completedStatuses.includes((c.status || "pending").toLowerCase())
  );
  const completed = lastCallsCache.filter((c) =>
    completedStatuses.includes((c.status || "").toLowerCase())
  );

  const driverFilterVal = filterDriver.value;

  let activeFiltered = active.slice();
  let completedFiltered = completed.slice();

  if (driverFilterVal) {
    activeFiltered = activeFiltered.filter(
      (c) => c.driverId === driverFilterVal
    );
    completedFiltered = completedFiltered.filter(
      (c) => c.driverId === driverFilterVal
    );
  }

  const sortA = sortActive.value;
  activeFiltered.sort((a, b) => compareCalls(a, b, sortA));

  const sortC = sortCompleted.value;
  completedFiltered.sort((a, b) => compareCalls(a, b, sortC));

  countActiveEl.innerHTML =
    `${t("statsActiveCalls")}<br><strong>${activeFiltered.length}</strong>`;
  countCompletedEl.innerHTML =
    `${t("statsPastCalls")}<br><strong>${completedFiltered.length}</strong>`;

  const totalDeliveryFee = completed.reduce(
    (sum, c) => sum + (c.deliveryFee || 0),
    0
  );
  document.getElementById("totalDelivery").innerHTML =
    `${t("statsTotalDelivery")}<br><strong>${totalDeliveryFee.toFixed(2)}</strong>`;
  if (merchantEarningsTopEl) {
    merchantEarningsTopEl.innerHTML =
      `${t("statsTotalDelivery")}<br><strong>${totalDeliveryFee.toFixed(2)} â‚¬</strong>`;
  }

  activeOrdersEl.innerHTML = "";
  activeFiltered.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      c.driverFirstName ||
      "Ø³Ø§Ø¦Ù‚";

    const card = document.createElement("div");
    card.className = "order-card";
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
        <div>
          <div><strong>#${getShortId(c.id)}</strong> â€” ${escapeHtml(driverName)}</div>
          <div class="small">${t("callStatusLabel")}: ${escapeHtml(
            c.status || "pending"
          )} â€” ${formatDate(c._date)}</div>
        </div>
      </div>
    `;

    activeOrdersEl.appendChild(card);

    card.addEventListener("click", (e) => {
      if (e.target.tagName.toLowerCase() === "button") return;
      viewOrderDetails(c.id);
    });
  });

  completedOrdersEl.innerHTML = "";
  completedFiltered.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      c.driverFirstName ||
      "Ø³Ø§Ø¦Ù‚";

    const dateBase =
      c.respondedAt && c.respondedAt.toDate
        ? c.respondedAt.toDate()
        : c._date;

    const card = document.createElement("div");
    card.className = "order-card";
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
        <div>
          <div><strong>#${getShortId(c.id)}</strong> â€” ${escapeHtml(driverName)}</div>
          <div class="small">${escapeHtml(
            c.status || ""
          )} â€” ${formatDate(dateBase)}</div>
        </div>
      </div>
    `;

    completedOrdersEl.appendChild(card);

    card.addEventListener("click", (e) => {
      if (e.target.tagName.toLowerCase() === "button") return;
      viewOrderDetails(c.id);
    });
  });
}

function compareCalls(a, b, mode) {
  if (!mode) mode = "date_desc";

  const ad = a._date;
  const bd = b._date;

  if (mode === "date_desc") return bd - ad;
  if (mode === "date_asc") return ad - bd;

  const nameA =
    (cachedDrivers[a.driverId] &&
      (cachedDrivers[a.driverId].firstName || "")) ||
    a.driverFirstName ||
    "";

  const nameB =
    (cachedDrivers[b.driverId] &&
      (cachedDrivers[b.driverId].firstName || "")) ||
    b.driverFirstName ||
    "";

  if (mode === "driver_asc") return nameA.localeCompare(nameB);
  if (mode === "driver_desc") return nameB.localeCompare(nameA);

  return 0;
}

/* ========== Utilities ========== */
function formatDate(d) {
  if (!d) return "";
  return d.toLocaleString();
}
function escapeHtml(s) {
  if (!s) return "";
  return String(s).replace(/[&<>"]/g, function (c) {
    return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[c];
  });
}
function getShortId(id) {
  if (!id) return "";
  return String(id).slice(-6);
}

/* ========== ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨ (Ù…Ù† calls) Ù„Ù„ØªØ§Ø¬Ø± ========== */
window.viewOrderDetails = async function (callId) {
  if (!currentMerchantId) return alert(t("alertMerchantNotSet"));

  const doc = await db
    .collection("merchants")
    .doc(currentMerchantId)
    .collection("calls")
    .doc(callId)
    .get();

  if (!doc.exists) return alert(t("alertOrderNotFound"));

  const o = { id: doc.id, ...doc.data() };

  const dist = o.distance || {};
  const totalKm =
    dist && typeof dist.totalKm === "number"
      ? dist.totalKm.toFixed(2) + " ÙƒÙ…"
      : null;
  const d1 =
    typeof dist.driverToMerchantKm === "number"
      ? dist.driverToMerchantKm.toFixed(2) + " ÙƒÙ…"
      : null;
  const d2 =
    typeof dist.merchantToDropoffKm === "number"
      ? dist.merchantToDropoffKm.toFixed(2) + " ÙƒÙ…"
      : null;

  let feeLabel = "â€”";
  if (o.cost && typeof o.cost.totalFee === "number") {
    feeLabel = o.cost.totalFee.toFixed(2) + " â‚¬";
  } else if (o.deliveryFee != null) {
    feeLabel = String(o.deliveryFee);
  }

  const shortId = getShortId(o.id);
  const driverName = (
    (o.driverFirstName || "") +
    " " +
    (o.driverLastName || "")
  ).trim();

  let html = `<div><strong>${t("orderDetailsHeadingPrefix")} #${shortId}</strong></div>`;

  html += `<div class="small">${t("orderDetailsStatusLabel")}: ${escapeHtml(
    o.status || ""
  )}</div>`;
  if (o.createdAt && o.createdAt.toDate) {
    html += `<div class="small">${t("orderDetailsDateLabel")}: ${formatDate(
      o.createdAt.toDate()
    )}</div>`;
  }

  html += `<div style="margin-top:8px;">`;
  html += `<div>${t("orderDetailsDriverLabel")}: ${escapeHtml(driverName || "-")}</div>`;
  html += `<div>${t("orderDetailsDriverPhoneLabel")}: ${escapeHtml(
    o.driverPhone || "-"
  )}</div>`;
  html += `<div>${t("orderDetailsCityLabel")}: ${escapeHtml(
    o.merchantCity || "-"
  )}</div>`;
  html += `<div>${t("orderDetailsCustomerNameLabel")}: ${escapeHtml(
    o.customerName || "-"
  )}</div>`;
  html += `<div>${t("orderDetailsAddressLabel")}: ${escapeHtml(
    o.deliveryAddress || "-"
  )}</div>`;

  if (totalKm) {
    html += `<div>${t("orderDetailsTotalDistanceLabel")}: ${totalKm}</div>`;
    if (d1 || d2) {
      const d1Label = d1 || "â€”";
      const d2Label = d2 || "â€”";
      const segText = t("orderDetailsSegmentDistancesLabel")
        .replace("{{d1}}", d1Label)
        .replace("{{d2}}", d2Label);
      html += `<div class="small">${segText}</div>`;
    }
  }

  html += `<div>${t("orderDetailsDeliveryCostLabel")}: ${feeLabel}</div>`;
  html += `<div>${t("orderDetailsNotesLabel")}: ${escapeHtml(
    o.notes || "-"
  )}</div>`;
  html += `</div>`;

  html += `<div class="btn-row">`;
  if (
    !o.status ||
    o.status === "pending" ||
    o.status === "accepted" ||
    o.status === "in_progress"
  ) {
    html += `<button class="secondary" onclick="printOrder('${o.id}')">${t(
      "orderDetailsPrintBtn"
    )}</button>`;
    html += `<button onclick="cancelOrder('${o.id}')" class="secondary">${t(
      "orderDetailsCancelBtn"
    )}</button>`;
  }
  html += `<button onclick="closeOrderModal()" class="secondary">${t(
    "orderDetailsCloseBtn"
  )}</button>`;
  html += `</div>`;

  modalContent.innerHTML = html;
  if (orderModalEl) orderModalEl.classList.remove("hidden");
  modalBackdrop.style.display = "flex";
  window.scrollTo(0, 0);
};

function closeOrderModal() {
  modalBackdrop.style.display = "none";
  modalContent.innerHTML = "";
  if (orderModalEl) orderModalEl.classList.add("hidden");
}

modalBackdrop.addEventListener("click", (e) => {
  if (e.target === modalBackdrop) closeOrderModal();
});

/* ========== Ù…Ù†Ø§Ø¯Ø§Ø© Ø§Ù„Ø³Ø§Ø¦Ù‚ (Ø¥Ù†Ø´Ø§Ø¡ call Ù„Ù„ØªØ§Ø¬Ø±) ========== */
async function createCallForDriver(driverId) {
  const driver = cachedDrivers[driverId] || {};

  if (!currentMerchantId) {
    showToast(t("toastNoMerchant"), "error");
    return;
  }

  if (!merchantCurrentOnline) {
    showToast(t("toastOffline"), "error");
    return;
  }

  if (driver.busy) {
    showToast(t("toastDriverBusy"), "error");
    return;
  }

  try {
    const merchantName = merchantNameEl.textContent || "";
    const merchantCity = merchantCityEl.textContent || "";

    const callData = {
      merchantId: currentMerchantId,
      merchantName,
      merchantCity,
      driverId,
      driverFirstName: driver.firstName || "",
      driverLastName: driver.lastName || "",
      driverPhone: driver.phone || "",
      status: "pending",
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    if (merchantLocationLat != null && merchantLocationLng != null) {
      callData.merchantLat = merchantLocationLat;
      callData.merchantLng = merchantLocationLng;
    }

    await db
      .collection("merchants")
      .doc(currentMerchantId)
      .collection("calls")
      .add(callData);

    if (merchantCallSoundEl) {
      try {
        merchantCallSoundEl.currentTime = 0;
        merchantCallSoundEl.play();
      } catch (e) {
        console.warn("ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Ø¯Ø§Ø¡:", e);
      }
    }

    closeDriverInfoWindow(driverId);

    const label = driver.firstName
      ? t("toastCallSentPrefix") + " " + driver.firstName
      : t("toastCallSentPrefix");
    showToast(label, "success");
  } catch (err) {
    showToast(t("toastErrorSendCallPrefix") + " " + err.message, "error");
  }
}

/* ========== Export / Print Ù„Ù„ØªØ§Ø¬Ø± ========== */
exportCsvBtn.addEventListener("click", () => {
  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  let completed = lastCallsCache.filter((c) =>
    completedStatuses.includes((c.status || "").toLowerCase())
  );

  const driverFilterVal = filterDriver.value;
  if (driverFilterVal) {
    completed = completed.filter((c) => c.driverId === driverFilterVal);
  }

  if (!completed.length) {
    if (driverFilterVal) {
      alert(t("alertNoExportForDriver"));
    } else {
      alert(t("alertNoExportAll"));
    }
    return;
  }

  const rows = [];
  // Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ù…ØªØ±Ø¬Ù…Ø©
  rows.push([
    t("csvHeaderId"),
    t("csvHeaderDriverId"),
    t("csvHeaderDriverName"),
    t("csvHeaderStatus"),
    t("csvHeaderRequestTime"),
    t("csvHeaderResponseTime"),
    t("csvHeaderMerchantName"),
    t("csvHeaderMerchantCity")
  ]);

  completed.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      ((c.driverFirstName || "") + " " + (c.driverLastName || "")).trim();

    const createdIso =
      c.createdAt && c.createdAt.toDate
        ? c.createdAt.toDate().toISOString()
        : "";

    const respondedIso =
      c.respondedAt && c.respondedAt.toDate
        ? c.respondedAt.toDate().toISOString()
        : "";

    rows.push([
      c.id,
      c.driverId || "",
      driverName,
      c.status || "",
      createdIso,
      respondedIso,
      c.merchantName || "",
      c.merchantCity || ""
    ]);
  });

  const csvContent = rows
    .map((r) =>
      r.map((c) => `"${String(c).replace(/"/g, '""')}"`).join(",")
    )
    .join("\n");

  const blob = new Blob([csvContent], {
    type: "text/csv;charset=utf-8;"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;

  let fileName = `calls_${new Date().toISOString().slice(0, 10)}.csv`;
  if (driverFilterVal) {
    const d = cachedDrivers[driverFilterVal] || {};
    const driverNameFile =
      ((d.firstName || "") + "_" + (d.lastName || "")).trim() || "driver";
    fileName = `calls_${driverNameFile}_${new Date()
      .toISOString()
      .slice(0, 10)}.csv`;
  }
  a.download = fileName;

  a.click();
  URL.revokeObjectURL(url);
});

printBtn.addEventListener("click", () => {
  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  let completed = lastCallsCache.filter((c) =>
    completedStatuses.includes((c.status || "").toLowerCase())
  );

  const driverFilterVal = filterDriver.value;
  if (driverFilterVal) {
    completed = completed.filter((c) => c.driverId === driverFilterVal);
  }

  if (!completed.length) {
    if (driverFilterVal) {
      alert(t("alertNoPrintForDriver"));
    } else {
      alert(t("alertNoPrintAll"));
    }
    return;
  }

  const docDir = currentLang === "ar" ? "rtl" : "ltr";

  let html =
    `<html dir="${docDir}"><head><meta charset="utf-8">` +
    `<title>${t("printCallsTitle")}</title></head><body>`;

  const nowStr = new Date().toLocaleString();

  if (driverFilterVal) {
    const d = cachedDrivers[driverFilterVal] || {};
    const driverName =
      ((d.firstName || "") + " " + (d.lastName || "")).trim() || "-";

    const heading = t("printCallsHeadingForDriver").replace(
      "{{driverName}}",
      escapeHtml(driverName)
    );
    html += `<h3>${heading} â€” ${nowStr}</h3>`;
  } else {
    html += `<h3>${t("printCallsHeadingAll")} â€” ${nowStr}</h3>`;
  }

  completed.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      ((c.driverFirstName || "") + " " + (c.driverLastName || "")).trim();

    const dateBase =
      c.respondedAt && c.respondedAt.toDate
        ? c.respondedAt.toDate()
        : c.createdAt && c.createdAt.toDate
        ? c.createdAt.toDate()
        : new Date();

    html += `
  <div style="border-bottom:1px solid #ddd; padding:8px;">
    <strong>#${getShortId(c.id)}</strong> â€” ${escapeHtml(
      driverName
    )} â€” ${formatDate(dateBase)}<br/>
    ${t("callStatusLabel")}: ${escapeHtml(c.status || "")}<br/>
    ${t("printMerchantLabel")}: ${escapeHtml(c.merchantName || "-")} (${escapeHtml(
      c.merchantCity || "-"
    )})
  </div>
`;
  });

  html += `</body></html>`;
  const w = window.open("", "_blank");
  w.document.write(html);
  w.document.close();
  w.print();
});

/* ========== ÙÙ„ØªØ± Ø§Ù„Ø³Ø§Ø¦Ù‚ÙŠÙ† ========== */
function refreshDriverFilterOptions() {
  const ids = Object.keys(cachedDrivers);
  const cur = filterDriver.value;
  filterDriver.innerHTML = `<option value="">${t("filterAllDrivers")}</option>`;
  ids.forEach((id) => {
    const d = cachedDrivers[id];
    const name = (d.firstName || "") + " " + (d.lastName || "");
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = name;
    filterDriver.appendChild(opt);
  });
  if (cur) filterDriver.value = cur;
}

/* ========== Ø·Ø¨Ø§Ø¹Ø© Ù†Ø¯Ø§Ø¡ Ù…ÙØ±Ø¯ (call) ========== */
window.printOrder = async function (callId) {
  if (!currentMerchantId) return alert(t("alertMerchantNotSet"));
  const doc = await db
    .collection("merchants")
    .doc(currentMerchantId)
    .collection("calls")
    .doc(callId)
    .get();
  if (!doc.exists) return alert(t("alertOrderNotFound"));
  const o = { id: doc.id, ...doc.data() };

  const shortId = getShortId(o.id);
  const docDir = currentLang === "ar" ? "rtl" : "ltr";

  const titlePrefix = t("printSingleOrderTitlePrefix");
  const headingPrefix = t("printSingleOrderHeadingPrefix");

  let html =
    `<html dir="${docDir}"><head><meta charset="utf-8">` +
    `<title>${titlePrefix} #${shortId}</title></head><body>`;

  html += `<h3>${headingPrefix} #${shortId}</h3>`;

  const driverName = (
    (o.driverFirstName || "") +
    " " +
    (o.driverLastName || "")
  ).trim();

  html += `<div>${t("printSingleOrderDriverLabel")}: ${escapeHtml(
    driverName
  )}</div>`;
  html += `<div>${t("printSingleOrderDriverPhoneLabel")}: ${escapeHtml(
    o.driverPhone || "-"
  )}</div>`;
  html += `<div>${t("printSingleOrderCustomerLabel")}: ${escapeHtml(
    o.customerName || "-"
  )}</div>`;
  html += `<div>${t("printSingleOrderAddressLabel")}: ${escapeHtml(
    o.deliveryAddress || "-"
  )}</div>`;
  html += `<div>${t("printSingleOrderCostLabel")}: ${escapeHtml(
    o.deliveryFee != null ? o.deliveryFee : "-"
  )}</div>`;

  html += `</body></html>`;
  const w = window.open("", "_blank");
  w.document.write(html);
  w.document.close();
  w.print();
};

/* ========== Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ (call) Ù…Ù† Ø§Ù„ØªØ§Ø¬Ø± ========== */
window.cancelOrder = async function (callId) {
  if (!currentMerchantId) return alert(t("alertMerchantNotSet"));
  if (!confirm(t("confirmCancelOrder"))) return;
  try {
    await db
      .collection("merchants")
      .doc(currentMerchantId)
      .collection("calls")
      .doc(callId)
      .update({
        status: "cancelled",
        cancelledAt: firebase.firestore.FieldValue.serverTimestamp()
      });
    closeOrderModal();
  } catch (err) {
    alert(t("alertCancelOrderErrorPrefix") + err.message);
  }
};

/* ========== small helpers ========== */
sortActive.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
sortCompleted.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
filterDriver.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);

/* ========== i18n: ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù„ØºØ© Ø¹Ù„Ù‰ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø«Ø§Ø¨ØªØ© ========== */
function applyLanguageToStaticUI() {
  document.title = t("pageTitle");
  const mainHeaderEl = document.getElementById("mainHeader");
  if (mainHeaderEl) mainHeaderEl.textContent = t("mainHeader");

  const langLabel = document.getElementById("langLabel");
  if (langLabel) langLabel.textContent = t("languageLabel");

  if (registerTab) registerTab.textContent = t("tabRegister");
  if (loginTab) loginTab.textContent = t("tabLogin");

  const regTitle = document.querySelector("#merchantForm h3");
  if (regTitle) regTitle.textContent = t("registerTitle");
  const storeNameEl = document.getElementById("storeName");
  if (storeNameEl) storeNameEl.placeholder = t("storeNamePlaceholder");
  const storeAddressEl = document.getElementById("storeAddress");
  if (storeAddressEl) storeAddressEl.placeholder = t("storeAddressPlaceholder");
  const storeCityEl = document.getElementById("storeCity");
  if (storeCityEl) storeCityEl.placeholder = t("storeCityPlaceholder");
  const storePhoneEl = document.getElementById("storePhone");
  if (storePhoneEl) storePhoneEl.placeholder = t("storePhonePlaceholder");
  const contactNameEl = document.getElementById("contactName");
  if (contactNameEl) contactNameEl.placeholder = t("contactNamePlaceholder");
  const contactPhoneEl = document.getElementById("contactPhone");
  if (contactPhoneEl) contactPhoneEl.placeholder = t("contactPhonePlaceholder");
  const contactEmailEl = document.getElementById("contactEmail");
  if (contactEmailEl) contactEmailEl.placeholder = t("contactEmailPlaceholder");
  const merchantPasswordEl = document.getElementById("merchantPassword");
  if (merchantPasswordEl) merchantPasswordEl.placeholder = t("merchantPasswordPlaceholder");
  const regSubmitBtn = merchantForm && merchantForm.querySelector('button[type="submit"]');
  if (regSubmitBtn) regSubmitBtn.textContent = t("registerSubmit");

  const loginTitle = document.querySelector("#loginForm h3");
  if (loginTitle) loginTitle.textContent = t("loginTitle");
  const loginEmailEl = document.getElementById("loginEmail");
  if (loginEmailEl) loginEmailEl.placeholder = t("loginEmailPlaceholder");
  const loginPasswordEl = document.getElementById("loginPassword");
  if (loginPasswordEl) loginPasswordEl.placeholder = t("loginPasswordPlaceholder");
  const loginSubmitBtn = loginForm && loginForm.querySelector('button[type="submit"]');
  if (loginSubmitBtn) loginSubmitBtn.textContent = t("loginSubmit");

  if (merchantOnlineToggle) {
    merchantOnlineToggle.textContent = merchantCurrentOnline ? t("topbarOnline") : t("topbarOffline");
  }
  if (merchantEarningsTopEl) {
    const currentHtml = merchantEarningsTopEl.innerHTML;
    const valueMatch = currentHtml.match(/<strong>(.*?)<\/strong>/);
    const val = valueMatch ? valueMatch[1] : "0 â‚¬";
    merchantEarningsTopEl.innerHTML = `${t("topbarTotalDelivery")}<br><strong>${val}</strong>`;
  }
  if (onlineDriversBadge) {
    const label = onlineDriversBadge.querySelector(".label");
    if (label) label.textContent = t("onlineDriversLabel");
  }

  const activeTitle = document.getElementById("activeOrdersTitle");
  if (activeTitle) activeTitle.textContent = t("activeOrdersTitle");
  const completedTitle = document.getElementById("completedOrdersTitle");
  if (completedTitle) completedTitle.textContent = t("completedOrdersTitle");

  if (filterDriver && filterDriver.options.length > 0) {
    filterDriver.options[0].textContent = t("filterAllDrivers");
  }

  if (sortActive && sortActive.options.length === 4) {
    sortActive.options[0].textContent = t("sortDateDesc");
    sortActive.options[1].textContent = t("sortDateAsc");
    sortActive.options[2].textContent = t("sortDriverAsc");
    sortActive.options[3].textContent = t("sortDriverDesc");
  }
  if (sortCompleted && sortCompleted.options.length === 4) {
    sortCompleted.options[0].textContent = t("sortDateDesc");
    sortCompleted.options[1].textContent = t("sortDateAsc");
    sortCompleted.options[2].textContent = t("sortDriverAsc");
    sortCompleted.options[3].textContent = t("sortDriverDesc");
  }
  // Ø¹Ù†ÙˆØ§Ù† Ù…ÙˆØ¯Ø§Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨ + Ø²Ø± Ø¥ØºÙ„Ø§Ù‚ ÙÙŠ Ø§Ù„Ù‡ÙŠØ¯Ø±
  const orderDetailsHeader = document.querySelector("#orderModal h3");
  if (orderDetailsHeader) {
    orderDetailsHeader.textContent = t("orderDetailsModalTitle");
  }

  if (exportCsvBtn) exportCsvBtn.textContent = t("exportCsv");
  if (printBtn) printBtn.textContent = t("print");
  if (logoutBtn) logoutBtn.textContent = t("logout");

  renderMerchantCalls(lastCallsCache || []);
}

function initLanguage() {
  const select = document.getElementById("langSelect");
  const saved = localStorage.getItem("merchantLang");
  if (saved && I18N[saved]) {
    currentLang = saved;
  } else {
    currentLang = "ar";
  }
  document.documentElement.lang = currentLang;
  if (select) select.value = currentLang;

  if (select) {
    select.addEventListener("change", () => {
      const val = select.value;
      if (I18N[val]) {
        currentLang = val;
        document.documentElement.lang = val;
        localStorage.setItem("merchantLang", val);
        applyLanguageToStaticUI();
      }
    });
  }

  applyLanguageToStaticUI();
}

/* ========== Clean up when leave ========== */
window.addEventListener("beforeunload", () => {
  if (ordersListenerUnsub) ordersListenerUnsub();
  if (driversListenerUnsub) driversListenerUnsub();
  if (merchantCallsListenerUnsub) merchantCallsListenerUnsub();
});

/* ØªØ´ØºÙŠÙ„ i18n Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª */
initLanguage();
</script>
</body>
</html>
