<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>نظام التوصيل — واجهة التاجر</title>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<style>
    :root{--primary:#4285F4;--card-bg:#fff;--muted:#666;}
    body {
  font-family: Arial, sans-serif;
  padding: 20px;
  background: #f3f6fb;
  color:#222;
}

/* RTL للعربية */
html[dir="rtl"] body {
  direction: rtl;
  text-align: right;
}

/* LTR للإنكليزي/الألماني/التركي */
html[dir="ltr"] body {
  direction: ltr;
  text-align: left;
}

    h2 { text-align: center; margin-bottom: 10px; }

    /* language switcher (فقط في شاشة التسجيل/الدخول) */
    .lang-switcher {
      max-width: 520px;
      margin: 0 auto 10px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .lang-switcher select {
      width: auto;
      min-width: 120px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fff;
    }
html[dir="ltr"] .lang-switcher {
  justify-content: flex-start;
}

    .tabs { display: flex; justify-content: center; gap:10px; margin-bottom: 20px; }
    .tab { padding: 10px 18px; border-radius: 8px; cursor: pointer; background: #e6eefc; color: #124; }
    .tab.active { background: var(--primary); color: #fff; box-shadow: 0 2px 8px rgba(66,133,244,0.3); }
    .card { background: var(--card-bg); border-radius: 10px; padding: 14px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); margin-bottom: 12px; }
    form { max-width: 520px; margin: 0 auto 10px; padding: 16px; border-radius: 10px; background: #fff; box-shadow: 0 1px 6px rgba(0,0,0,0.04); }
    input, select, button, textarea { width: 100%; padding: 10px; margin: 8px 0; border-radius: 8px; border: 1px solid #ddd; box-sizing: border-box; }
    button { background: var(--primary); color: #fff; border: none; cursor: pointer; }
    button.secondary { background: #fff; color: var(--primary); border: 1px solid #cde; }
    .hidden { display:none; }
    /* Merchant dashboard layout */
    #merchantDashboard { max-width: 1200px; margin: 0 auto; }
    .dashboard-top { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:12px; }
    .merchant-info { display:flex; gap:12px; align-items:center; }
    .stat { background:#fff; padding:10px 14px; border-radius:10px; min-width:120px; text-align:center; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }
    .main-row { display:flex; gap:18px; }
    .map-col { flex: 1.4; min-height:500px; border-radius:10px; overflow:hidden; }
    #map { width:100%; height:100%; min-height:500px; }
    .side-col { flex: 0.9; display:flex; flex-direction:column; gap:12px; min-width:320px; }
    .orders-list { max-height: 240px; overflow:auto; padding:10px; background:#fff; border-radius:10px; }
    .order-card { border:1px solid #eef; padding:10px; margin-bottom:8px; border-radius:8px; cursor:pointer; }
    .order-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    .controls { display:flex; gap:8px; align-items:center; }
    .small { font-size:13px; color:var(--muted); }
    /* modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:90%; max-width:520px; background:#fff; padding:18px; border-radius:12px; }
    .flex-between { display:flex; justify-content:space-between; align-items:center; }
    .btn-row { display:flex; gap:8px; margin-top:10px; }
   
    @media(max-width:980px){
        .main-row{ flex-direction:column; }
        .side-col{ min-width:auto; }
        form{ width:95%; }
    }
	/* ========== وضع واجهة التاجر الحديثة (خريطة كاملة + شريط علوي + قائمة جانبية) ========== */

body.merchant-mode {
  margin: 0;
  padding: 0;
}

/* نلغي شكل الكرت عن لوحة التاجر */
#merchantDashboard.merchant-dashboard {
  max-width: none;
  margin: 0;
  padding: 0;
  background: transparent;
  box-shadow: none;
}

/* حاوية الخريطة */
.merchant-map-wrapper {
  position: relative;
  width: 100%;
  height: 100vh; /* ملء الشاشة */
  overflow: hidden;
}

/* الخريطة نفسها */
.merchant-map-wrapper #map {
  width: 100%;
  height: 100%;
}

/* الشريط العلوي العائم فوق الخريطة */
.merchant-topbar {
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  background: rgba(15, 23, 42, 0.92);
  color: #fff;
  border-radius: 999px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.6);
  z-index: 10;
}

/* 
  ترتيب ثابت:
  - زر القائمة دائماً على اليمين
  - زر الحالة في المنتصف
  - الأرباح دائماً على اليسار
*/
html[dir="rtl"] .merchant-topbar {
  flex-direction: row;
  justify-content: space-between;
}

html[dir="ltr"] .merchant-topbar {
  flex-direction: row-reverse;
  justify-content: space-between;
}

/* زر القائمة (الهامبرغر) */
.topbar-btn {
  width: 34px;
  height: 34px;
  border-radius: 999px;
  background: #111827;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 18px;
}

/* زر أونلاين / أوفلاين */
.topbar-toggle {
  min-width: 90px;
  padding: 6px 14px;
  border-radius: 999px;
  background: #6b7280; /* أوفلاين */
  cursor: pointer;
  font-size: 14px;
}

.topbar-toggle[data-state="online"] {
  background: #22c55e; /* أونلاين */
}
/* وميض زر الأونلاين/أوفلاين للتاجر */
@keyframes merchant-blink {
  0%,100% { opacity: 1; }
  50%     { opacity: 0.3; }
}
.blink {
  animation: merchant-blink 0.8s linear infinite;
}

/* صندوق الأرباح في الشريط العلوي */
.topbar-earnings {
  font-size: 11px;
  line-height: 1.3;
  padding: 4px 10px;
  border-radius: 999px;
  background: #0f172a;
  text-align: center;
  white-space: nowrap;
}
.topbar-earnings strong {
  font-size: 14px;
}
/* كرت عدد السائقين الأونلاين (منفصل عن الشريط العلوي) */
.online-drivers-card {
  position: absolute;
  top: 0px;
  left: -150px;
  background: #ffffff;
  color: #111827;
  padding: 6px 12px;
  border-radius: 16px;
  box-shadow: 0 20px 25px rgba(15, 23, 42, 0.35);
  font-size: 13px;
  line-height: 1.4;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  z-index: 11;
  text-align: center;
  overflow: visible;
}
.online-drivers-card .count {
  font-weight: 700;   /* خط أعرض */
  font-size: 16px;    /* ممكن تكبير الرقم شوي */
  color: #22c55e;     /* أخضر واضح */
}
.drivers-picker-toggle {
  margin-top: 4px;
  padding: 2px 8px;
  border-radius: 999px;
  border: none;
  background: #0f172a;
  color: #e5e7eb;
  font-size: 11px;
  cursor: pointer;
}
.drivers-picker-toggle:hover {
  background: #1f2937;
}

/* البانل العائم للسائقين المتاحين */
.selected-drivers-panel {
  position: fixed;
  top: 100px;
  right: 10px;
  width: 230px;
  max-height: 60vh;
  background: #020617;
  color: #e5e7eb;
  border-radius: 14px;
  box-shadow: 0 12px 30px rgba(15,23,42,0.7);
  z-index: 30;
  padding: 8px 10px;
  display: none;
  overflow-y: auto;
}

.selected-drivers-panel.visible {
  display: block;
}

.selected-drivers-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
  font-size: 13px;
}

.selected-drivers-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.selected-driver-item {
  padding: 6px 8px;
  border-radius: 999px;
  background: #0f172a;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 6px;
  cursor: pointer;
  border: 1px solid #1f2937;
  font-size: 12px;
}

.selected-driver-item:hover {
  border-color: #22c55e;
}

.selected-driver-name {
  font-weight: 600;
}

.selected-driver-price {
  font-size: 11px;
  color: #9ca3af;
}

.selected-drivers-close {
  border: none;
  background: #111827;
  color: #e5e7eb;
  border-radius: 999px;
  width: 22px;
  height: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 13px;
}

@media (max-width: 600px) {
  .selected-drivers-panel {
    top: auto;
    bottom: 80px;
    right: 8px;
    left: 8px;
    width: auto;
    max-height: 40vh;
  }
}

html[dir="rtl"] .online-drivers-card {
  direction: rtl;
}

html[dir="ltr"] .online-drivers-card {
  direction: ltr;
}
/* مواءمة صندوق السائقين المتاحين على شاشات الجوال */
@media (max-width: 600px) {
  .online-drivers-card {
    top: 75px;                          /* تحت الشريط العلوي مباشرة */
    left: 50%;                          /* منتصف العرض */
    transform: translateX(-50%);        /* تمركز تام في المنتصف */
    max-width: calc(100vw - 32px);      /* ضمان بقائه داخل الشاشة */
  }
}

/* القائمة الجانبية (يمين) */
.merchant-side-panel {
  position: fixed;
  top: 0;
  right: 0;
  width: 380px;
  max-width: 80%;
  height: 100vh;
  background: #020617;
  color: #e5e7eb;
  box-shadow: -16px 0 40px rgba(0, 0, 0, 0.6);
  transform: translateX(100%);
  transition: transform 0.25s ease-out;
  z-index: 20;
  display: flex;
  flex-direction: column;
}

.merchant-side-panel.open {
  transform: translateX(0);
}

/* خلفية شفافة وراء القائمة */
.merchant-side-panel-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.35);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-out;
  z-index: 15;
}

.merchant-side-panel-backdrop.visible {
  opacity: 1;
  pointer-events: auto;
}

/* هيدر القائمة الجانبية */
.side-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 14px 6px;
  border-bottom: 1px solid rgba(15, 23, 42, 0.9);
}
.merchant-info-box {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.merchant-info-box .merchant-name {
  font-weight: 700;
}
.merchant-info-box .merchant-city {
  font-size: 13px;
  color: #9ca3af;
}
.icon-btn {
  width: 30px;
  height: 30px;
  border-radius: 999px;
  background: #111827;
  color: #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: none;
}

/* محتوى القائمة (تمرير عمودي) */
.side-panel-scroll {
  flex: 1;
  padding: 10px 14px 16px;
  overflow-y: auto;
}

/* صف الإحصاءات */
.stat-row {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}
.merchant-side-panel .stat {
  flex: 1;
  background: #020617;
  border-radius: 10px;
  padding: 8px 10px;
  min-width: 0;
  text-align: center;
  box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  border: 1px solid #111827;
  font-size: 12px;
}
.merchant-side-panel .stat strong {
  font-size: 16px;
}

/* أقسام الطلبات داخل القائمة */
.panel-section {
  background: #020617;
  border-radius: 10px;
  padding: 10px 10px 8px;
  margin-bottom: 12px;
  border: 1px solid #111827;
}

.panel-section .flex-between {
  margin-bottom: 6px;
}

/* تعديلات بسيطة على قائمة الطلبات لتناسب الخلفية الداكنة */
.merchant-side-panel .orders-list {
  max-height: 220px;
  padding: 6px;
  background: transparent;
  border-radius: 8px;
}
.merchant-side-panel .order-card {
  border: 1px solid #111827;
  background: #020617;
  color: #e5e7eb;
}
.merchant-side-panel .order-card:hover {
  box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  border-color: #1d4ed8;
}
@keyframes merchant-active-order-pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
    border-color: #22c55e;
  }
  70% {
    box-shadow: 0 0 0 8px rgba(34, 197, 94, 0);
    border-color: #22c55e;
  }
  100% {
    box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
    border-color: #22c55e;
  }
}

.merchant-side-panel .order-card.active-call {
  border-color: #22c55e;
  animation: merchant-active-order-pulse 1.2s ease-out infinite;
}

/* أزرار ثانوية داخل القائمة */
.merchant-side-panel button.secondary {
  background: #020617;
  color: #e5e7eb;
  border-color: #1f2937;
}

/* زر خروج ممتد */
.full-width {
  width: 100%;
  margin-top: 4px;
}
/* Toast notifications */
.toast-container {
  position: fixed;
  bottom: 18px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
}

.toast {
  min-width: 220px;
  max-width: 320px;
  background: rgba(15, 23, 42, 0.97);
  color: #f9fafb;
  padding: 10px 14px;
  border-radius: 999px;
  font-size: 13px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.7);
  display: flex;
  align-items: center;
  gap: 8px;
  opacity: 1;
  transition: opacity 0.4s ease-out, transform 0.4s ease-out;
}

/* اتجاه التوست حسب لغة الصفحة */
html[dir="rtl"] .toast {
  direction: rtl;
}

html[dir="ltr"] .toast {
  direction: ltr;
}

.toast-success {
  border: 1px solid #22c55e;
}

.toast-error {
  border: 1px solid #ef4444;
}

.toast-icon {
  font-size: 16px;
}

.toast.fade-out {
  opacity: 0;
  transform: translateY(8px);
}

/* زر مناداة السائق داخل البالون */
.call-btn {
  color: #fff !important;
  font-weight: 700;
}
/* تذييل النسخة التجريبية في واجهة التسجيل */
.beta-footer{
  max-width:520px;
  margin:8px auto 0;
  font-size:11px;
  color:#6b7280;
  text-align:center;
}

/* زر الملاحظة القانونية في القائمة الجانبية */
.merchant-side-panel .beta-legal-btn{
  margin-top:4px;
  margin-bottom:4px;
  font-size:11px;
}
.merchant-approved-banner {
  position: fixed;
  left: 50%;
  bottom: 16px;
  transform: translateX(-50%);
  background: var(--card, #ffffff);
  color: var(--ink-strong, #0f172a);
  padding: 12px 18px;
  border-radius: 999px;
  box-shadow: 0 15px 30px rgba(15, 23, 42, 0.25);
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  z-index: 9999;
}

.merchant-approved-banner.hidden {
  display: none;
}

</style>
</head>
<body>

<h2 id="mainHeader">نظام التوصيل — واجهة التاجر</h2>

<!-- language switcher (فقط على شاشة التسجيل/الدخول) -->
<div id="langSwitcher" class="lang-switcher">
  <label id="langLabel" for="langSelect">اللغة:</label>
  <select id="langSelect">
    <option value="ar">العربية</option>
    <option value="de">Deutsch</option>
    <option value="en">English</option>
    <option value="tr">Türkçe</option>
  </select>
</div>

<!-- التبويبات -->
<div class="tabs" id="authTabs">
    <div class="tab active" id="registerTab">تسجيل</div>
    <div class="tab" id="loginTab">تسجيل الدخول</div>
</div>

<!-- SECTION: Register (تاجر فقط) -->
<div id="registerSection" class="card">
    <form id="merchantForm" autocomplete="off">
        <h3>تسجيل تاجر</h3>
        <input type="text" id="storeName" placeholder="اسم المتجر" required />
        <input type="text" id="storeAddress" placeholder="عنوان المتجر" required />
        <input type="text" id="storeCity" placeholder="المدينة" required />
        <input type="text" id="storePhone" placeholder="رقم هاتف المتجر" required />
        <input type="text" id="contactName" placeholder="اسم جهة الاتصال" required />
        <input type="text" id="contactPhone" placeholder="رقم هاتف جهة الاتصال" required />
        <input type="email" id="contactEmail" placeholder="ايميل جهة الاتصال" required />
        <input type="password" id="merchantPassword" placeholder="كلمة السر (6+ حروف)" required />
        <button type="submit">تسجيل التاجر</button>
    </form>
</div>

<!-- SECTION: Login -->
<div id="loginSection" class="card hidden">
    <form id="loginForm" autocomplete="off">
        <h3>تسجيل الدخول (تاجر)</h3>
        <input type="email" id="loginEmail" placeholder="البريد الإلكتروني" required />
        <input type="password" id="loginPassword" placeholder="كلمة السر" required />
        <button type="submit">تسجيل الدخول</button>
    </form>
</div>
<!-- تذييل النسخة التجريبية في واجهة التسجيل -->
<div id="betaFooter" class="beta-footer">
  Taussil e.K. – Beta-Version im Testbetrieb. Nutzung auf eigene Verantwortung.
</div>

<!-- SECTION: Merchant Dashboard -->
<div id="merchantDashboard" class="hidden merchant-dashboard">
  <div class="merchant-map-wrapper">
  <!-- الخريطة ملء الشاشة -->
  <div id="map"></div>

  <!-- بانل السائقين المتاحين (مرتب من الأقل سعراً للأغلى) -->
  <div id="driversPickerPanel" class="selected-drivers-panel">
    <div class="selected-drivers-header">
      <span id="driversPickerTitle">السائقون المتاحون (من الأقل سعراً)</span>
      <button id="driversPickerClose" type="button" class="selected-drivers-close">✕</button>
    </div>
    <div id="driversPickerList" class="selected-drivers-list"></div>
  </div>

    <!-- الشريط العلوي العائم: يمين زر القائمة، وسط أونلاين/أوفلاين، يسار الأرباح -->
    <div class="merchant-topbar">
      <button id="merchantMenuBtn" class="topbar-btn" type="button">☰</button>
      <button id="merchantOnlineToggle" class="topbar-toggle" type="button" data-state="offline">
        أوفلاين
      </button>
      <div id="merchantEarnings" class="topbar-earnings">
        إجمالي التوصيل<br><strong>0 €</strong>
      </div>
      <!-- صندوق عدد السائقين الأونلاين -->
      <div id="onlineDriversBadge" class="online-drivers-card">
  <div>
    <span class="label">السائقون المتاحون</span>
    <span class="count">0</span>
  </div>
  <!-- زر السهم لفتح قائمة السائقين -->
  <button id="openDriversPicker" class="drivers-picker-toggle" type="button">▾</button>
</div>

    </div>

    <!-- القائمة الجانبية -->
    <aside id="merchantSidePanel" class="merchant-side-panel">
      <div class="side-panel-header">
        <div class="merchant-info-box">
          <div id="merchantName" class="merchant-name">اسم التاجر</div>
          <div id="merchantCity" class="merchant-city small">العنوان</div>
        </div>
        <button id="closeSidePanel" class="icon-btn" type="button">✕</button>
      </div>

      <div class="side-panel-scroll">
        <!-- الإحصاءات -->
        <div class="stat-row">
          <div class="stat" id="countActive">
            الأوامر النشطة<br /><strong>0</strong>
          </div>
          <div class="stat" id="countCompleted">
            الأوامر السابقة<br /><strong>0</strong>
          </div>
          <div class="stat" id="totalDelivery">
            تكاليف التوصيل<br /><strong>0</strong>
          </div>
        </div>

        <!-- الطلبات النشطة -->
        <div class="panel-section">
          <div class="flex-between">
            <div><strong id="activeOrdersTitle">الطلبات النشطة</strong></div>
            <div class="controls">
              <select id="filterDriver">
                <option value="">الجميع</option>
              </select>
              <select id="sortActive">
                <option value="date_desc">الأحدث أولاً</option>
                <option value="date_asc">الأقدم أولاً</option>
                <option value="driver_asc">السائق أ-ي</option>
                <option value="driver_desc">السائق ي-أ</option>
              </select>
            </div>
          </div>
          <div id="activeOrders" class="orders-list"></div>
        </div>

        <!-- الطلبات السابقة -->
        <div class="panel-section">
          <div class="flex-between">
            <div><strong id="completedOrdersTitle">الطلبات السابقة</strong></div>
            <div class="controls">
              <button id="exportCsv" class="secondary">تصدير CSV</button>
              <button id="printBtn" class="secondary">طباعة</button>
              <select id="sortCompleted">
                <option value="date_desc">الأحدث أولاً</option>
                <option value="date_asc">الأقدم أولاً</option>
                <option value="driver_asc">السائق أ-ي</option>
                <option value="driver_desc">السائق ي-أ</option>
              </select>
            </div>
          </div>
          <div id="completedOrders" class="orders-list"></div>
        </div>
<!-- زر الملاحظة القانونية للنسخة التجريبية -->
        <button id="betaLegalBtn" class="secondary full-width beta-legal-btn" type="button">
          Hinweis zur Testphase (Beta-Version)
        </button>
        <!-- زر الخروج -->
        <button id="logoutBtn" class="secondary full-width">تسجيل خروج</button>
      </div>
    </aside>

    <!-- خلفية القائمة الجانبية -->
    <div id="merchantSidePanelBackdrop" class="merchant-side-panel-backdrop"></div>
  </div>
</div>

<!-- تفاصيل الطلب (مودال) -->
<div id="orderModal" class="hidden">
    <div class="modal-backdrop" id="modalBackdrop" style="display:none;">
        <div class="modal">
            <div class="flex-between">
                <h3>تفاصيل الطلب</h3>
                
            </div>
            <div id="modalContent" style="margin-top:12px;"></div>
        </div>
    </div>
</div>

<!-- مودال الملاحظة القانونية للنسخة التجريبية -->
<div id="betaLegalModal" class="hidden">
  <div class="modal-backdrop" id="betaLegalBackdrop" style="display:none;">
    <div class="modal">
      <div class="flex-between">
        <h3>Hinweis zur Testphase (Beta-Version)</h3>
        <button type="button" id="betaLegalClose" class="icon-btn">✕</button>
      </div>
      <div style="margin-top:12px; max-height:60vh; overflow:auto; font-size:13px; line-height:1.5;">
        <p>Die Plattform „Taussil“ befindet sich derzeit in einer begrenzten Testphase (Beta-Version) und wird ausschließlich zu Erprobungs- und Verbesserungszwecken eingesetzt.</p>

        <p>Taussil stellt lediglich eine technische Vermittlungsplattform zwischen Händlern und Fahrern zur Verfügung. Verträge über Lieferungen, Zahlungen oder sonstige Leistungen werden ausschließlich zwischen Händler und Fahrer (und ggf. dessen Kunden) geschlossen.</p>

        <p>Taussil übernimmt keine Haftung für:</p>
        <ul>
          <li>die ordnungsgemäße Durchführung der Lieferung,</li>
          <li>das Verhalten von Fahrern oder Händlern,</li>
          <li>den Verlust, die verspätete Übergabe oder die Nicht-Übergabe von Bargeldbeträgen, die Fahrer im Auftrag des Händlers bei Kunden kassieren,</li>
          <li>Streitigkeiten oder Schäden, die aus dem Verhältnis zwischen Händler, Fahrer und Endkunden entstehen.</li>
        </ul>

        <p>Die Nutzung der Plattform in dieser Testphase erfolgt auf eigenes Risiko des Händlers. Es besteht kein Anspruch auf fehlerfreien Betrieb, permanente Verfügbarkeit oder bestimmte Funktionen. Daten und Einstellungen können sich im Rahmen der Weiterentwicklung der Software ändern.</p>

        <p>Mit der Nutzung der Plattform in dieser Beta-Version erkennt der Händler diese Rahmenbedingungen ausdrücklich an.</p>
      </div>
    </div>
  </div>
</div>

<!-- صوت عند التحول إلى أونلاين للتاجر -->
<audio id="merchantOnlineSound" src="online1.mp3" preload="auto"></audio>
<!-- صوت عند قبول الطلب من السائق -->
<audio id="callAcceptedSound" src="send.mp3" preload="auto"></audio>

<!-- صوت عند بدء توجه السائق إلى التاجر -->
<audio id="driverOnWaySound" src="unterwegs.mp3" preload="auto"></audio>

<!-- صوت قبل دقيقة من الوصول أو ضمن 500م -->
<audio id="driverNearSound" src="1m.mp3" preload="auto"></audio>

<audio id="merchantCallSound" src="send.mp3" preload="auto"></audio>
<audio id="customerDeliveredSound" src="Geliefert.mp3" preload="auto"></audio>
<audio id="merchantOnlineSound" src="online1.mp3" preload="auto"></audio>

<!-- Toast notifications -->
<div id="toastContainer" class="toast-container"></div>
<div id="merchantApprovedBanner" class="merchant-approved-banner hidden">
  <span id="merchantApprovedBannerText"></span>
</div>

<!-- Google Maps API -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCUMgXQwwe7afBlRpp6zrXunbTVSCXfSqQ&libraries=geometry"></script>

<script>
/* ========== الترجمة (i18n) الأساسية ========== */
const I18N = {
  ar: {
    pageTitle: "نظام التوصيل — واجهة التاجر",
    mainHeader: "نظام التوصيل — واجهة التاجر",
    languageLabel: "اللغة:",
    tabRegister: "تسجيل",
    tabLogin: "تسجيل الدخول",
    registerTitle: "تسجيل تاجر",
    storeNamePlaceholder: "اسم المتجر",
    storeAddressPlaceholder: "عنوان المتجر",
    storeCityPlaceholder: "المدينة",
    storePhonePlaceholder: "رقم هاتف المتجر",
    contactNamePlaceholder: "اسم جهة الاتصال",
    contactPhonePlaceholder: "رقم هاتف جهة الاتصال",
    contactEmailPlaceholder: "ايميل جهة الاتصال",
    merchantPasswordPlaceholder: "كلمة السر (6+ حروف)",
    registerSubmit: "تسجيل التاجر",
    loginTitle: "تسجيل الدخول (تاجر)",
    loginEmailPlaceholder: "البريد الإلكتروني",
    loginPasswordPlaceholder: "كلمة السر",
    loginSubmit: "تسجيل الدخول",
    topbarOnline: "متصل",
    topbarOffline: "غير متصل",
    topbarTotalDelivery: "تكاليف التوصيل",
    onlineDriversLabel: "السائقون المتاحون",
    statsActiveCalls: "الأوامر النشطة",
    statsPastCalls: "الأوامر السابقة",
    statsTotalDelivery: "تكاليف التوصيل",
    activeOrdersTitle: "الأوامر النشطة",
    completedOrdersTitle: "الأوامر السابقة",
    filterAllDrivers: "الجميع",
    sortDateDesc: "الأحدث أولاً",
    sortDateAsc: "الأقدم أولاً",
    sortDriverAsc: "السائق أ-ي",
    sortDriverDesc: "السائق ي-أ",
    exportCsv: "تصدير CSV",
    print: "طباعة",
    logout: "تسجيل خروج",
        callStatusLabel: "حالة النداء",
		cancelActiveOrderConfirm:
      "السائق الذي اخترته في طريقه إليك.\n\nهل تريد بالفعل حذف هذا الطلب؟\nإذا قمت بحذف الطلب سيتم احتساب المسافة التي قطعها السائق بناءً على أسعار السائق.",
    toastNoMerchant: "لا يمكن إرسال نداء: لم يتم تحديد التاجر الحالي.",
    toastOffline: "لا يمكنك إرسال نداءات وأنت في وضع أوفلاين. الرجاء التحويل إلى أونلاين أولاً.",
    toastDriverBusy: "السائق مشغول حالياً ولا يمكن مناداته.",
    toastCallSentPrefix: "تم إرسال نداء للسائق",
    toastErrorSendCallPrefix: "خطأ أثناء إرسال النداء:",
    toastDriverHeadingMerchantWithName: "السائق {{name}} في طريقه إليك",
    toastDriverHeadingMerchantNoName: "السائق في طريقه إليك",
    toastDriverHeadingCustomerWithName: "السائق {{name}} في طريقه للعميل",
    toastDriverHeadingCustomerNoName: "السائق في طريقه للعميل",
// === CSV / Print ===
    csvHeaderId: "المعرّف",
    csvHeaderDriverId: "معرّف السائق",
    csvHeaderDriverName: "اسم السائق",
    csvHeaderStatus: "الحالة",
    csvHeaderRequestTime: "وقت الطلب",
    csvHeaderResponseTime: "وقت الاستجابة",
    csvHeaderMerchantName: "اسم التاجر",
    csvHeaderMerchantCity: "مدينة التاجر",

    alertNoExportForDriver: "لا توجد طلبات سابقة لهذا السائق للتصدير.",
    alertNoExportAll: "لا توجد طلبات للتصدير.",
    alertNoPrintForDriver: "لا توجد طلبات سابقة لهذا السائق للطباعة.",
    alertNoPrintAll: "لا توجد طلبات سابقة للطباعة.",

    printCallsTitle: "طباعة النداءات",
    printCallsHeadingAll: "النداءات السابقة",
    printCallsHeadingForDriver: "النداءات السابقة — {{driverName}}",
    printMerchantLabel: "المتجر",

    printSingleOrderTitlePrefix: "طلب",
    printSingleOrderHeadingPrefix: "طلب",
    printSingleOrderDriverLabel: "السائق",
    printSingleOrderDriverPhoneLabel: "هاتف السائق",
    printSingleOrderCustomerLabel: "العميل",
    printSingleOrderAddressLabel: "العنوان",
    printSingleOrderCostLabel: "التكلفة",
	    // === Order details modal ===
    orderDetailsModalTitle: "تفاصيل الطلب",
    orderDetailsHeadingPrefix: "طلب / نداء",
    orderDetailsStatusLabel: "الحالة",
    orderDetailsDateLabel: "تاريخ",
    orderDetailsDriverLabel: "السائق",
    orderDetailsDriverPhoneLabel: "هاتف السائق",
    orderDetailsCityLabel: "المدينة",
    orderDetailsCustomerNameLabel: "اسم العميل",
    orderDetailsAddressLabel: "العنوان",
    orderDetailsTotalDistanceLabel: "المسافة الكلية المقطوعة",
    orderDetailsSegmentDistancesLabel: "من السائق إلى التاجر: {{d1}} / من التاجر إلى نقطة التسليم: {{d2}}",
    orderDetailsDeliveryCostLabel: "تكلفة التوصيل",
    orderDetailsNotesLabel: "ملاحظات",
    orderDetailsPrintBtn: "طباعة",
    orderDetailsCancelBtn: "إلغاء",
    orderDetailsCloseBtn: "إغلاق",

    // Alerts / confirm
    confirmCancelOrder: "هل ترغب فعلاً في إلغاء هذا الطلب؟",
    alertMerchantNotSet: "لم يتم تحديد التاجر.",
    alertOrderNotFound: "طلب غير موجود",
    alertCancelOrderErrorPrefix: "خطأ أثناء إلغاء الطلب: ",
printReportTitle: "تقرير التوصيل",
printMerchantLabel: "التاجر:",
printDriverLabel: "السائق:",
printDateLabel: "التاريخ:",
printDeliveryCostSummaryLabel: "التكلفة المحددة للتوصيل:",
printPricingMultiDrivers: "متعدد السائقين — راجع تسعيرة كل سائق على حدة.",
printPricingMissing: "لم يتم تحديد تسعيرة واضحة لهذا السائق في النظام.",
printNoCompletedGlobal: "لا توجد طلبات سابقة للطباعة.",
printNoCompletedForDriver: "لا توجد طلبات سابقة لهذا السائق للطباعة.",
printTableMerchant: "اسم التاجر",
printTableDriver: "اسم السائق",
printTableId: "ID الطلب",
printTableStatus: "الحالة",
printTableCreatedAt: "تاريخ الإنشاء",
printTableCustomerAddress: "عنوان العميل",
printTableDistDriverMerchant: "المسافة من السائق إلى التاجر (كم)",
printTableDistMerchantCustomer: "المسافة من التاجر إلى العميل (كم)",
printTableFee: "تكلفة التوصيل (€)",
// داخل I18N.ar = { ... }
printTitleCalls: "تقرير النداءات السابقة",
printMerchantLabel: "التاجر",
printDriverLabel: "السائق",
printDateGenerated: "تاريخ الطباعة (توقيت UTC)",
printDriverPricingTitle: "تسعيرة التوصيل للسائق",
printBaseFeeLabel: "الرسوم الأساسية",
printPerKmToCustomerLabel: "لكل كيلومتر (من التاجر إلى العميل)",
printPerKmToMerchantLabel: "لكل كيلومتر (من السائق إلى التاجر)",
printFreeKmLabel: "أول {KM} كم مجاناً",
printColMerchant: "اسم التاجر",
printColDriver: "اسم السائق",
printColOrderId: "رقم الطلب",
printColStatus: "الحالة",
printColCreatedAt: "تاريخ الإنشاء (UTC)",
printColCustomerAddress: "عنوان العميل",
printColDistDriverToMerchant: "المسافة: سائق → تاجر (كم)",
printColDistMerchantToCustomer: "المسافة: تاجر → عميل (كم)",
printColDeliveryFee: "تكلفة التوصيل (€)",
printFooterTotalOrders: "مجموع الطلبات",
printFooterTotalFees: "مجموع تكاليف التوصيل (€)",
printNoOrders: "لا توجد طلبات سابقة للطباعة.",
printNoOrdersForDriver: "لا توجد طلبات سابقة لهذا السائق للطباعة.",

  },
  en: {
    pageTitle: "Delivery System — Merchant Interface",
    mainHeader: "Delivery System — Merchant Interface",
    languageLabel: "Language:",
    tabRegister: "Register",
    tabLogin: "Login",
    registerTitle: "Merchant registration",
    storeNamePlaceholder: "Store name",
    storeAddressPlaceholder: "Store address",
    storeCityPlaceholder: "City",
    storePhonePlaceholder: "Store phone number",
    contactNamePlaceholder: "Contact person name",
    contactPhonePlaceholder: "Contact person phone",
    contactEmailPlaceholder: "Contact email",
    merchantPasswordPlaceholder: "Password (6+ characters)",
    registerSubmit: "Register merchant",
    loginTitle: "Login (merchant)",
    loginEmailPlaceholder: "Email",
    loginPasswordPlaceholder: "Password",
    loginSubmit: "Login",
    topbarOnline: "Online",
    topbarOffline: "Offline",
    topbarTotalDelivery: "Total delivery",
    onlineDriversLabel: "Available drivers",
    statsActiveCalls: "Active calls",
    statsPastCalls: "Past calls",
    statsTotalDelivery: "Total delivery",
    activeOrdersTitle: "Active orders",
    completedOrdersTitle: "Past orders",
    filterAllDrivers: "All",
    sortDateDesc: "Newest first",
    sortDateAsc: "Oldest first",
    sortDriverAsc: "Driver A–Z",
    sortDriverDesc: "Driver Z–A",
    exportCsv: "Export CSV",
    print: "Print",
    logout: "Logout",
    
	    callStatusLabel: "Call status",
		cancelActiveOrderConfirm:
      "The driver you selected is already on the way to you.\n\nDo you really want to cancel this order?\nIf you cancel, the distance the driver has already travelled will be charged according to the driver's pricing.",
    toastNoMerchant: "Cannot send a call: current merchant is not set.",
    toastOffline: "You can't send calls while you are offline. Please switch to online first.",
    toastDriverBusy: "The driver is currently busy and cannot be called.",
    toastCallSentPrefix: "Call sent to driver",
    toastErrorSendCallPrefix: "Error while sending the call:",
    toastDriverHeadingMerchantWithName: "Driver {{name}} is on the way to you",
    toastDriverHeadingMerchantNoName: "The driver is on the way to you",
    toastDriverHeadingCustomerWithName: "Driver {{name}} is on the way to the customer",
    toastDriverHeadingCustomerNoName: "The driver is on the way to the customer",
// === CSV / Print ===
    csvHeaderId: "ID",
    csvHeaderDriverId: "Driver ID",
    csvHeaderDriverName: "Driver name",
    csvHeaderStatus: "Status",
    csvHeaderRequestTime: "Request time",
    csvHeaderResponseTime: "Response time",
    csvHeaderMerchantName: "Merchant name",
    csvHeaderMerchantCity: "Merchant city",

    alertNoExportForDriver: "There are no past orders for this driver to export.",
    alertNoExportAll: "There are no orders to export.",
    alertNoPrintForDriver: "There are no past orders for this driver to print.",
    alertNoPrintAll: "There are no past orders to print.",

    printCallsTitle: "Print calls",
    printCallsHeadingAll: "Past calls",
    printCallsHeadingForDriver: "Past calls — {{driverName}}",
    printMerchantLabel: "Merchant",

    printSingleOrderTitlePrefix: "Order",
    printSingleOrderHeadingPrefix: "Order",
    printSingleOrderDriverLabel: "Driver",
    printSingleOrderDriverPhoneLabel: "Driver phone",
    printSingleOrderCustomerLabel: "Customer",
    printSingleOrderAddressLabel: "Address",
    printSingleOrderCostLabel: "Cost",
	    // === Order details modal ===
    orderDetailsModalTitle: "Order details",
    orderDetailsHeadingPrefix: "Order / Call",
    orderDetailsStatusLabel: "Status",
    orderDetailsDateLabel: "Date",
    orderDetailsDriverLabel: "Driver",
    orderDetailsDriverPhoneLabel: "Driver phone",
    orderDetailsCityLabel: "City",
    orderDetailsCustomerNameLabel: "Customer name",
    orderDetailsAddressLabel: "Address",
    orderDetailsTotalDistanceLabel: "Total distance travelled",
    orderDetailsSegmentDistancesLabel: "Driver → merchant: {{d1}} / Merchant → drop-off: {{d2}}",
    orderDetailsDeliveryCostLabel: "Delivery cost",
    orderDetailsNotesLabel: "Notes",
    orderDetailsPrintBtn: "Print",
    orderDetailsCancelBtn: "Cancel",
    orderDetailsCloseBtn: "Close",

    // Alerts / confirm
    confirmCancelOrder: "Do you really want to cancel this order?",
    alertMerchantNotSet: "Merchant is not set.",
    alertOrderNotFound: "Order not found.",
    alertCancelOrderErrorPrefix: "Error while cancelling the order: ",
printReportTitle: "Delivery report",
printMerchantLabel: "Merchant:",
printDriverLabel: "Driver:",
printDateLabel: "Date:",
printDeliveryCostSummaryLabel: "Configured delivery pricing:",
printPricingMultiDrivers: "Multiple drivers — please refer to each driver's pricing.",
printPricingMissing: "No clear pricing configured for this driver.",
printNoCompletedGlobal: "No past orders to print.",
printNoCompletedForDriver: "No past orders for this driver to print.",
printTableMerchant: "Merchant name",
printTableDriver: "Driver name",
printTableId: "Order ID",
printTableStatus: "Status",
printTableCreatedAt: "Created at",
printTableCustomerAddress: "Customer address",
printTableDistDriverMerchant: "Distance driver → merchant (km)",
printTableDistMerchantCustomer: "Distance merchant → customer (km)",
printTableFee: "Delivery fee (€)",
// داخل I18N.en = { ... }
printTitleCalls: "Delivery calls report",
printMerchantLabel: "Merchant",
printDriverLabel: "Driver",
printDateGenerated: "Print date (UTC)",
printDriverPricingTitle: "Driver delivery pricing",
printBaseFeeLabel: "Base fee",
printPerKmToCustomerLabel: "Per km (merchant → customer)",
printPerKmToMerchantLabel: "Per km (driver → merchant)",
printFreeKmLabel: "First {KM} km free",
printColMerchant: "Merchant name",
printColDriver: "Driver name",
printColOrderId: "Order ID",
printColStatus: "Status",
printColCreatedAt: "Created at (UTC)",
printColCustomerAddress: "Customer address",
printColDistDriverToMerchant: "Distance: driver → merchant (km)",
printColDistMerchantToCustomer: "Distance: merchant → customer (km)",
printColDeliveryFee: "Delivery fee (€)",
printFooterTotalOrders: "Total orders",
printFooterTotalFees: "Total delivery fees (€)",
printNoOrders: "No past orders to print.",
printNoOrdersForDriver: "No past orders for this driver to print.",

  },
  de: {
    pageTitle: "Liefersystem — Händleroberfläche",
    mainHeader: "Liefersystem — Händleroberfläche",
    languageLabel: "Sprache:",
    tabRegister: "Registrieren",
    tabLogin: "Anmelden",
    registerTitle: "Händler registrieren",
    storeNamePlaceholder: "Name des Geschäfts",
    storeAddressPlaceholder: "Adresse des Geschäfts",
    storeCityPlaceholder: "Stadt",
    storePhonePlaceholder: "Telefon des Geschäfts",
    contactNamePlaceholder: "Ansprechperson",
    contactPhonePlaceholder: "Telefon der Ansprechperson",
    contactEmailPlaceholder: "E-Mail der Ansprechperson",
    merchantPasswordPlaceholder: "Passwort (mind. 6 Zeichen)",
    registerSubmit: "Händler registrieren",
    loginTitle: "Anmeldung (Händler)",
    loginEmailPlaceholder: "E-Mail",
    loginPasswordPlaceholder: "Passwort",
    loginSubmit: "Anmelden",
    topbarOnline: "Online",
    topbarOffline: "Offline",
    topbarTotalDelivery: "Lieferkosten",
    onlineDriversLabel: "Verfügbare Fahrer",
    statsActiveCalls: "Aktive Lieferung",
    statsPastCalls: "Alte Lieferung",
    statsTotalDelivery: "Lieferkosten",
    activeOrdersTitle: "Aktive Lieferung",
    completedOrdersTitle: "Alte Lieferungen",
    filterAllDrivers: "Alle",
    sortDateDesc: "Neueste zuerst",
    sortDateAsc: "Älteste zuerst",
    sortDriverAsc: "Fahrer A–Z",
    sortDriverDesc: "Fahrer Z–A",
    exportCsv: "CSV exportieren",
    print: "Drucken",
    logout: "Abmelden",
        callStatusLabel: "Anfragestatus",
		    cancelActiveOrderConfirm:
      "Der von dir ausgewählte Fahrer ist bereits auf dem Weg zu dir.\n\nMöchtest du diese Bestellung wirklich stornieren?\nWenn du stornierst, wird die bereits gefahrene Strecke gemäß der Preisgestaltung des Fahrers berechnet.",
    toastNoMerchant: "Anfrage kann nicht gesendet werden: aktueller Händler ist nicht festgelegt.",
    toastOffline: "Sie können keine Anfragen senden, während Sie offline sind. Bitte gehen Sie zuerst online.",
    toastDriverBusy: "Der Fahrer ist momentan beschäftigt und kann nicht angefragt werden.",
    toastCallSentPrefix: "Anfrage an Fahrer gesendet",
    toastErrorSendCallPrefix: "Fehler beim Senden der Anfrage:",
    toastDriverHeadingMerchantWithName: "Fahrer {{name}} ist auf dem Weg zu Ihnen",
    toastDriverHeadingMerchantNoName: "Der Fahrer ist auf dem Weg zu Ihnen",
    toastDriverHeadingCustomerWithName: "Fahrer {{name}} ist auf dem Weg zum Kunden",
    toastDriverHeadingCustomerNoName: "Der Fahrer ist auf dem Weg zum Kunden",
// === CSV / Print ===
    csvHeaderId: "ID",
    csvHeaderDriverId: "Fahrer-ID",
    csvHeaderDriverName: "Fahrername",
    csvHeaderStatus: "Status",
    csvHeaderRequestTime: "Anfragezeit",
    csvHeaderResponseTime: "Antwortzeit",
    csvHeaderMerchantName: "Händlername",
    csvHeaderMerchantCity: "Händlerstadt",

    alertNoExportForDriver: "Für diesen Fahrer gibt es keine früheren Bestellungen zum Exportieren.",
    alertNoExportAll: "Es gibt keine Bestellungen zum Exportieren.",
    alertNoPrintForDriver: "Für diesen Fahrer gibt es keine früheren Bestellungen zum Drucken.",
    alertNoPrintAll: "Es gibt keine früheren Bestellungen zum Drucken.",

    printCallsTitle: "Anfragen drucken",
    printCallsHeadingAll: "Frühere Anfragen",
    printCallsHeadingForDriver: "Frühere Anfragen — {{driverName}}",
    printMerchantLabel: "Händler",

    printSingleOrderTitlePrefix: "Bestellung",
    printSingleOrderHeadingPrefix: "Bestellung",
    printSingleOrderDriverLabel: "Fahrer",
    printSingleOrderDriverPhoneLabel: "Fahrertelefon",
    printSingleOrderCustomerLabel: "Kunde",
    printSingleOrderAddressLabel: "Adresse",
    printSingleOrderCostLabel: "Kosten",
	    // === Order details modal ===
    orderDetailsModalTitle: "Bestelldetails",
    orderDetailsHeadingPrefix: "Bestellung / Anfrage",
    orderDetailsStatusLabel: "Status",
    orderDetailsDateLabel: "Datum",
    orderDetailsDriverLabel: "Fahrer",
    orderDetailsDriverPhoneLabel: "Fahrertelefon",
    orderDetailsCityLabel: "Stadt",
    orderDetailsCustomerNameLabel: "Kundenname",
    orderDetailsAddressLabel: "Adresse",
    orderDetailsTotalDistanceLabel: "Gesamt zurückgelegte Strecke",
    orderDetailsSegmentDistancesLabel: "Vom Fahrer zum Händler: {{d1}} / Vom Händler zum Ziel: {{d2}}",
    orderDetailsDeliveryCostLabel: "Lieferkosten",
    orderDetailsNotesLabel: "Notizen",
    orderDetailsPrintBtn: "Drucken",
    orderDetailsCancelBtn: "Stornieren",
    orderDetailsCloseBtn: "Schließen",

    // Alerts / confirm
    confirmCancelOrder: "Möchten Sie diese Bestellung wirklich stornieren?",
    alertMerchantNotSet: "Händler ist nicht gesetzt.",
    alertOrderNotFound: "Bestellung nicht gefunden.",
    alertCancelOrderErrorPrefix: "Fehler beim Stornieren der Bestellung: ",
printReportTitle: "Lieferbericht",
printMerchantLabel: "Händler:",
printDriverLabel: "Fahrer:",
printDateLabel: "Datum:",
printDeliveryCostSummaryLabel: "Hinterlegte Lieferkosten:",
printPricingMultiDrivers: "Mehrere Fahrer – bitte die Preise je Fahrer prüfen.",
printPricingMissing: "Für diesen Fahrer ist kein eindeutiger Tarif hinterlegt.",
printNoCompletedGlobal: "Keine vergangenen Aufträge zum Drucken.",
printNoCompletedForDriver: "Keine vergangenen Aufträge für diesen Fahrer zum Drucken.",
printTableMerchant: "Händlername",
printTableDriver: "Fahrername",
printTableId: "Bestell-ID",
printTableStatus: "Status",
printTableCreatedAt: "Erstellt am",
printTableCustomerAddress: "Kundenadresse",
printTableDistDriverMerchant: "Entfernung Fahrer → Händler (km)",
printTableDistMerchantCustomer: "Entfernung Händler → Kunde (km)",
printTableFee: "Liefergebühr (€)",
// داخل I18N.de = { ... }
printTitleCalls: "Lieferanfragen – Bericht",
printMerchantLabel: "Händler",
printDriverLabel: "Fahrer",
printDateGenerated: "Druckdatum (UTC)",
printDriverPricingTitle: "Fahrerpreis für Lieferungen",
printBaseFeeLabel: "Grundgebühr",
printPerKmToCustomerLabel: "pro km (Händler → Kunde)",
printPerKmToMerchantLabel: "pro km (Fahrer → Händler)",
printFreeKmLabel: "Die ersten {KM} km kostenlos",
printColMerchant: "Name des Händlers",
printColDriver: "Name des Fahrers",
printColOrderId: "Bestell-ID",
printColStatus: "Status",
printColCreatedAt: "Erstellt am (UTC)",
printColCustomerAddress: "Adresse des Kunden",
printColDistDriverToMerchant: "Distanz: Fahrer → Händler (km)",
printColDistMerchantToCustomer: "Distanz: Händler → Kunde (km)",
printColDeliveryFee: "Lieferkosten (€)",
printFooterTotalOrders: "Anzahl Bestellungen",
printFooterTotalFees: "Summe Lieferkosten (€)",
printNoOrders: "Es gibt keine vergangenen Bestellungen zum Drucken.",
printNoOrdersForDriver: "Es gibt keine vergangenen Bestellungen für diesen Fahrer zum Drucken.",

  },
  tr: {
    pageTitle: "Teslimat Sistemi — İşletme Arayüzü",
    mainHeader: "Teslimat Sistemi — İşletme Arayüzü",
    languageLabel: "Dil:",
    tabRegister: "Kayıt ol",
    tabLogin: "Giriş yap",
    registerTitle: "İşletme kaydı",
    storeNamePlaceholder: "İşletme adı",
    storeAddressPlaceholder: "İşletme adresi",
    storeCityPlaceholder: "Şehir",
    storePhonePlaceholder: "İşletme telefonu",
    contactNamePlaceholder: "Yetkili kişi adı",
    contactPhonePlaceholder: "Yetkili telefonu",
    contactEmailPlaceholder: "Yetkili e-posta",
    merchantPasswordPlaceholder: "Şifre (en az 6 karakter)",
    registerSubmit: "İşletmeyi kaydet",
    loginTitle: "Giriş (işletme)",
    loginEmailPlaceholder: "E-posta",
    loginPasswordPlaceholder: "Şifre",
    loginSubmit: "Giriş yap",
    topbarOnline: "Çevrimiçi",
    topbarOffline: "Çevrimdışı",
    topbarTotalDelivery: "Toplam teslimat",
    onlineDriversLabel: "Müsait sürücüler",
    statsActiveCalls: "Aktif çağrılar",
    statsPastCalls: "Geçmiş çağrılar",
    statsTotalDelivery: "Toplam teslimat",
    activeOrdersTitle: "Aktif siparişler",
    completedOrdersTitle: "Geçmiş siparişler",
    filterAllDrivers: "Tümü",
    sortDateDesc: "En yeni önce",
    sortDateAsc: "En eski önce",
    sortDriverAsc: "Sürücü A–Z",
    sortDriverDesc: "Sürücü Z–A",
    exportCsv: "CSV dışa aktar",
    print: "Yazdır",
    logout: "Çıkış yap",
        callStatusLabel: "Çağrı durumu",
		cancelActiveOrderConfirm:
      "Seçtiğiniz sürücü şu anda size doğru geliyor.\n\nBu siparişi gerçekten iptal etmek istiyor musunuz?\nİptal ederseniz, sürücünün şimdiye kadar kat ettiği mesafe sürücünün fiyatlandırmasına göre ücretlendirilir.",
    toastNoMerchant: "Çağrı gönderilemiyor: geçerli işletme tanımlı değil.",
    toastOffline: "Çevrimdışıyken çağrı gönderemezsiniz. Lütfen önce çevrimiçi moda geçin.",
    toastDriverBusy: "Sürücü şu anda meşgul, çağrı gönderilemez.",
    toastCallSentPrefix: "Sürücüye çağrı gönderildi",
    toastErrorSendCallPrefix: "Çağrı gönderilirken hata oluştu:",
    toastDriverHeadingMerchantWithName: "Sürücü {{name}} size doğru yolda",
    toastDriverHeadingMerchantNoName: "Sürücü size doğru yolda",
    toastDriverHeadingCustomerWithName: "Sürücü {{name}} müşteriye doğru yolda",
    toastDriverHeadingCustomerNoName: "Sürücü müşteriye doğru yolda",
// === CSV / Print ===
    csvHeaderId: "ID",
    csvHeaderDriverId: "Sürücü ID",
    csvHeaderDriverName: "Sürücü adı",
    csvHeaderStatus: "Durum",
    csvHeaderRequestTime: "Çağrı zamanı",
    csvHeaderResponseTime: "Yanıt zamanı",
    csvHeaderMerchantName: "İşletme adı",
    csvHeaderMerchantCity: "İşletme şehri",

    alertNoExportForDriver: "Bu sürücü için dışa aktarılacak geçmiş sipariş yok.",
    alertNoExportAll: "Dışa aktarılacak sipariş yok.",
    alertNoPrintForDriver: "Bu sürücü için yazdırılacak geçmiş sipariş yok.",
    alertNoPrintAll: "Yazdırılacak geçmiş sipariş yok.",

    printCallsTitle: "Çağrıları yazdır",
    printCallsHeadingAll: "Geçmiş çağrılar",
    printCallsHeadingForDriver: "Geçmiş çağrılar — {{driverName}}",
    printMerchantLabel: "İşletme",

    printSingleOrderTitlePrefix: "Sipariş",
    printSingleOrderHeadingPrefix: "Sipariş",
    printSingleOrderDriverLabel: "Sürücü",
    printSingleOrderDriverPhoneLabel: "Sürücü telefonu",
    printSingleOrderCustomerLabel: "Müşteri",
    printSingleOrderAddressLabel: "Adres",
    printSingleOrderCostLabel: "Ücret",
	    // === Order details modal ===
    orderDetailsModalTitle: "Sipariş detayları",
    orderDetailsHeadingPrefix: "Sipariş / Çağrı",
    orderDetailsStatusLabel: "Durum",
    orderDetailsDateLabel: "Tarih",
    orderDetailsDriverLabel: "Sürücü",
    orderDetailsDriverPhoneLabel: "Sürücü telefonu",
    orderDetailsCityLabel: "Şehir",
    orderDetailsCustomerNameLabel: "Müşteri adı",
    orderDetailsAddressLabel: "Adres",
    orderDetailsTotalDistanceLabel: "Toplam gidilen mesafe",
    orderDetailsSegmentDistancesLabel: "Sürücü → işletme: {{d1}} / İşletme → teslimat noktası: {{d2}}",
    orderDetailsDeliveryCostLabel: "Teslimat ücreti",
    orderDetailsNotesLabel: "Notlar",
    orderDetailsPrintBtn: "Yazdır",
    orderDetailsCancelBtn: "İptal et",
    orderDetailsCloseBtn: "Kapat",

    // Alerts / confirm
    confirmCancelOrder: "Bu siparişi gerçekten iptal etmek istiyor musunuz?",
    alertMerchantNotSet: "İşletme tanımlı değil.",
    alertOrderNotFound: "Sipariş bulunamadı.",
    alertCancelOrderErrorPrefix: "Sipariş iptal edilirken hata oluştu: ",
printReportTitle: "Teslimat raporu",
printMerchantLabel: "İşletme:",
printDriverLabel: "Sürücü:",
printDateLabel: "Tarih:",
printDeliveryCostSummaryLabel: "Tanımlı teslimat ücreti:",
printPricingMultiDrivers: "Birden fazla sürücü — lütfen her sürücünün tarifesine ayrı bakın.",
printPricingMissing: "Bu sürücü için sistemde net bir tarife yok.",
printNoCompletedGlobal: "Yazdırılacak önceki sipariş yok.",
printNoCompletedForDriver: "Bu sürücü için yazdırılacak önceki sipariş yok.",
printTableMerchant: "İşletme adı",
printTableDriver: "Sürücü adı",
printTableId: "Sipariş ID",
printTableStatus: "Durum",
printTableCreatedAt: "Oluşturulma tarihi",
printTableCustomerAddress: "Müşteri adresi",
printTableDistDriverMerchant: "Sürücü → işletme mesafesi (km)",
printTableDistMerchantCustomer: "İşletme → müşteri mesafesi (km)",
printTableFee: "Teslimat ücreti (€)",
// داخل I18N.tr = { ... }
printTitleCalls: "Teslimat çağrıları raporu",
printMerchantLabel: "İşletme",
printDriverLabel: "Sürücü",
printDateGenerated: "Yazdırma tarihi (UTC)",
printDriverPricingTitle: "Sürücünün teslimat ücreti",
printBaseFeeLabel: "Temel ücret",
printPerKmToCustomerLabel: "km başına (işletme → müşteri)",
printPerKmToMerchantLabel: "km başına (sürücü → işletme)",
printFreeKmLabel: "İlk {KM} km ücretsiz",
printColMerchant: "İşletme adı",
printColDriver: "Sürücü adı",
printColOrderId: "Sipariş ID",
printColStatus: "Durum",
printColCreatedAt: "Oluşturma zamanı (UTC)",
printColCustomerAddress: "Müşteri adresi",
printColDistDriverToMerchant: "Mesafe: sürücü → işletme (km)",
printColDistMerchantToCustomer: "Mesafe: işletme → müşteri (km)",
printColDeliveryFee: "Teslimat ücreti (€)",
printFooterTotalOrders: "Toplam sipariş",
printFooterTotalFees: "Toplam teslimat ücreti (€)",
printNoOrders: "Yazdırılacak geçmiş sipariş yok.",
printNoOrdersForDriver: "Bu sürücü için yazdırılacak geçmiş sipariş yok.",

  }
};

let currentLang = "ar";
function t(key) {
  const dict = I18N[currentLang] || I18N.ar;
  if (dict && Object.prototype.hasOwnProperty.call(dict, key)) {
    return dict[key];
  }
  if (I18N.ar && Object.prototype.hasOwnProperty.call(I18N.ar, key)) {
    return I18N.ar[key];
  }
  return key;
}
// === ترجمة بالون الـ ETA حسب currentLang ===
function getEtaArrivedText() {
  const lang = currentLang || "ar";
  switch (lang) {
    case "en":
      return "Arriving now";
    case "de":
      return "Kommt gleich an";
    case "tr":
      return "Neredeyse geldi";
    default: // ar
      return "وصل تقريباً";
  }
}

function getEtaLabelText(remainingSeconds) {
  const lang = currentLang || "ar";
  const mins = Math.floor(remainingSeconds / 60);
  const secs = remainingSeconds % 60;
  const mmss = `${mins}:${String(secs).padStart(2, "0")}`;

  switch (lang) {
    case "en":
      return `🕒 ETA in ${mmss} min`;
    case "de":
      return `🕒 Voraussichtliche Ankunft in ${mmss} Min`;
    case "tr":
      return `🕒 Tahmini varış ${mmss} dk içinde`;
    default: // ar
      return `🕒 متوقع خلال ${mmss} دقيقة`;
  }
}

function getNearCountdownText(secondsLeft) {
  const lang = currentLang || "ar";
  const mins = Math.floor(secondsLeft / 60);
  const secs = secondsLeft % 60;
  const mmss = `${mins}:${String(secs).padStart(2, "0")}`;

  switch (lang) {
    case "en":
      return `⏳ Arriving in ${mmss}`;
    case "de":
      return `⏳ Ankunft in ${mmss}`;
    case "tr":
      return `⏳ Yaklaşık ${mmss} içinde varır`;
    default: // ar
      return `⏳ يصل خلال ${mmss}`;
  }
}

/* ========== إعداد Firebase ========== */
const firebaseConfig = {
  apiKey: "AIzaSyBhiKPw7M3NMCOhzoBJJyI9enOa6qZQnHc",
  authDomain: "delivera-7pq7jc.firebaseapp.com",
  projectId: "delivera-7pq7jc",
  storageBucket: "delivera-7pq7jc.appspot.com",
  messagingSenderId: "186649231022",
  appId: "1:186649231022:web:18e76b00018fbb5d68773f"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
// إلغاء الطلب من لوحة التاجر + عكسه فوراً في وثيقة السائق
async function cancelCallAndNotifyDriver(callRef) {
  const snap = await callRef.get();
  if (!snap.exists) return;

  const data = snap.data() || {};
  const driverId = data.driverId;
  const callId   = callRef.id;

  const patch = {
    status: "cancelled",
    cancelledBy: "merchant",
    cancelledAt: firebase.firestore.FieldValue.serverTimestamp()
  };

  const batch = db.batch();

  // 1) تحديث وثيقة التاجر
  batch.update(callRef, patch);

  // 2) تحديث / إنشاء وثيقة السائق بنفس callId
  if (driverId) {
    const driverCallRef = db
      .collection("drivers")
      .doc(driverId)
      .collection("calls")
      .doc(callId);

    // نستخدم set مع merge حتى لو الوثيقة غير موجودة يتم إنشاؤها
    batch.set(
      driverCallRef,
      patch,
      { merge: true }
    );
  }

  await batch.commit();
}

// الرسم الأساسي
const BASE_DELIVERY_FEE = 3.5; // EUR
// مسار أيقونة ماركر التاجر (غيّره لما يناسبك)
const MERCHANT_MARKER_ICON_PATH = "markt 1.png";
// مسار أيقونة ماركر العميل (غيّره لما يناسبك)
const CUSTOMER_MARKER_ICON_PATH = "kunde.png";
// مسارات أيقونات مركبات السائقين (حدّث أسماء الملفات حسب صورك الفعلية)
const DRIVER_VEHICLE_ICONS = {
  car: "car.png",
  motorcycle: "motorcycle.png",
  bicycle: "bicycle.png",
  default: "driver-default.png"
};

/* ========== عناصر DOM ========== */
const registerTab = document.getElementById("registerTab");
const loginTab = document.getElementById("loginTab");
const registerSection = document.getElementById("registerSection");
const loginSection = document.getElementById("loginSection");

const merchantForm = document.getElementById("merchantForm");
const loginForm = document.getElementById("loginForm");

const merchantDashboard = document.getElementById("merchantDashboard");
const merchantNameEl = document.getElementById("merchantName");
const merchantCityEl = document.getElementById("merchantCity");
const logoutBtn = document.getElementById("logoutBtn");

const mapContainer = document.getElementById("map");
const activeOrdersEl = document.getElementById("activeOrders");
const completedOrdersEl = document.getElementById("completedOrders");
const countActiveEl = document.getElementById("countActive");
const countCompletedEl = document.getElementById("countCompleted");

const filterDriver = document.getElementById("filterDriver");
const sortActive = document.getElementById("sortActive");
const sortCompleted = document.getElementById("sortCompleted");
const exportCsvBtn = document.getElementById("exportCsv");
const printBtn = document.getElementById("printBtn");

const modalBackdrop = document.getElementById("modalBackdrop");
const modalContent = document.getElementById("modalContent");

const orderModalEl = document.getElementById("orderModal");
const betaFooterEl = document.getElementById("betaFooter");
const betaLegalBtn = document.getElementById("betaLegalBtn");
const betaLegalModal = document.getElementById("betaLegalModal");
const betaLegalBackdrop = document.getElementById("betaLegalBackdrop");
const betaLegalCloseBtn = document.getElementById("betaLegalClose");

/* ========== Toast helper ========== */
const toastContainer = document.getElementById("toastContainer");

function showToast(message, type = "success") {
  if (!toastContainer) return;

  const toast = document.createElement("div");
  toast.className = "toast " + (type === "error" ? "toast-error" : "toast-success");

  const iconSpan = document.createElement("span");
  iconSpan.className = "toast-icon";
  iconSpan.textContent = type === "error" ? "⚠️" : "✅";

  const textSpan = document.createElement("span");
  textSpan.textContent = message;

  toast.appendChild(iconSpan);
  toast.appendChild(textSpan);
  toastContainer.appendChild(toast);

  const removeToast = () => {
    if (toast && toast.parentNode) {
      toast.parentNode.removeChild(toast);
    }
  };

  // بعد 2.5 ثانية نبدأ الإخفاء التدريجي
  setTimeout(() => {
    toast.classList.add("fade-out");

    // إزالة بعد انتهاء الـ transition
    toast.addEventListener("transitionend", removeToast, { once: true });

    // فالباك إضافي لو لأي سبب transitionend ما اشتغل
    setTimeout(removeToast, 800);
  }, 2500);
}
/* ========== مودال النص القانوني للنسخة التجريبية ========== */
function openBetaLegalModal() {
  if (!betaLegalModal || !betaLegalBackdrop) return;
  betaLegalModal.classList.remove("hidden");
  betaLegalBackdrop.style.display = "flex";
}

function closeBetaLegalModal() {
  if (!betaLegalModal || !betaLegalBackdrop) return;
  betaLegalBackdrop.style.display = "none";
  betaLegalModal.classList.add("hidden");
}

if (betaLegalBtn) {
  betaLegalBtn.addEventListener("click", openBetaLegalModal);
}
if (betaLegalCloseBtn) {
  betaLegalCloseBtn.addEventListener("click", closeBetaLegalModal);
}
if (betaLegalBackdrop) {
  betaLegalBackdrop.addEventListener("click", (e) => {
    if (e.target === betaLegalBackdrop) {
      closeBetaLegalModal();
    }
  });
}

/* عناصر الواجهة الجديدة (الشريط العلوي + القائمة الجانبية) */
const merchantMenuBtn = document.getElementById("merchantMenuBtn");
const merchantOnlineToggle = document.getElementById("merchantOnlineToggle");
const merchantEarningsTopEl = document.getElementById("merchantEarnings");
const onlineDriversBadge = document.getElementById("onlineDriversBadge");
const openDriversPickerBtn = document.getElementById("openDriversPicker");
const driversPickerPanel = document.getElementById("driversPickerPanel");
const driversPickerList = document.getElementById("driversPickerList");
const driversPickerCloseBtn = document.getElementById("driversPickerClose");

const merchantSidePanel = document.getElementById("merchantSidePanel");
const merchantSidePanelBackdrop = document.getElementById("merchantSidePanelBackdrop");
const closeSidePanelBtn = document.getElementById("closeSidePanel");
// صوت أونلاين للتاجر + حالة الأونلاين
const merchantOnlineSoundEl = document.getElementById("merchantOnlineSound");
const merchantCallSoundEl   = document.getElementById("merchantCallSound");
const callAcceptedSoundEl     = document.getElementById("callAcceptedSound");
const driverOnWaySoundEl      = document.getElementById("driverOnWaySound");
const driverNearSoundEl       = document.getElementById("driverNearSound");
// صوت تسليم الطلب (لرحلة العميل)
const customerDeliveredSoundEl = document.getElementById("customerDeliveredSound");
let merchantApprovalStatus = "pending";
let merchantUnsubscribe = null;
let merchantCurrentOnline = false;
let playMerchantOnlineSoundNext = false;
let hasSeenApprovedBanner = false;
/* ========== متغيّرات الخريطة والسائقين ========== */
let map;
let driverMarkers = {};
let merchantMarker = null;
let ordersListenerUnsub = null;
let driversListenerUnsub = null;
let merchantCallsListenerUnsub = null;
let currentMerchantId = null;
let cachedDrivers = {}; // id -> data
let lastCallsCache = [];
function hasActiveCallForDriver(driverId) {
  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  return lastCallsCache.some((c) => {
    if (c.driverId !== driverId) return false;
    const st = (c.status || "pending").toLowerCase();
    return !completedStatuses.includes(st);
  });
}

let merchantLocationLat = null;
let merchantLocationLng = null;
let directionsService = null;

let currentTrackedCallId = null;
let currentTrackedDriverId = null;

const driverHaloState = {};
const multiTrackingByDriver = {};
const multiCustomerMarkers = {};

let trackedDriverId = null;
let trackedRoutePolyline = null;
let trackedRouteFullPath = [];
let trackedEtaInfoWindow = null;
let trackedEtaTimerId = null;
let trackedEtaSeconds = null;
let trackedEtaUpdatedAt = null;
let trackedNearAlertPlayed = false;
let lastDriverRouteRequestAt = 0;
let nearCountdownTimerId = null;
let nearCountdownSeconds = null;

let trackedLastDistanceMeters = null;
let driverRouteAvgSpeedMps = null;

const MAX_DRIVER_TO_MERCHANT_DIRECTIONS = 2;
let driverToMerchantDirectionsCountByCall = {};

let currentDestinationLat = null;
let currentDestinationLng = null;
let currentDestinationType = null;
let currentDestinationAddress = null;

let customerMarker = null;
let currentCustomerName = "";

let directionsRequestedForCurrentLeg = false;
let mapFittedForCurrentLeg = false;

let lastCallsById = {};

/* ========== فتح/إغلاق القائمة الجانبية في واجهة التاجر ========== */
if (merchantMenuBtn && merchantSidePanel && merchantSidePanelBackdrop) {
  merchantMenuBtn.addEventListener("click", () => {
    merchantSidePanel.classList.add("open");
    merchantSidePanelBackdrop.classList.add("visible");
  });
}

if (closeSidePanelBtn) {
  closeSidePanelBtn.addEventListener("click", () => {
    merchantSidePanel.classList.remove("open");
    merchantSidePanelBackdrop.classList.remove("visible");
  });
}

if (merchantSidePanelBackdrop) {
  merchantSidePanelBackdrop.addEventListener("click", () => {
    merchantSidePanel.classList.remove("open");
    merchantSidePanelBackdrop.classList.remove("visible");
  });
}

/* ========== زر أونلاين / أوفلاين الخاص بالتاجر (مرتبط بـ Firestore + صوت) ========== */
function updateMerchantOnlineBtn() {
  if (!merchantOnlineToggle) return;

  if (merchantCurrentOnline) {
    merchantOnlineToggle.textContent = t("topbarOnline");
    merchantOnlineToggle.dataset.state = "online";
  } else {
    merchantOnlineToggle.textContent = t("topbarOffline");
    merchantOnlineToggle.dataset.state = "offline";
  }

  merchantOnlineToggle.classList.remove("blink");

  if (merchantCurrentOnline && playMerchantOnlineSoundNext && merchantOnlineSoundEl) {
    try {
      merchantOnlineSoundEl.currentTime = 0;
      merchantOnlineSoundEl.play();
    } catch (e) {
      console.warn("تعذر تشغيل صوت أونلاين التاجر:", e);
    }
  }

  playMerchantOnlineSoundNext = false;

  if (merchantCurrentOnline) {
    ensureMerchantMarkerOnMap();
  } else {
    hideMerchantMarker();
  }
}

if (merchantOnlineToggle) {
  merchantOnlineToggle.addEventListener("click", async () => {
    if (!currentMerchantId) {
      alert("لم يتم تحديد التاجر الحالي.");
      return;
    }

    // 🔒 لا نسمح أونلاين إذا الحساب غير معتمد
    if (merchantApprovalStatus !== "approved") {
      let msg;
      switch (currentLang) {
        case "en":
          msg = "Your account is still under review by the admin.";
          break;
        case "de":
          msg = "Dein Konto wird noch vom Admin geprüft.";
          break;
        case "tr":
          msg = "Hesabın hâlâ yönetici tarafından inceleniyor.";
          break;
        default:
          msg = "حسابك ما زال قيد المراجعة من الأدمن.";
      }
      showToast(msg, "error");
      return;
    }

    const goingOnline = !merchantCurrentOnline;
    merchantCurrentOnline = goingOnline;

    if (goingOnline) {
      // 🎧 هنا نفعّل الصوت (يتشغّل داخل updateMerchantOnlineBtn)
      playMerchantOnlineSoundNext = true;
      merchantOnlineToggle.classList.add("blink");
    }

    try {
      const updateData = goingOnline
        ? {
            online: true,
            lastOnline: firebase.firestore.FieldValue.serverTimestamp()
          }
        : {
            online: false
          };

      // ✅ أول مرة يضغط أونلاين بعد الاعتماد → نخفي البانر ولا نرجّعه أبداً
      if (goingOnline && !hasSeenApprovedBanner) {
        hideApprovedBanner();
        hasSeenApprovedBanner = true;
        updateData.approvedBannerDismissed = true;
      }

      await db.collection("merchants").doc(currentMerchantId).update(updateData);

      updateMerchantOnlineBtn();
    } catch (err) {
      // رجّع الحالة القديمة لو صار خطأ
      merchantCurrentOnline = !goingOnline;
      playMerchantOnlineSoundNext = false;
      merchantOnlineToggle.classList.remove("blink");
      alert("حدث خطأ أثناء تحديث حالة التاجر: " + err.message);
    }
  });

  // تهيئة الزر حسب حالة المتغيرات الحالية
  updateMerchantOnlineBtn();
}

function getApprovedBannerText() {
  switch (currentLang) {
    case "en":
      return "Your account has been approved. You can start delivering orders with available drivers.";
    case "de":
      return "Dein Konto wurde freigeschaltet. Du kannst jetzt mit verfügbaren Fahrern Bestellungen ausliefern.";
    case "tr":
      return "Hesabın onaylandı. Artık uygun sürücülerle sipariş teslimatına başlayabilirsin.";
    default:
      return "تم اعتماد حسابك، يمكنك بدء توصيل طلباتك مع السائقين المتاحين.";
  }
}

function showApprovedBanner() {
  const banner = document.getElementById("merchantApprovedBanner");
  const textEl = document.getElementById("merchantApprovedBannerText");
  if (!banner || !textEl) return;
  textEl.textContent = getApprovedBannerText();
  banner.classList.remove("hidden");
}

function hideApprovedBanner() {
  const banner = document.getElementById("merchantApprovedBanner");
  if (!banner) return;
  banner.classList.add("hidden");
}

function maybeShowApprovedBanner() {
  if (
    merchantApprovalStatus === "approved" &&
    !merchantCurrentOnline &&
    !hasSeenApprovedBanner
  ) {
    showApprovedBanner();
  }
}

function subscribeToMerchantDoc(merchantId) {
  if (!merchantId) return;

  // إلغاء أي listener قديم
  if (merchantUnsubscribe) {
    merchantUnsubscribe();
    merchantUnsubscribe = null;
  }

  merchantUnsubscribe = db.collection("merchants").doc(merchantId).onSnapshot(
    (doc) => {
      if (!doc.exists) return;
      const data = doc.data();

      merchantApprovalStatus = data.approvalStatus || "pending";
      hasSeenApprovedBanner = !!data.approvedBannerDismissed;

      const firestoreOnline = !!data.online;
      merchantCurrentOnline =
        merchantApprovalStatus === "approved" && firestoreOnline;

      updateMerchantOnlineBtn();

      if (!hasSeenApprovedBanner) {
        maybeShowApprovedBanner(); // يُظهر الرسالة لو تم الاعتماد ولم يذهب أونلاين بعد
      } else {
        hideApprovedBanner(); // لو مخفية نهائياً لا نعرضها
      }
    },
    (error) => {
      console.error("Merchant onSnapshot error:", error);
    }
  );
}

/* ========== تبويبات التسجيل/الدخول ========== */
registerTab.addEventListener("click", () => {
  registerTab.classList.add("active");
  loginTab.classList.remove("active");
  registerSection.classList.remove("hidden");
  loginSection.classList.add("hidden");
});
loginTab.addEventListener("click", () => {
  loginTab.classList.add("active");
  registerTab.classList.remove("active");
  loginSection.classList.remove("hidden");
  registerSection.classList.add("hidden");
});

/* ========== تسجيل التاجر ========== */
merchantForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const storeName = document.getElementById("storeName").value.trim();
  const storeAddress = document.getElementById("storeAddress").value.trim();
  const storeCity = document.getElementById("storeCity").value.trim();
  const storePhone = document.getElementById("storePhone").value.trim();
  const contactName = document.getElementById("contactName").value.trim();
  const contactPhone = document.getElementById("contactPhone").value.trim();
  const contactEmail = document.getElementById("contactEmail").value.trim();
  const password = document.getElementById("merchantPassword").value;
  if (password.length < 6) return alert("كلمة السر يجب أن تكون 6 أحرف على الأقل.");
  try {
    const userCredential = await auth.createUserWithEmailAndPassword(
      contactEmail,
      password
    );
    const uid = userCredential.user.uid;
    await db.collection("merchants").doc(uid).set({
  storeName,
  storeAddress,
  storeCity,
  storePhone,
  contactName,
  contactPhone,
  contactEmail,
  role: "merchant",
  approvalStatus: "pending",        // ⬅ جديد
  online: false,                    // ⬅ جديد (يبدأ أوفلاين)
  createdAt: firebase.firestore.FieldValue.serverTimestamp()
});

    alert("تم تسجيل التاجر بنجاح!");
    merchantForm.reset();
  } catch (err) {
    alert("خطأ: " + err.message);
  }
});

/* ========== تسجيل الدخول (تاجر فقط) ========== */
loginForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const email = document.getElementById("loginEmail").value.trim();
  const password = document.getElementById("loginPassword").value;

  try {
    const userCredential = await auth.signInWithEmailAndPassword(
      email,
      password
    );
    const uid = userCredential.user.uid;

    const merchantDoc = await db.collection("merchants").doc(uid).get();

            if (merchantDoc.exists) {
      const merchantData = merchantDoc.data();

      currentMerchantId = uid;
      hasSeenApprovedBanner = !!merchantData.approvedBannerDismissed; // من Firestore لو كان مخزّن

      merchantNameEl.textContent =
        merchantData.storeName || merchantData.contactName || "تاجر";

      merchantCityEl.textContent =
        merchantData.storeAddress || merchantData.storeCity || "";

      // حالة الاعتماد من Firestore (افتراضي pending لو الحقل غير موجود)
      merchantApprovalStatus = merchantData.approvalStatus || "pending";

      // لا نسمح أونلاين إلا إذا الحساب approved
      merchantCurrentOnline =
        merchantApprovalStatus === "approved" && !!merchantData.online;

      updateMerchantOnlineBtn();

      // إظهار لوحة التاجر
      registerSection.classList.add("hidden");
      loginSection.classList.add("hidden");
      merchantDashboard.classList.remove("hidden");
      document.getElementById("mainHeader").classList.add("hidden");
      document.getElementById("authTabs").classList.add("hidden");
      const langSwitcher = document.getElementById("langSwitcher");
      if (langSwitcher) langSwitcher.classList.add("hidden");
      if (betaFooterEl) betaFooterEl.classList.add("hidden");

      initMapAndData(uid);
      subscribeToMerchantDoc(uid);
      document.body.classList.add("merchant-mode");

      // لو الحساب approved ولم يدخل أونلاين من قبل ولم تُخف الرسالة
      if (
        merchantApprovalStatus === "approved" &&
        !merchantCurrentOnline &&
        !hasSeenApprovedBanner
      ) {
        showApprovedBanner();
      }

      // لو الحساب غير معتمد → توست تنبيهي كالسابق
      if (merchantApprovalStatus !== "approved") {
        let msg;
        switch (currentLang) {
          case "en":
            msg =
              "Your account is under review by the admin. You cannot go online yet.";
            break;
          case "de":
            msg =
              "Dein Konto wird vom Admin geprüft. Du kannst noch nicht online gehen.";
            break;
          case "tr":
            msg =
              "Hesabın yönetici tarafından inceleniyor. Henüz çevrimiçi olamazsın.";
            break;
          default:
            msg =
              "حسابك قيد المراجعة من الأدمن، ولا يمكنك تفعيل أونلاين حتى يتم اعتماده.";
        }
        showToast(msg, "error");
      }
    } else {
      await auth.signOut();
      alert("هذه الواجهة مخصصة للتجار فقط. يرجى استخدام رابط واجهة السائق إن كنت سائقاً.");
    }

    loginForm.reset();
  } catch (err) {
    alert("خطأ: " + err.message);
  }
});

/* ========== تسجيل خروج التاجر ========== */
logoutBtn.addEventListener("click", async () => {
  // إلغاء listener لو موجود
  if (merchantUnsubscribe) {
    merchantUnsubscribe();
    merchantUnsubscribe = null;
  }
  currentMerchantId = null;

  await auth.signOut();

  // رجّع الحالة المحلية لقيم آمنة
  merchantApprovalStatus = "pending";
  merchantCurrentOnline = false;
  updateMerchantOnlineBtn();

  merchantDashboard.classList.add("hidden");
  registerSection.classList.remove("hidden");
  loginSection.classList.remove("hidden");
  document.getElementById("mainHeader").classList.remove("hidden");
  document.getElementById("authTabs").classList.remove("hidden");
  const langSwitcher = document.getElementById("langSwitcher");
  if (langSwitcher) langSwitcher.classList.remove("hidden");
  if (betaFooterEl) betaFooterEl.classList.remove("hidden");

  document.body.classList.remove("merchant-mode");
});

function createCircleIcon(color, scale) {
  return {
    path: google.maps.SymbolPath.CIRCLE,
    fillColor: color,
    fillOpacity: 0.9,
    scale: scale,
    strokeColor: "#ffffff",
    strokeWeight: 3
  };
}
function getDriverVehicleIcon(driverData) {
  if (typeof google === "undefined" || !google.maps) return null;

  const rawType = (driverData.vehicleType || "").toLowerCase();
  let key;
  if (rawType === "car") {
    key = "car";
  } else if (rawType === "motorcycle" || rawType === "motorbike") {
    key = "motorcycle";
  } else if (rawType === "bicycle" || rawType === "bike") {
    key = "bicycle";
  } else {
    key = "default";
  }

  const url = DRIVER_VEHICLE_ICONS[key] || DRIVER_VEHICLE_ICONS.default;

  return {
    url,
    scaledSize: new google.maps.Size(40, 40),
    origin: new google.maps.Point(0, 0),
    anchor: new google.maps.Point(20, 20)
  };
}

// URL فقط لاستخدامه داخل فقاعة الـ ETA
function getDriverVehicleIconUrlForId(driverId) {
  const data = cachedDrivers[driverId] || {};
  const rawType = (data.vehicleType || "").toLowerCase();
  let key;
  if (rawType === "car") {
    key = "car";
  } else if (rawType === "motorcycle" || rawType === "motorbike") {
    key = "motorcycle";
  } else if (rawType === "bicycle" || rawType === "bike") {
    key = "bicycle";
  } else {
    key = "default";
  }
  return DRIVER_VEHICLE_ICONS[key] || DRIVER_VEHICLE_ICONS.default;
}

function getMerchantMarkerIcon() {
  if (typeof google === "undefined" || !google.maps) return null;
  return {
    url: MERCHANT_MARKER_ICON_PATH,
    scaledSize: new google.maps.Size(52, 52),
    origin: new google.maps.Point(0, 0),
    anchor: new google.maps.Point(26, 46)
  };
}

function ensureMerchantMarkerOnMap() {
  if (!map) return;
  if (merchantLocationLat == null || merchantLocationLng == null) return;

  const pos = { lat: merchantLocationLat, lng: merchantLocationLng };

  if (!merchantMarker) {
    merchantMarker = new google.maps.Marker({
      position: pos,
      map,
      title: merchantNameEl.textContent || "المطعم",
      icon: getMerchantMarkerIcon()
    });
  } else {
    merchantMarker.setPosition(pos);
    merchantMarker.setMap(map);
  }
}

function hideMerchantMarker() {
  if (merchantMarker) {
    merchantMarker.setMap(null);
  }
}
function getCustomerMarkerIcon() {
  if (typeof google === "undefined" || !google.maps) return null;
  return {
    url: CUSTOMER_MARKER_ICON_PATH,
    scaledSize: new google.maps.Size(46, 46),
    origin: new google.maps.Point(0, 0),
    anchor: new google.maps.Point(23, 40)
  };
}
function mtEnsureCustomerMarker(driverId, lat, lng, label) {
  if (!map || lat == null || lng == null) return;
  const pos = { lat, lng };
  let marker = multiCustomerMarkers[driverId];

  if (!marker) {
    marker = new google.maps.Marker({
      position: pos,
      map,
      title: label || "العميل",
      icon: getCustomerMarkerIcon()
    });
    multiCustomerMarkers[driverId] = marker;
  } else {
    marker.setPosition(pos);
    marker.setMap(map);
  }
}

function mtHideCustomerMarkerForDriver(driverId) {
  const m = multiCustomerMarkers[driverId];
  if (m) {
    m.setMap(null);
    delete multiCustomerMarkers[driverId];
  }
}
function mtStartTrackingToMerchant(driverId, callId) {
  if (!driverMarkers[driverId] || !driverMarkers[driverId].marker) return;

  const tr = multiTrackingByDriver[driverId] || {};
  multiTrackingByDriver[driverId] = tr;

  tr.callId = callId;
  tr.leg = "merchant";
  tr.destinationType = "merchant";
  tr.destinationLat = merchantLocationLat;
  tr.destinationLng = merchantLocationLng;
  tr.destinationAddress = null;
  tr.customerName = "";
  tr.nearAlertPlayed = false;
  tr.directionsRequestedForCurrentLeg = false;
  tr.mapFittedForCurrentLeg = false;
  tr.lastRouteRequestAt = 0;

  if (tr.routePolyline) {
    tr.routePolyline.setMap(null);
    tr.routePolyline = null;
  }
  tr.routeFullPath = [];

  if (tr.etaInfoWindow) {
    tr.etaInfoWindow.close();
    tr.etaInfoWindow = null;
  }
  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }
  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }
  tr.etaSeconds = null;
  tr.etaUpdatedAt = null;
  tr.nearCountdownSeconds = null;

  mtUpdateRouteAndEta(driverId);
}

function mtStartTrackingToCustomer(driverId, callId, callData) {
  if (!driverMarkers[driverId] || !driverMarkers[driverId].marker) return;

  const tr = multiTrackingByDriver[driverId] || {};
  multiTrackingByDriver[driverId] = tr;

  mtHideCustomerMarkerForDriver(driverId);

  tr.callId = callId;
  tr.leg = "customer";
  tr.destinationType = "customer";
  tr.destinationLat = null;
  tr.destinationLng = null;
  tr.destinationAddress = callData.deliveryAddress || "";
  tr.customerName = (callData.customerName || "").trim();
  tr.nearAlertPlayed = false;
  tr.directionsRequestedForCurrentLeg = false;
  tr.mapFittedForCurrentLeg = false;
  tr.lastRouteRequestAt = 0;

  if (tr.routePolyline) {
    tr.routePolyline.setMap(null);
    tr.routePolyline = null;
  }
  tr.routeFullPath = [];

  if (tr.etaInfoWindow) {
    tr.etaInfoWindow.close();
    tr.etaInfoWindow = null;
  }
  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }
  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }
  tr.etaSeconds = null;
  tr.etaUpdatedAt = null;
  tr.nearCountdownSeconds = null;

  mtUpdateRouteAndEta(driverId);
}

function mtUpdateRouteProgress(driverId, currentLatLng) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || !tr.routePolyline) return;
  if (!tr.routeFullPath || tr.routeFullPath.length === 0) return;
  if (!google.maps || !google.maps.geometry || !google.maps.geometry.spherical)
    return;

  let closestIndex = 0;
  let minDist = Infinity;

  for (let i = 0; i < tr.routeFullPath.length; i++) {
    const p = tr.routeFullPath[i];
    const d = google.maps.geometry.spherical.computeDistanceBetween(
      currentLatLng,
      p
    );
    if (d < minDist) {
      minDist = d;
      closestIndex = i;
    }
  }

  if (minDist > 80) return;

  const remaining = tr.routeFullPath.slice(closestIndex);
  tr.routeFullPath = remaining;
  tr.routePolyline.setPath(remaining);
}

function mtUpdateRouteAndEta(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || !tr.destinationType) return;
  if (!map) return;

  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  const origin = markerState.marker.getPosition();
  if (!origin) return;

  mtUpdateRouteProgress(driverId, origin);

  const isCustomerLeg = tr.destinationType === "customer";

  let distanceMetersGeo = null;
  if (
    tr.destinationLat != null &&
    tr.destinationLng != null &&
    google.maps &&
    google.maps.geometry &&
    google.maps.geometry.spherical
  ) {
    const destLatLng = new google.maps.LatLng(tr.destinationLat, tr.destinationLng);
    distanceMetersGeo =
      google.maps.geometry.spherical.computeDistanceBetween(origin, destLatLng);
  }

  if (!tr.nearAlertPlayed && distanceMetersGeo != null && distanceMetersGeo <= 300) {
    tr.nearAlertPlayed = true;

    if (tr.destinationType === "merchant") {
      if (driverNearSoundEl) {
        try {
          driverNearSoundEl.currentTime = 0;
          driverNearSoundEl.play();
        } catch (e) {
          console.warn("تعذر تشغيل صوت قرب الوصول:", e);
        }
      }

      if (tr.routePolyline) {
        tr.routePolyline.setMap(null);
        tr.routePolyline = null;
      }
      
      if (tr.etaTimerId) {
        clearInterval(tr.etaTimerId);
        tr.etaTimerId = null;
      }
      tr.etaSeconds = null;
      tr.etaUpdatedAt = null;

      mtStartNearArrivalCountdown(driverId);
      return;
    } else if (tr.destinationType === "customer") {
      if (tr.etaTimerId) {
        clearInterval(tr.etaTimerId);
        tr.etaTimerId = null;
      }
      tr.etaSeconds = null;
      tr.etaUpdatedAt = null;

      mtStartNearArrivalCountdown(driverId);
      return;
    }
  }

  if (tr.nearAlertPlayed) return;

  if (!directionsService) {
    directionsService = new google.maps.DirectionsService();
  }

  const now = Date.now();
  if (!isCustomerLeg) {
    if (tr.lastRouteRequestAt && now - tr.lastRouteRequestAt < 10000) {
      return;
    }
    tr.lastRouteRequestAt = now;
  } else {
    if (tr.directionsRequestedForCurrentLeg) {
      return;
    }
    tr.directionsRequestedForCurrentLeg = true;
  }

  let destination;
  if (tr.destinationLat != null && tr.destinationLng != null) {
    destination = { lat: tr.destinationLat, lng: tr.destinationLng };
  } else if (tr.destinationAddress) {
    destination = tr.destinationAddress;
  } else if (
    tr.destinationType === "merchant" &&
    merchantLocationLat != null &&
    merchantLocationLng != null
  ) {
    destination = {
      lat: merchantLocationLat,
      lng: merchantLocationLng
    };
  } else {
    return;
  }

  directionsService.route(
    {
      origin,
      destination,
      travelMode: google.maps.TravelMode.DRIVING
    },
    (result, status) => {
      if (
        status !== "OK" ||
        !result.routes ||
        !result.routes[0] ||
        !result.routes[0].legs ||
        !result.routes[0].legs[0]
      ) {
        console.warn("تعذر حساب مسار السائق:", status, result);
        return;
      }

      const leg = result.routes[0].legs[0];
      const durationSeconds = leg.duration ? leg.duration.value : null;

      if (tr.destinationType === "customer" && leg.end_location) {
        tr.destinationLat = leg.end_location.lat();
        tr.destinationLng = leg.end_location.lng();
        mtEnsureCustomerMarker(
          driverId,
          tr.destinationLat,
          tr.destinationLng,
          tr.customerName || "العميل"
        );
      } else if (
        tr.destinationType === "merchant" &&
        leg.end_location &&
        (tr.destinationLat == null || tr.destinationLng == null)
      ) {
        tr.destinationLat = leg.end_location.lat();
        tr.destinationLng = leg.end_location.lng();
      }

      if (!tr.mapFittedForCurrentLeg && map && origin) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend(origin);

        if (tr.destinationLat != null && tr.destinationLng != null) {
          bounds.extend(
            new google.maps.LatLng(tr.destinationLat, tr.destinationLng)
          );
        } else if (leg.end_location) {
          bounds.extend(leg.end_location);
        }

        map.fitBounds(bounds);
        tr.mapFittedForCurrentLeg = true;
      }

      const overviewPath = result.routes[0].overview_path;
      if (overviewPath && overviewPath.length) {
        tr.routeFullPath = overviewPath.slice();

        if (!tr.routePolyline) {
          tr.routePolyline = new google.maps.Polyline({
            map,
            path: tr.routeFullPath,
            strokeColor: "#22c55e",
            strokeOpacity: 0.8,
            strokeWeight: 4
          });
        } else {
          tr.routePolyline.setPath(tr.routeFullPath);
        }

        mtUpdateRouteProgress(driverId, origin);
      }

      if (durationSeconds != null) {
        tr.etaSeconds = durationSeconds;
        tr.etaUpdatedAt = Date.now();

        if (!tr.etaInfoWindow) {
          tr.etaInfoWindow = new google.maps.InfoWindow({
            pixelOffset: new google.maps.Size(0, -40),
            disableAutoPan: true
          });
        } else {
          tr.etaInfoWindow.setOptions({ disableAutoPan: true });
        }

        mtUpdateEtaBubble(driverId);

        if (!tr.etaTimerId) {
          tr.etaTimerId = setInterval(
            () => mtUpdateEtaBubble(driverId),
            1000
          );
        }
      }
    }
  );
}

function mtGetEtaSeconds(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || tr.etaSeconds == null || tr.etaUpdatedAt == null) return null;
  const elapsed = (Date.now() - tr.etaUpdatedAt) / 1000;
  return Math.max(0, Math.round(tr.etaSeconds - elapsed));
}

function mtUpdateEtaBubble(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr || !tr.etaInfoWindow) return;

  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  const remaining = mtGetEtaSeconds(driverId);
  if (remaining == null) return;

  if (remaining <= 0) {
    const arrivedText = getEtaArrivedText();
    tr.etaInfoWindow.setContent(`
      <div style="
        background:#0f172a;
        color:#bbf7d0;
        padding:4px 8px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #22c55e;
        white-space:nowrap;
      ">
        ${arrivedText}
      </div>
    `);
    tr.etaInfoWindow.open(map, markerState.marker);
    return;
  }

  const etaText = getEtaLabelText(remaining);

  const html = `
    <div style="
      background:#0f172a;
      color:#f9fafb;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      box-shadow:0 4px 12px rgba(15,23,42,0.6);
      border:1px solid #22c55e;
      white-space:nowrap;
    ">
      ${etaText}
    </div>
  `;
  tr.etaInfoWindow.setContent(html);
  tr.etaInfoWindow.open(map, markerState.marker);
}

function mtStartNearArrivalCountdown(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr) return;

  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }

  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }

  tr.nearCountdownSeconds = 60;

  if (!tr.etaInfoWindow) {
    tr.etaInfoWindow = new google.maps.InfoWindow({
      pixelOffset: new google.maps.Size(0, -40),
      disableAutoPan: true
    });
  } else {
    tr.etaInfoWindow.setOptions({ disableAutoPan: true });
  }

  const render = () => {
    const st = driverMarkers[driverId];
    if (!st || !st.marker || !st.marker.getMap()) {
      if (tr.nearCountdownTimerId) {
        clearInterval(tr.nearCountdownTimerId);
        tr.nearCountdownTimerId = null;
      }
      tr.nearCountdownSeconds = null;
      if (tr.etaInfoWindow) tr.etaInfoWindow.close();
      return;
    }

    if (tr.nearCountdownSeconds == null || tr.nearCountdownSeconds <= 0) {
      if (tr.etaInfoWindow) tr.etaInfoWindow.close();
      if (tr.nearCountdownTimerId) {
        clearInterval(tr.nearCountdownTimerId);
        tr.nearCountdownTimerId = null;
      }
      tr.nearCountdownSeconds = null;
      return;
    }

    const countdownText = getNearCountdownText(tr.nearCountdownSeconds);

    const html = `
      <div style="
        background:#0f172a;
        color:#fecaca;
        padding:4px 10px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #ef4444;
        white-space:nowrap;
        animation: merchant-blink 0.8s linear infinite;
      ">
        ${countdownText}
      </div>
    `;
    tr.etaInfoWindow.setContent(html);
    tr.etaInfoWindow.open(map, st.marker);
  };

  render();

  tr.nearCountdownTimerId = setInterval(() => {
    if (tr.nearCountdownSeconds != null) {
      tr.nearCountdownSeconds -= 1;
      render();
    }
  }, 1000);
}

function mtStopTrackingForDriver(driverId) {
  const tr = multiTrackingByDriver[driverId];
  if (!tr) return;

  if (tr.routePolyline) {
    tr.routePolyline.setMap(null);
    tr.routePolyline = null;
  }
  tr.routeFullPath = [];

  if (tr.etaTimerId) {
    clearInterval(tr.etaTimerId);
    tr.etaTimerId = null;
  }
  if (tr.nearCountdownTimerId) {
    clearInterval(tr.nearCountdownTimerId);
    tr.nearCountdownTimerId = null;
  }

  if (tr.etaInfoWindow) {
    tr.etaInfoWindow.close();
    tr.etaInfoWindow = null;
  }

  tr.etaSeconds = null;
  tr.etaUpdatedAt = null;
  tr.nearCountdownSeconds = null;
  tr.nearAlertPlayed = false;
  tr.directionsRequestedForCurrentLeg = false;
  tr.mapFittedForCurrentLeg = false;

  mtHideCustomerMarkerForDriver(driverId);

  delete multiTrackingByDriver[driverId];
}

function ensureCustomerMarkerOnMap(lat, lng, label) {
  if (!map || lat == null || lng == null) return;
  const pos = { lat, lng };

  if (!customerMarker) {
    customerMarker = new google.maps.Marker({
      position: pos,
      map,
      title: label || "العميل",
      icon: getCustomerMarkerIcon()
    });
  } else {
    customerMarker.setPosition(pos);
    customerMarker.setMap(map);
  }
}

function hideCustomerMarker() {
  if (customerMarker) {
    customerMarker.setMap(null);
  }
}

function getRouteDistanceKm(origin, destination) {
  return new Promise((resolve) => {
    if (!directionsService) {
      directionsService = new google.maps.DirectionsService();
    }
    directionsService.route(
      {
        origin: origin,
        destination: destination,
        travelMode: google.maps.TravelMode.DRIVING
      },
      (result, status) => {
        if (
          status === "OK" &&
          result.routes &&
          result.routes.length > 0 &&
          result.routes[0].legs &&
          result.routes[0].legs.length > 0 &&
          result.routes[0].legs[0].distance
        ) {
          resolve(result.routes[0].legs[0].distance.value / 1000);
        } else {
          console.error("فشل حساب مسار Google Maps", status, result);
          resolve(0);
        }
      }
    );
  });
}

function initMapAndData(merchantId) {
  currentMerchantId = merchantId;

  if (!map) {
    const geocoder = new google.maps.Geocoder();
    const merchantAddress =
      merchantNameEl.textContent + ", " + merchantCityEl.textContent;

    map = new google.maps.Map(mapContainer, {
      center: { lat: 25.276987, lng: 55.296249 },
      zoom: 14,
      styles: [
        { elementType: "geometry", stylers: [{ color: "#f5f5f5" }] },
        { elementType: "labels.text.fill", stylers: [{ color: "#616161" }] },
        { elementType: "labels.text.stroke", stylers: [{ color: "#f5f5f5" }] },
        {
          featureType: "road",
          elementType: "geometry",
          stylers: [{ color: "#e0e0e0" }]
        },
        {
          featureType: "road",
          elementType: "labels.text.fill",
          stylers: [{ color: "#4b5563" }]
        },
        {
          featureType: "poi",
          stylers: [{ visibility: "off" }]
        }
      ],
      fullscreenControl: false,
      zoomControl: false,
      streetViewControl: false,
      mapTypeControl: false,
      gestureHandling: "greedy"
    });

    geocoder.geocode({ address: merchantAddress }, (results, status) => {
      if (status === "OK" && results[0]) {
        const location = results[0].geometry.location;
        map.setCenter(location);

        merchantLocationLat = location.lat();
        merchantLocationLng = location.lng();

        currentDestinationLat = merchantLocationLat;
        currentDestinationLng = merchantLocationLng;
        currentDestinationType = "merchant";
        currentDestinationAddress = null;
        directionsRequestedForCurrentLeg = false;

        const circle = new google.maps.Circle({
          center: location,
          radius: 3000
        });
        map.fitBounds(circle.getBounds());

        if (merchantCurrentOnline) {
          ensureMerchantMarkerOnMap();
        } else {
          hideMerchantMarker();
        }
      } else {
        console.error("خطأ في جيوكود العنوان: " + status);
      }
    });

    if (!directionsService) {
      directionsService = new google.maps.DirectionsService();
    }
  }

    if (driversListenerUnsub) driversListenerUnsub();
  driversListenerUnsub = db
    .collection("drivers")
    .where("online", "==", true)
    .onSnapshot((snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const id = change.doc.id;
        const data = change.doc.data();
        cachedDrivers[id] = data;

        if (change.type === "added") {
          if (data.lat && data.lng) addDriverMarker(id, data);
        } else if (change.type === "modified") {
          updateDriverMarker(id, data);
        } else if (change.type === "removed") {
          removeDriverMarker(id);
        }
      });

      refreshDriverFilterOptions();

      if (onlineDriversBadge) {
        const countEl = onlineDriversBadge.querySelector(".count");
        if (countEl) {
          countEl.textContent = snapshot.size;
        }
      }

      // لو البانل مفتوح نحدّث القائمة ديناميكياً
      if (driversPickerPanel && driversPickerPanel.classList.contains("visible")) {
        buildDriversPickerList();
      }
    });

  if (merchantCallsListenerUnsub) merchantCallsListenerUnsub();
  merchantCallsListenerUnsub = db
    .collection("merchants")
    .doc(merchantId)
    .collection("calls")
    .orderBy("createdAt", "desc")
    .onSnapshot((snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const id = change.doc.id;
        const newData = change.doc.data() || {};
        const oldData = lastCallsById[id] || {};
        const oldStatus = (oldData.status || "").toLowerCase();
        const newStatus = (newData.status || "").toLowerCase();

        if (oldStatus !== "accepted" && newStatus === "accepted") {
          playCallAcceptedForMerchant(newData);
        }

        const wasHeadingMerchant = isStatusHeadingToMerchant(oldStatus);
        const nowHeadingMerchant = isStatusHeadingToMerchant(newStatus);
        if (!wasHeadingMerchant && nowHeadingMerchant) {
          handleDriverHeadingToMerchant(id, newData);
        }

        const wasHeadingCustomer = isStatusHeadingToCustomer(oldStatus);
        const nowHeadingCustomer = isStatusHeadingToCustomer(newStatus);
        if (!wasHeadingCustomer && nowHeadingCustomer) {
          handleDriverHeadingToCustomer(id, newData);
        }

        if (
          newStatus === "completed" ||
          newStatus === "finished" ||
          newStatus === "delivered" ||
          newStatus === "cancelled" ||
          newStatus === "rejected"
        ) {
          if (newStatus === "delivered" && customerDeliveredSoundEl) {
            try {
              customerDeliveredSoundEl.currentTime = 0;
              customerDeliveredSoundEl.play();
            } catch (e) {
              console.warn("تعذر تشغيل صوت التسليم:", e);
            }
          }

          stopTrackingDriverForCall(id);
        }

        lastCallsById[id] = newData;
      });

      const calls = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        calls.push({ id: doc.id, ...data });
        lastCallsById[doc.id] = data;
      });
      renderMerchantCalls(calls);
    });
}

function buildDriverInfoContent(id, data) {
  const lang = currentLang || "ar";

  const firstName =
    data.firstName ||
    (data.fullName || "").split(" ")[0] ||
    (lang === "en"
      ? "Driver"
      : lang === "de"
      ? "Fahrer"
      : lang === "tr"
      ? "Sürücü"
      : "سائق");

  const isBusy = !!data.busy;

  // تنسيق الأرقام حسب اللغة (فاصلة للعربي/أوروبي أو نقطة للإنجليزي)
  const formatAmount = (num) => {
    const s = Number(num).toFixed(2);
    if (lang === "de" || lang === "tr") return s.replace(".", ",");
    return s;
  };

  let texts;

  switch (lang) {
    case "en":
      texts = {
        phoneLabel: "Phone:",
        cityLabel: "City:",
        pricingLabel: "Pricing:",
        busy: "The driver is currently busy",
        offline: "You are offline — you cannot send a call",
        callBtn: "Call driver",
        noPricing: "No pricing set yet",
        baseFeeBothSame: (base, perKm) =>
          `Base fee ${base}€ + ${perKm}€/km (from driver to merchant and from merchant to drop-off point)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `Base fee ${base}€ + ${toMer}€/km (driver → merchant) + ${perKm}€/km (merchant → drop-off point)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `Base fee ${base}€ + ${perKm}€/km (merchant → drop-off point)`,
        freeKm: (km) => `First ${km} km free`
      };
      break;

    case "de":
      texts = {
        phoneLabel: "Telefon:",
        cityLabel: "Stadt:",
        pricingLabel: "Tarif:",
        busy: "Der Fahrer ist derzeit beschäftigt",
        offline: "Du bist offline – du kannst keinen Ruf senden",
        callBtn: "Fahrer rufen",
        noPricing: "Noch kein Tarif festgelegt",
        baseFeeBothSame: (base, perKm) =>
          `Grundgebühr ${base}€ + ${perKm}€/km (vom Fahrer zum Händler und vom Händler zum Lieferort)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `Grundgebühr ${base}€ + ${toMer}€/km (Fahrer → Händler) + ${perKm}€/km (Händler → Lieferort)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `Grundgebühr ${base}€ + ${perKm}€/km (Händler → Lieferort)`,
        freeKm: (km) => `Die ersten ${km} km kostenlos`
      };
      break;

    case "tr":
      texts = {
        phoneLabel: "Telefon:",
        cityLabel: "Şehir:",
        pricingLabel: "Fiyatlandırma:",
        busy: "Sürücü şu anda meşgul",
        offline: "Çevrimdışı moddasınız — çağrı gönderemezsiniz",
        callBtn: "Sürücüyü çağır",
        noPricing: "Henüz fiyatlandırma tanımlanmadı",
        baseFeeBothSame: (base, perKm) =>
          `Temel ücret ${base}€ + ${perKm}€/km (sürücüden işletmeye ve işletmeden teslimat noktasına)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `Temel ücret ${base}€ + ${toMer}€/km (sürücü → işletme) + ${perKm}€/km (işletme → teslimat noktası)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `Temel ücret ${base}€ + ${perKm}€/km (işletme → teslimat noktası)`,
        freeKm: (km) => `İlk ${km} km ücretsiz`
      };
      break;

    default: // ar
      texts = {
        phoneLabel: "الهاتف:",
        cityLabel: "المدينة:",
        pricingLabel: "التسعيرة:",
        busy: "السائق مشغول حالياً",
        offline: "أنت في وضع أوفلاين — لا يمكنك إرسال نداء",
        callBtn: "مناداة",
        noPricing: "لم يحدد تسعيرة بعد",
        baseFeeBothSame: (base, perKm) =>
          `رسوم أساسية ${base}€ + ${perKm}€/كم (من السائق إلى التاجر ومن التاجر إلى نقطة التسليم)`,
        baseFeeTwoSegments: (base, toMer, perKm) =>
          `رسوم أساسية ${base}€ + ${toMer}€/كم (من السائق إلى التاجر) + ${perKm}€/كم (من التاجر إلى نقطة التسليم)`,
        baseFeeMerchantOnly: (base, perKm) =>
          `رسوم أساسية ${base}€ + ${perKm}€/كم (من التاجر إلى نقطة التسليم)`,
        freeKm: (km) => `أول ${km} كم مجاناً`
      };
      break;
  }

  let actionHtml = "";
  if (isBusy) {
    actionHtml = `<span class="small" style="color:#d93025;">${texts.busy}</span>`;
  } else if (!merchantCurrentOnline) {
    actionHtml = `<span class="small" style="color:#9ca3af;">${texts.offline}</span>`;
  } else {
    actionHtml = `<button id="callBtn_${id}" class="small call-btn">${texts.callBtn}</button>`;
  }

  let pricingHtml = texts.noPricing;

  const hasDeliveryPrice =
    typeof data.pricePerKmDelivery === "number" &&
    data.pricePerKmDelivery > 0;

  const includeToMerchant = !!data.includeToMerchantSegment;
  const useSameForBoth = data.useSamePriceForBoth !== false;
  const freeKm =
    typeof data.freeKm === "number" ? data.freeKm : 0;

  if (hasDeliveryPrice) {
    const baseFeeStr = formatAmount(BASE_DELIVERY_FEE);
    const deliveryStr = formatAmount(data.pricePerKmDelivery);

    let line = texts.baseFeeMerchantOnly(baseFeeStr, deliveryStr);

    if (includeToMerchant) {
      const toMerchantPrice =
        typeof data.pricePerKmToMerchant === "number" &&
        !useSameForBoth
          ? data.pricePerKmToMerchant
          : data.pricePerKmDelivery;

      const toMerStr = formatAmount(toMerchantPrice);

      if (useSameForBoth) {
        line = texts.baseFeeBothSame(baseFeeStr, deliveryStr);
      } else {
        line = texts.baseFeeTwoSegments(baseFeeStr, toMerStr, deliveryStr);
      }
    } else {
      line = texts.baseFeeMerchantOnly(baseFeeStr, deliveryStr);
    }

    if (freeKm > 0) {
      line += `<br/>${texts.freeKm(freeKm)}`;
    }

    pricingHtml = line;
  }

  const isRtl = lang === "ar";

    const isLtrLang = ["en", "de", "tr"].includes(currentLang);
  const container = document.createElement("div");
  container.style.direction = isLtrLang ? "ltr" : "rtl";
  container.style.textAlign = isLtrLang ? "left" : "right";

  container.innerHTML = `
    <div style="min-width:220px">
      <strong>${escapeHtml(firstName)}</strong><br/>
      <div class="small">${texts.phoneLabel} ${escapeHtml(data.phone || "")}</div>
      <div class="small">${texts.cityLabel} ${escapeHtml(data.city || "")}</div>
      <div class="small" style="margin-top:4px;">
        ${texts.pricingLabel}<br/>${pricingHtml}
      </div>
      <div style="margin-top:8px; display:flex; gap:6px; justify-content:${isRtl ? "flex-end" : "flex-start"};">
        ${actionHtml}
      </div>
    </div>
  `;

  return container;
}

function addDriverMarker(id, data) {
  if (!data.lat || !data.lng) return;

  const isBusy = !!data.busy;

  // إذا الماركر موجود مسبقاً: نحدّثه
  if (driverMarkers[id]) {
    const state = driverMarkers[id];
    state.marker.setPosition({ lat: data.lat, lng: data.lng });

    const wasBusy = !!state.isBusy;
    state.isBusy = isBusy;

    // دائماً نستخدم صورة المركبة كأيقونة
    const vehIcon = getDriverVehicleIcon(data);
    if (vehIcon) {
      state.marker.setIcon(vehIcon);
    }

    // لو تغيّرت حالة الانشغال نغيّر لون الهالة
    if (wasBusy !== isBusy) {
      stopDriverHalo(id);
      startDriverHalo(id); // يختار اللون بحسب isBusy
    } else {
      // نفس الحالة لكن لا يوجد هالة (احتياط)
      if (!driverHaloState[id]) {
        startDriverHalo(id);
      }
    }

    const newContent = buildDriverInfoContent(id, data);
    state.info.setContent(newContent);
    return;
  }

  // إنشاء ماركر جديد
  const marker = new google.maps.Marker({
    position: { lat: data.lat, lng: data.lng },
    map,
    title: (data.firstName || "") + " " + (data.lastName || "")
  });

  const info = new google.maps.InfoWindow();
  const content = buildDriverInfoContent(id, data);
  info.setContent(content);

  marker.addListener("click", () => {
    info.open(map, marker);
    setTimeout(() => {
      const btn = document.getElementById(`callBtn_${id}`);
      if (btn) {
        btn.onclick = () => createCallForDriver(id);
      }
    }, 80);
  });

  const state = {
    marker,
    info,
    isBusy
  };

  driverMarkers[id] = state;

  // دائماً صورة المركبة كأيقونة
  const vehIcon = getDriverVehicleIcon(data);
  if (vehIcon) {
    marker.setIcon(vehIcon);
  }

  // هالة خضراء لمتاح، حمراء لمشغول
  startDriverHalo(id);
}

function updateDriverMarker(id, data) {
  // نعيد استعمال addDriverMarker لتحديث الموقع والأيقونة والهالة
  addDriverMarker(id, data);

  if (multiTrackingByDriver[id]) {
    mtUpdateRouteAndEta(id);
  }
}

function removeDriverMarker(id) {
  const state = driverMarkers[id];
  if (!state) return;
  state.marker.setMap(null);
  state.info.close();
  if (state.pulseInterval) clearInterval(state.pulseInterval);
  delete driverMarkers[id];

  stopDriverHalo(id);
  if (multiTrackingByDriver[id]) {
    mtStopTrackingForDriver(id);
  }
}

function closeDriverInfoWindow(driverId) {
  const state = driverMarkers[driverId];
  if (state && state.info) {
    state.info.close();
  }
}
function isStatusHeadingToMerchant(status) {
  if (!status) return false;
  const s = String(status).toLowerCase();
  return (
    s === "heading_to_merchant" ||
    s === "going_to_merchant" ||
    s === "to_merchant" ||
    s === "in_progress"
  );
}
function isStatusHeadingToCustomer(status) {
  if (!status) return false;
  const s = String(status).toLowerCase();
  return (
    s === "heading_to_customer" ||
    s === "going_to_customer" ||
    s === "to_customer" ||
    s === "to_client" ||
    s === "heading_to_client"
  );
}

function playCallAcceptedForMerchant(callData) {
  if (callAcceptedSoundEl) {
    try {
      callAcceptedSoundEl.currentTime = 0;
      callAcceptedSoundEl.play();
    } catch (e) {
      console.warn("تعذر تشغيل صوت قبول الطلب:", e);
    }
  }
}

function startDriverHalo(driverId, forcedColor) {
  if (!map) return;
  const markerState = driverMarkers[driverId];
  if (!markerState || !markerState.marker) return;

  const pos = markerState.marker.getPosition();
  if (!pos) return;

  // لو في هالة مسبقاً لا نكرر
  if (driverHaloState[driverId]) return;

  // اللون: أحمر للمشغول، أخضر للمتاح (ما لم يتم تمرير forcedColor)
  const color = forcedColor || (markerState.isBusy ? "#d93025" : "#22c55e");

  const baseScale = 18;
  const maxScale  = 32;

  const haloMarker = new google.maps.Marker({
    position: pos,
    map,
    clickable: false,
    zIndex: (markerState.marker.getZIndex() || 100) - 1,
    icon: {
      path: google.maps.SymbolPath.CIRCLE,
      fillColor: color,
      fillOpacity: 0.45,
      strokeColor: color,
      strokeOpacity: 0.9,
      strokeWeight: 1.5,
      scale: baseScale,
    },
  });

  const state = {
    haloMarker,
    baseScale,
    maxScale,
    currentScale: baseScale,
    color,
    intervalId: null,
  };

  state.intervalId = setInterval(() => {
    const mState = driverMarkers[driverId];
    if (!mState || !mState.marker || !mState.marker.getMap()) {
      stopDriverHalo(driverId);
      return;
    }

    const curPos = mState.marker.getPosition();
    if (curPos) state.haloMarker.setPosition(curPos);

    state.currentScale += 0.8;
    if (state.currentScale > state.maxScale) {
      state.currentScale = state.baseScale;
    }

    const progress =
      (state.currentScale - state.baseScale) /
      (state.maxScale - state.baseScale);

    const fillOpacity   = 0.80 * (1 - progress);
    const strokeOpacity = 0.9 * (1 - progress * 0.7);

    state.haloMarker.setIcon({
      path: google.maps.SymbolPath.CIRCLE,
      fillColor: state.color,
      fillOpacity,
      strokeColor: state.color,
      strokeOpacity,
      strokeWeight: 1.5,
      scale: state.currentScale,
    });
  }, 80);

  driverHaloState[driverId] = state;
}

function stopDriverHalo(driverId) {
  const state = driverHaloState[driverId];
  if (!state) return;
  if (state.intervalId) clearInterval(state.intervalId);
  if (state.haloMarker) state.haloMarker.setMap(null);
  delete driverHaloState[driverId];
}

function startTrackingDriverToMerchant(driverId) {
  trackedDriverId = driverId;
  trackedNearAlertPlayed = false;

  currentDestinationType = "merchant";
  currentDestinationLat = merchantLocationLat;
  currentDestinationLng = merchantLocationLng;
  currentDestinationAddress = null;
  directionsRequestedForCurrentLeg = false;
  mapFittedForCurrentLeg = false;

  if (currentTrackedCallId) {
    driverToMerchantDirectionsCountByCall[currentTrackedCallId] = 0;
  }
  driverRouteAvgSpeedMps = null;

  if (trackedRoutePolyline) {
    trackedRoutePolyline.setMap(null);
    trackedRoutePolyline = null;
  }
  trackedRouteFullPath = [];

  if (trackedEtaInfoWindow) {
    trackedEtaInfoWindow.close();
    trackedEtaInfoWindow = null;
  }

  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }
  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }
  nearCountdownSeconds = null;

  updateDriverRouteAndEta();
}
function startTrackingDriverToCustomer(callData) {
  trackedDriverId = callData.driverId || null;
  trackedNearAlertPlayed = false;

  currentDestinationType = "customer";
  currentDestinationLat = null;
  currentDestinationLng = null;
  currentDestinationAddress = callData.deliveryAddress || "";
  currentCustomerName = (callData.customerName || "").trim();
  directionsRequestedForCurrentLeg = false;
  mapFittedForCurrentLeg = false;

  driverRouteAvgSpeedMps = null;

  if (trackedRoutePolyline) {
    trackedRoutePolyline.setMap(null);
    trackedRoutePolyline = null;
  }
  trackedRouteFullPath = [];

  if (trackedEtaInfoWindow) {
    trackedEtaInfoWindow.close();
    trackedEtaInfoWindow = null;
  }
  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }
  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }
  nearCountdownSeconds = null;

  hideCustomerMarker();

  updateDriverRouteAndEta();
}

function stopTrackingDriverToMerchant() {
  trackedDriverId = null;
  trackedNearAlertPlayed = false;

  if (trackedRoutePolyline) {
    trackedRoutePolyline.setMap(null);
    trackedRoutePolyline = null;
  }
  trackedRouteFullPath = [];

  if (trackedEtaInfoWindow) {
    trackedEtaInfoWindow.close();
    trackedEtaInfoWindow = null;
  }

  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }

  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }
  nearCountdownSeconds = null;
}

function getCurrentEtaSeconds() {
  if (trackedEtaSeconds == null || trackedEtaUpdatedAt == null) return null;

  let baseRemaining = Math.max(
    Math.round(trackedEtaSeconds - (Date.now() - trackedEtaUpdatedAt) / 1000),
    0
  );

  if (
    trackedDriverId &&
    map &&
    currentDestinationLat != null &&
    currentDestinationLng != null &&
    driverRouteAvgSpeedMps &&
    driverRouteAvgSpeedMps > 0 &&
    google.maps &&
    google.maps.geometry &&
    google.maps.geometry.spherical
  ) {
    const state = driverMarkers[trackedDriverId];
    if (state && state.marker) {
      const pos = state.marker.getPosition();
      if (pos) {
        const dest = new google.maps.LatLng(
          currentDestinationLat,
          currentDestinationLng
        );
        const distanceMeters =
          google.maps.geometry.spherical.computeDistanceBetween(pos, dest);

        trackedLastDistanceMeters = distanceMeters;

        const seconds = distanceMeters / driverRouteAvgSpeedMps;
        return Math.max(Math.round(seconds), 0);
      }
    }
  }

  return baseRemaining;
}

function updateEtaBubble() {
  if (!trackedEtaInfoWindow || !trackedDriverId) return;

  const markerState = driverMarkers[trackedDriverId];
  if (!markerState || !markerState.marker) return;

  const remaining = getCurrentEtaSeconds();
  if (remaining == null) return;

  if (remaining <= 0) {
    const arrivedText = getEtaArrivedText();
    trackedEtaInfoWindow.setContent(`
      <div style="
        background:#0f172a;
        color:#bbf7d0;
        padding:4px 8px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #22c55e;
        white-space:nowrap;
      ">
        ${arrivedText}
      </div>
    `);
    trackedEtaInfoWindow.open(map, markerState.marker);
    return;
  }

  const etaText = getEtaLabelText(remaining);

  const html = `
    <div style="
      background:#0f172a;
      color:#f9fafb;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      box-shadow:0 4px 12px rgba(15,23,42,0.6);
      border:1px solid #22c55e;
      white-space:nowrap;
    ">
      ${etaText}
    </div>
  `;
  trackedEtaInfoWindow.setContent(html);
  trackedEtaInfoWindow.open(map, markerState.marker);
}

function startNearArrivalCountdown(driverId) {
  const state = driverMarkers[driverId];
  if (!state || !state.marker) return;

  if (trackedEtaTimerId) {
    clearInterval(trackedEtaTimerId);
    trackedEtaTimerId = null;
  }

  if (nearCountdownTimerId) {
    clearInterval(nearCountdownTimerId);
    nearCountdownTimerId = null;
  }

  nearCountdownSeconds = 60;

  if (!trackedEtaInfoWindow) {
    trackedEtaInfoWindow = new google.maps.InfoWindow({
      pixelOffset: new google.maps.Size(0, -40),
      disableAutoPan: true
    });
  } else {
    trackedEtaInfoWindow.setOptions({ disableAutoPan: true });
  }

  const render = () => {
    const currentState = driverMarkers[driverId];
    if (!currentState || !currentState.marker || !currentState.marker.getMap()) {
      if (nearCountdownTimerId) {
        clearInterval(nearCountdownTimerId);
        nearCountdownTimerId = null;
      }
      nearCountdownSeconds = null;
      if (trackedEtaInfoWindow) trackedEtaInfoWindow.close();
      return;
    }

    if (nearCountdownSeconds == null || nearCountdownSeconds <= 0) {
      if (trackedEtaInfoWindow) trackedEtaInfoWindow.close();
      if (nearCountdownTimerId) {
        clearInterval(nearCountdownTimerId);
        nearCountdownTimerId = null;
      }
      nearCountdownSeconds = null;
      return;
    }

    const countdownText = getNearCountdownText(nearCountdownSeconds);

    const html = `
      <div style="
        background:#0f172a;
        color:#fecaca;
        padding:4px 10px;
        border-radius:999px;
        font-size:11px;
        font-weight:700;
        box-shadow:0 4px 12px rgba(15,23,42,0.6);
        border:1px solid #ef4444;
        white-space:nowrap;
        animation: merchant-blink 0.8s linear infinite;
      ">
        ${countdownText}
      </div>
    `;

    trackedEtaInfoWindow.setContent(html);
    trackedEtaInfoWindow.open(map, currentState.marker);
  };

  render();

  nearCountdownTimerId = setInterval(() => {
    if (nearCountdownSeconds != null) {
      nearCountdownSeconds -= 1;
      render();
    }
  }, 1000);
}

function updateRouteProgressAlongPath(currentLatLng) {
  if (!trackedRoutePolyline) return;
  if (!trackedRouteFullPath || trackedRouteFullPath.length === 0) return;
  if (
    !google.maps ||
    !google.maps.geometry ||
    !google.maps.geometry.spherical
  ) {
    return;
  }

  let closestIndex = 0;
  let minDist = Infinity;

  for (let i = 0; i < trackedRouteFullPath.length; i++) {
    const p = trackedRouteFullPath[i];
    const d = google.maps.geometry.spherical.computeDistanceBetween(
      currentLatLng,
      p
    );
    if (d < minDist) {
      minDist = d;
      closestIndex = i;
    }
  }

  if (minDist > 80) return;

  const remaining = trackedRouteFullPath.slice(closestIndex);
  trackedRouteFullPath = remaining;
  trackedRoutePolyline.setPath(remaining);
}

function updateDriverRouteAndEta() {
  if (!trackedDriverId) return;
  if (!map) return;
  if (!currentDestinationType) return;

  const markerState = driverMarkers[trackedDriverId];
  if (!markerState || !markerState.marker) return;

  const origin = markerState.marker.getPosition();
  if (!origin) return;

  updateRouteProgressAlongPath(origin);

  const isCustomerLeg = currentDestinationType === "customer";

  let distanceMetersGeo = null;
  if (
    currentDestinationLat != null &&
    currentDestinationLng != null &&
    google.maps &&
    google.maps.geometry &&
    google.maps.geometry.spherical
  ) {
    const destLatLng = new google.maps.LatLng(
      currentDestinationLat,
      currentDestinationLng
    );
    distanceMetersGeo =
      google.maps.geometry.spherical.computeDistanceBetween(origin, destLatLng);
    trackedLastDistanceMeters = distanceMetersGeo;
  }

  if (
    !trackedNearAlertPlayed &&
    distanceMetersGeo != null &&
    distanceMetersGeo <= 300
  ) {
    trackedNearAlertPlayed = true;

    if (currentDestinationType === "merchant") {
      if (driverNearSoundEl) {
        try {
          driverNearSoundEl.currentTime = 0;
          driverNearSoundEl.play();
        } catch (e) {
          console.warn("تعذر تشغيل صوت قرب الوصول:", e);
        }
      }

      if (trackedRoutePolyline) {
        trackedRoutePolyline.setMap(null);
        trackedRoutePolyline = null;
      }
      
      if (trackedEtaTimerId) {
        clearInterval(trackedEtaTimerId);
        trackedEtaTimerId = null;
      }
      trackedEtaSeconds = null;
      trackedEtaUpdatedAt = null;

      startNearArrivalCountdown(trackedDriverId);
      return;
    }

    if (currentDestinationType === "customer") {
      if (trackedEtaTimerId) {
        clearInterval(trackedEtaTimerId);
        trackedEtaTimerId = null;
      }
      trackedEtaSeconds = null;
      trackedEtaUpdatedAt = null;

      startNearArrivalCountdown(trackedDriverId);
      return;
    }
  }

  if (trackedNearAlertPlayed) return;

  if (!directionsService) {
    directionsService = new google.maps.DirectionsService();
  }

  if (!isCustomerLeg) {
    const now = Date.now();
    if (now - lastDriverRouteRequestAt < 10000) return;
    lastDriverRouteRequestAt = now;
  } else {
    if (directionsRequestedForCurrentLeg) {
      return;
    }
    directionsRequestedForCurrentLeg = true;
  }

  let destination;
  if (currentDestinationLat != null && currentDestinationLng != null) {
    destination = {
      lat: currentDestinationLat,
      lng: currentDestinationLng
    };
  } else if (currentDestinationAddress) {
    destination = currentDestinationAddress;
  } else if (
    currentDestinationType === "merchant" &&
    merchantLocationLat != null &&
    merchantLocationLng != null
  ) {
    destination = {
      lat: merchantLocationLat,
      lng: merchantLocationLng
    };
  } else {
    return;
  }

  directionsService.route(
    {
      origin,
      destination,
      travelMode: google.maps.TravelMode.DRIVING
    },
    (result, status) => {
      if (
        status !== "OK" ||
        !result.routes ||
        !result.routes[0] ||
        !result.routes[0].legs ||
        !result.routes[0].legs[0]
      ) {
        console.warn("تعذر حساب مسار السائق:", status, result);
        return;
      }

      const leg = result.routes[0].legs[0];
      const distanceMeters = leg.distance ? leg.distance.value : null;
      const durationSeconds = leg.duration ? leg.duration.value : null;

      if (distanceMeters != null) {
        trackedLastDistanceMeters = distanceMeters;
      }
      if (
        distanceMeters != null &&
        durationSeconds != null &&
        durationSeconds > 0
      ) {
        driverRouteAvgSpeedMps = distanceMeters / durationSeconds;
      }

      if (currentDestinationType === "customer" && leg.end_location) {
        currentDestinationLat = leg.end_location.lat();
        currentDestinationLng = leg.end_location.lng();
        ensureCustomerMarkerOnMap(
          currentDestinationLat,
          currentDestinationLng,
          currentCustomerName || "العميل"
        );
      } else if (
        currentDestinationType === "merchant" &&
        leg.end_location &&
        (currentDestinationLat == null || currentDestinationLng == null)
      ) {
        currentDestinationLat = leg.end_location.lat();
        currentDestinationLng = leg.end_location.lng();
      }

      if (!mapFittedForCurrentLeg && map && origin) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend(origin);

        if (currentDestinationLat != null && currentDestinationLng != null) {
          bounds.extend(
            new google.maps.LatLng(currentDestinationLat, currentDestinationLng)
          );
        } else if (leg.end_location) {
          bounds.extend(leg.end_location);
        }

        map.fitBounds(bounds);
        mapFittedForCurrentLeg = true;
      }

      const overviewPath = result.routes[0].overview_path;
      if (overviewPath && overviewPath.length) {
        trackedRouteFullPath = overviewPath.slice();

        if (!trackedRoutePolyline) {
          trackedRoutePolyline = new google.maps.Polyline({
            map,
            path: trackedRouteFullPath,
            strokeColor: "#22c55e",
            strokeOpacity: 0.8,
            strokeWeight: 4
          });
        } else {
          trackedRoutePolyline.setPath(trackedRouteFullPath);
        }

        updateRouteProgressAlongPath(origin);
      }

      if (durationSeconds != null) {
        trackedEtaSeconds = durationSeconds;
        trackedEtaUpdatedAt = Date.now();

        if (!trackedEtaInfoWindow) {
          trackedEtaInfoWindow = new google.maps.InfoWindow({
            pixelOffset: new google.maps.Size(0, -40),
            disableAutoPan: true
          });
        } else {
          trackedEtaInfoWindow.setOptions({ disableAutoPan: true });
        }

        updateEtaBubble();

        if (!trackedEtaTimerId) {
          trackedEtaTimerId = setInterval(updateEtaBubble, 1000);
        }
      }
    }
  );
}

function handleDriverHeadingToMerchant(callId, callData) {
  const driverId = callData.driverId || null;
  if (!driverId) return;

  if (driverOnWaySoundEl) {
    try {
      driverOnWaySoundEl.currentTime = 0;
      driverOnWaySoundEl.play();
    } catch (e) {
      console.warn("تعذر تشغيل صوت (السائق في الطريق):", e);
    }
  }

  if (typeof showToast === "function") {
    const driverName = (
      (callData.driverFirstName || "") +
      " " +
      (callData.driverLastName || "")
    ).trim();

    const label = driverName
      ? t("toastDriverHeadingMerchantWithName").replace("{{name}}", driverName)
      : t("toastDriverHeadingMerchantNoName");

    showToast(label);
  }

  startDriverHalo(driverId);
  mtStartTrackingToMerchant(driverId, callId);
}

function handleDriverHeadingToCustomer(callId, callData) {
  const driverId = callData.driverId || null;
  if (!driverId) return;

  if (driverOnWaySoundEl) {
    try {
      driverOnWaySoundEl.currentTime = 0;
      driverOnWaySoundEl.play();
    } catch (e) {
      console.warn("تعذر تشغيل صوت (السائق في الطريق للعميل):", e);
    }
  }

  if (typeof showToast === "function") {
    const driverName = (
      (callData.driverFirstName || "") +
      " " +
      (callData.driverLastName || "")
    ).trim();

    const label = driverName
      ? t("toastDriverHeadingCustomerWithName").replace("{{name}}", driverName)
      : t("toastDriverHeadingCustomerNoName");

    showToast(label);
  }

  startDriverHalo(driverId);
  mtStartTrackingToCustomer(driverId, callId, callData);
}

function stopTrackingDriverForCall(callId) {
  Object.keys(multiTrackingByDriver).forEach((driverId) => {
    const tr = multiTrackingByDriver[driverId];
    if (tr && tr.callId === callId) {
      // نوقف فقط تتبع المسار والـ ETA، ونترك الهالة الخضراء العامة
      mtStopTrackingForDriver(driverId);
    }
  });
}

/* ========== Merchant CALLS rendering ========== */
function renderMerchantCalls(allCalls) {
  lastCallsCache = allCalls.map((c) => {
    if (c.createdAt && c.createdAt.toDate) {
      c._date = c.createdAt.toDate();
    } else {
      c._date = c.createdAt ? new Date(c.createdAt) : new Date();
    }
    return c;
  });

  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  const active = lastCallsCache.filter((c) =>
    !completedStatuses.includes((c.status || "pending").toLowerCase())
  );
  const completed = lastCallsCache.filter((c) =>
    completedStatuses.includes((c.status || "").toLowerCase())
  );

  const driverFilterVal = filterDriver.value;

  let activeFiltered = active.slice();
  let completedFiltered = completed.slice();

  if (driverFilterVal) {
    activeFiltered = activeFiltered.filter(
      (c) => c.driverId === driverFilterVal
    );
    completedFiltered = completedFiltered.filter(
      (c) => c.driverId === driverFilterVal
    );
  }

  const sortA = sortActive.value;
  activeFiltered.sort((a, b) => compareCalls(a, b, sortA));

  const sortC = sortCompleted.value;
  completedFiltered.sort((a, b) => compareCalls(a, b, sortC));

    countActiveEl.innerHTML =
    `${t("statsActiveCalls")}<br><strong>${activeFiltered.length}</strong>`;
  countCompletedEl.innerHTML =
    `${t("statsPastCalls")}<br><strong>${completedFiltered.length}</strong>`;

  // إجمالي التوصيل لجميع السائقين (لشريط الأعلى)
  const getCallFee = (c) => {
    if (c && c.cost && typeof c.cost.totalFee === "number") {
      return c.cost.totalFee;
    }
    if (typeof c.deliveryFee === "number") {
      return c.deliveryFee;
    }
    return 0;
  };

  const totalDeliveryFeeAll = completed.reduce((sum, c) => {
    const status = (c.status || "").toLowerCase();
    const fee = getCallFee(c);

    // نحتسب:
    // 1) كل الطلبات المسلّمة
    // 2) الطلبات الملغاة اللي فيها تعويض فعلي (> 0)
    if (status === "delivered" || (status === "cancelled" && fee > 0)) {
      return sum + fee;
    }
    return sum;
  }, 0);

  // إجمالي التوصيل حسب الفلتر (السائق المحدد فقط)
  const totalDeliveryFeeFiltered = completedFiltered.reduce((sum, c) => {
    const status = (c.status || "").toLowerCase();
    const fee = getCallFee(c);

    if (status === "delivered" || (status === "cancelled" && fee > 0)) {
      return sum + fee;
    }
    return sum;
  }, 0);

  // صندوق "إجمالي التوصيل" داخل القائمة الجانبية يتبع الفلتر
  document.getElementById("totalDelivery").innerHTML =
    `${t("statsTotalDelivery")}<br><strong>${totalDeliveryFeeFiltered.toFixed(2)}</strong>`;

  // شريط الأرباح العلوي يعرض الإجمالي الكلي لكل السائقين
  if (merchantEarningsTopEl) {
    merchantEarningsTopEl.innerHTML =
      `${t("statsTotalDelivery")}<br><strong>${totalDeliveryFeeAll.toFixed(2)} €</strong>`;
  }

  activeOrdersEl.innerHTML = "";
activeFiltered.forEach((c) => {
  const driverName =
    (cachedDrivers[c.driverId] &&
      ((cachedDrivers[c.driverId].firstName || "") +
        " " +
        (cachedDrivers[c.driverId].lastName || ""))) ||
    c.driverFirstName ||
    "سائق";

  // الطلب النشط: السائق في الطريق للتاجر أو للعميل
  const isLiveTrip =
    isStatusHeadingToMerchant(c.status) ||
    isStatusHeadingToCustomer(c.status);

  const card = document.createElement("div");
  card.className = "order-card";
  if (isLiveTrip) {
    card.classList.add("active-call"); // إطار أخضر نابض
  }

  card.innerHTML = `
    <div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
      <div>
        <div><strong>#${getShortId(c.id)}</strong> — ${escapeHtml(driverName)}</div>
        <div class="small">${t("callStatusLabel")}: ${escapeHtml(
          c.status || "pending"
        )} — ${formatDate(c._date)}</div>
      </div>
    </div>
  `;

  activeOrdersEl.appendChild(card);

  card.addEventListener("click", (e) => {
    if (e.target.tagName.toLowerCase() === "button") return;
    viewOrderDetails(c.id);
  });
});

  completedOrdersEl.innerHTML = "";
  completedFiltered.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      c.driverFirstName ||
      "سائق";

    const dateBase =
      c.respondedAt && c.respondedAt.toDate
        ? c.respondedAt.toDate()
        : c._date;

    const card = document.createElement("div");
    card.className = "order-card";
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; gap:8px; align-items:center;">
        <div>
          <div><strong>#${getShortId(c.id)}</strong> — ${escapeHtml(driverName)}</div>
          <div class="small">${escapeHtml(
            c.status || ""
          )} — ${formatDate(dateBase)}</div>
        </div>
      </div>
    `;

    completedOrdersEl.appendChild(card);

    card.addEventListener("click", (e) => {
      if (e.target.tagName.toLowerCase() === "button") return;
      viewOrderDetails(c.id);
    });
	refreshDriverFilterOptions();
  });
}

function compareCalls(a, b, mode) {
  if (!mode) mode = "date_desc";

  const ad = a._date;
  const bd = b._date;

  if (mode === "date_desc") return bd - ad;
  if (mode === "date_asc") return ad - bd;

  const nameA =
    (cachedDrivers[a.driverId] &&
      (cachedDrivers[a.driverId].firstName || "")) ||
    a.driverFirstName ||
    "";

  const nameB =
    (cachedDrivers[b.driverId] &&
      (cachedDrivers[b.driverId].firstName || "")) ||
    b.driverFirstName ||
    "";

  if (mode === "driver_asc") return nameA.localeCompare(nameB);
  if (mode === "driver_desc") return nameB.localeCompare(nameA);

  return 0;
}

/* ========== Utilities ========== */
function formatDate(d) {
  if (!d) return "";
  return d.toLocaleString();
}
function escapeHtml(s) {
  if (!s) return "";
  return String(s).replace(/[&<>"]/g, function (c) {
    return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[c];
  });
}
function getShortId(id) {
  if (!id) return "";
  return String(id).slice(-6);
}

/* ========== تفاصيل الطلب (من calls) للتاجر ========== */
window.viewOrderDetails = async function (callId) {
  if (!currentMerchantId) return alert(t("alertMerchantNotSet"));

  const doc = await db
    .collection("merchants")
    .doc(currentMerchantId)
    .collection("calls")
    .doc(callId)
    .get();

  if (!doc.exists) return alert(t("alertOrderNotFound"));

  const o = { id: doc.id, ...doc.data() };

  const dist = o.distance || {};
  const totalKm =
    dist && typeof dist.totalKm === "number"
      ? dist.totalKm.toFixed(2) + " كم"
      : null;
  const d1 =
    typeof dist.driverToMerchantKm === "number"
      ? dist.driverToMerchantKm.toFixed(2) + " كم"
      : null;
  const d2 =
    typeof dist.merchantToDropoffKm === "number"
      ? dist.merchantToDropoffKm.toFixed(2) + " كم"
      : null;

  let feeLabel = "—";
  if (o.cost && typeof o.cost.totalFee === "number") {
    feeLabel = o.cost.totalFee.toFixed(2) + " €";
  } else if (o.deliveryFee != null) {
    feeLabel = String(o.deliveryFee);
  }

  const shortId = getShortId(o.id);
  const driverName = (
    (o.driverFirstName || "") +
    " " +
    (o.driverLastName || "")
  ).trim();

  let html = `<div><strong>${t("orderDetailsHeadingPrefix")} #${shortId}</strong></div>`;

  html += `<div class="small">${t("orderDetailsStatusLabel")}: ${escapeHtml(
    o.status || ""
  )}</div>`;
  if (o.createdAt && o.createdAt.toDate) {
    html += `<div class="small">${t("orderDetailsDateLabel")}: ${formatDate(
      o.createdAt.toDate()
    )}</div>`;
  }

  html += `<div style="margin-top:8px;">`;
  html += `<div>${t("orderDetailsDriverLabel")}: ${escapeHtml(driverName || "-")}</div>`;
  html += `<div>${t("orderDetailsDriverPhoneLabel")}: ${escapeHtml(
    o.driverPhone || "-"
  )}</div>`;
  html += `<div>${t("orderDetailsCityLabel")}: ${escapeHtml(
    o.merchantCity || "-"
  )}</div>`;
  html += `<div>${t("orderDetailsCustomerNameLabel")}: ${escapeHtml(
    o.customerName || "-"
  )}</div>`;
  html += `<div>${t("orderDetailsAddressLabel")}: ${escapeHtml(
    o.deliveryAddress || "-"
  )}</div>`;

  if (totalKm) {
    html += `<div>${t("orderDetailsTotalDistanceLabel")}: ${totalKm}</div>`;
    if (d1 || d2) {
      const d1Label = d1 || "—";
      const d2Label = d2 || "—";
      const segText = t("orderDetailsSegmentDistancesLabel")
        .replace("{{d1}}", d1Label)
        .replace("{{d2}}", d2Label);
      html += `<div class="small">${segText}</div>`;
    }
  }

  html += `<div>${t("orderDetailsDeliveryCostLabel")}: ${feeLabel}</div>`;
  html += `<div>${t("orderDetailsNotesLabel")}: ${escapeHtml(
    o.notes || "-"
  )}</div>`;
  html += `</div>`;

  html += `<div class="btn-row">`;
  if (
    !o.status ||
    o.status === "pending" ||
    o.status === "accepted" ||
    o.status === "in_progress"
  ) {
    html += `<button class="secondary" onclick="printOrder('${o.id}')">${t(
      "orderDetailsPrintBtn"
    )}</button>`;
    html += `<button onclick="cancelOrder('${o.id}')" class="secondary">${t(
      "orderDetailsCancelBtn"
    )}</button>`;
  }
  html += `<button onclick="closeOrderModal()" class="secondary">${t(
    "orderDetailsCloseBtn"
  )}</button>`;
  html += `</div>`;

  modalContent.innerHTML = html;
  if (orderModalEl) orderModalEl.classList.remove("hidden");
  modalBackdrop.style.display = "flex";
  window.scrollTo(0, 0);
};

function closeOrderModal() {
  modalBackdrop.style.display = "none";
  modalContent.innerHTML = "";
  if (orderModalEl) orderModalEl.classList.add("hidden");
}

modalBackdrop.addEventListener("click", (e) => {
  if (e.target === modalBackdrop) closeOrderModal();
});

/* ========== مناداة السائق (إنشاء call للتاجر) ========== */
async function createCallForDriver(driverId) {
  const driver = cachedDrivers[driverId] || {};

  if (!currentMerchantId) {
    showToast(t("toastNoMerchant"), "error");
    return;
  }

  if (!merchantCurrentOnline) {
    showToast(t("toastOffline"), "error");
    return;
  }

  if (driver.busy) {
    showToast(t("toastDriverBusy"), "error");
    return;
  }

  try {
    const merchantName = merchantNameEl.textContent || "";
    const merchantCity = merchantCityEl.textContent || "";

    const callData = {
      merchantId: currentMerchantId,
      merchantName,
      merchantCity,
      driverId,
      driverFirstName: driver.firstName || "",
      driverLastName: driver.lastName || "",
      driverPhone: driver.phone || "",
      status: "pending",
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    if (merchantLocationLat != null && merchantLocationLng != null) {
      callData.merchantLat = merchantLocationLat;
      callData.merchantLng = merchantLocationLng;
    }

    await db
      .collection("merchants")
      .doc(currentMerchantId)
      .collection("calls")
      .add(callData);

    if (merchantCallSoundEl) {
      try {
        merchantCallSoundEl.currentTime = 0;
        merchantCallSoundEl.play();
      } catch (e) {
        console.warn("تعذر تشغيل صوت إرسال النداء:", e);
      }
    }

    closeDriverInfoWindow(driverId);

    const label = driver.firstName
      ? t("toastCallSentPrefix") + " " + driver.firstName
      : t("toastCallSentPrefix");
    showToast(label, "success");
  } catch (err) {
    showToast(t("toastErrorSendCallPrefix") + " " + err.message, "error");
  }
}

/* ========== Export / Print للتاجر ========== */
exportCsvBtn.addEventListener("click", () => {
  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  let completed = lastCallsCache.filter((c) =>
    completedStatuses.includes((c.status || "").toLowerCase())
  );

  const driverFilterVal = filterDriver.value;
  if (driverFilterVal) {
    completed = completed.filter((c) => c.driverId === driverFilterVal);
  }

  if (!completed.length) {
    if (driverFilterVal) {
      alert(t("alertNoExportForDriver"));
    } else {
      alert(t("alertNoExportAll"));
    }
    return;
  }

  const rows = [];
  // رؤوس الأعمدة مترجمة
  rows.push([
    t("csvHeaderId"),
    t("csvHeaderDriverId"),
    t("csvHeaderDriverName"),
    t("csvHeaderStatus"),
    t("csvHeaderRequestTime"),
    t("csvHeaderResponseTime"),
    t("csvHeaderMerchantName"),
    t("csvHeaderMerchantCity")
  ]);

  completed.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      ((c.driverFirstName || "") + " " + (c.driverLastName || "")).trim();

    const createdIso =
      c.createdAt && c.createdAt.toDate
        ? c.createdAt.toDate().toISOString()
        : "";

    const respondedIso =
      c.respondedAt && c.respondedAt.toDate
        ? c.respondedAt.toDate().toISOString()
        : "";

    rows.push([
      c.id,
      c.driverId || "",
      driverName,
      c.status || "",
      createdIso,
      respondedIso,
      c.merchantName || "",
      c.merchantCity || ""
    ]);
  });

  const csvContent = rows
    .map((r) =>
      r.map((c) => `"${String(c).replace(/"/g, '""')}"`).join(",")
    )
    .join("\n");

  const blob = new Blob([csvContent], {
    type: "text/csv;charset=utf-8;"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;

  let fileName = `calls_${new Date().toISOString().slice(0, 10)}.csv`;
  if (driverFilterVal) {
    const d = cachedDrivers[driverFilterVal] || {};
    const driverNameFile =
      ((d.firstName || "") + "_" + (d.lastName || "")).trim() || "driver";
    fileName = `calls_${driverNameFile}_${new Date()
      .toISOString()
      .slice(0, 10)}.csv`;
  }
  a.download = fileName;

  a.click();
  URL.revokeObjectURL(url);
});

printBtn.addEventListener("click", () => {
  const completedStatuses = [
    "rejected",
    "cancelled",
    "completed",
    "finished",
    "delivered"
  ];

  // الطلبات المكتملة
  let completed = lastCallsCache.filter((c) =>
    completedStatuses.includes((c.status || "").toLowerCase())
  );

  const driverFilterVal = filterDriver.value;
  if (driverFilterVal) {
    completed = completed.filter((c) => c.driverId === driverFilterVal);
  }

  const labels = {
    title: t("printTitleCalls"),
    merchantLabel: t("printMerchantLabel"),
    driverLabel: t("printDriverLabel"),
    dateGenerated: t("printDateGenerated"),
    driverPricingTitle: t("printDriverPricingTitle"),
    baseFeeLabel: t("printBaseFeeLabel"),
    perKmToCustomerLabel: t("printPerKmToCustomerLabel"),
    perKmToMerchantLabel: t("printPerKmToMerchantLabel"),
    colMerchant: t("printColMerchant"),
    colDriver: t("printColDriver"),
    colOrderId: t("printColOrderId"),
    colStatus: t("printColStatus"),
    colCreatedAt: t("printColCreatedAt"),
    colCustomerAddress: t("printColCustomerAddress"),
    colDistDriverToMerchant: t("printColDistDriverToMerchant"),
    colDistMerchantToCustomer: t("printColDistMerchantToCustomer"),
    colDeliveryFee: t("printColDeliveryFee"),
    footerTotalOrders: t("printFooterTotalOrders"),
    footerTotalFees: t("printFooterTotalFees"),
    noOrdersAll: t("printNoOrders"),
    noOrdersDriver: t("printNoOrdersForDriver")
  };

  if (!completed.length) {
    const msg = driverFilterVal ? labels.noOrdersDriver : labels.noOrdersAll;
    alert(msg);
    return;
  }

  // اتجاه اللغة
  const lang = currentLang || "ar";
  const isRtl = lang === "ar";
  const dirAttr = isRtl ? "rtl" : "ltr";
  const align = isRtl ? "right" : "left";
  const pageNumberPos = isRtl ? "left: 8px;" : "right: 8px;";

  const merchantHeaderName = (merchantNameEl?.textContent || "").trim();

  // السائق المختار (لو فيه فلتر)
  let driverHeaderName = "";
  let driverDoc = null;
  if (driverFilterVal) {
    driverDoc = cachedDrivers[driverFilterVal] || {};
    driverHeaderName =
      ((driverDoc.firstName || "") + " " + (driverDoc.lastName || "")).trim();
  }

  // تاريخ الطباعة – UTC
  const nowUtc = new Date();
  const nowUtcLabel = nowUtc
    .toISOString()
    .replace("T", " ")
    .replace("Z", " UTC");

  // HTML + CSS (مع أرقام الصفحات)
  let html = `
<html dir="${dirAttr}">
<head>
<meta charset="utf-8">
<title>${escapeHtml(labels.title)}</title>
<style>
  body {
    font-family: Arial, sans-serif;
    direction: ${dirAttr};
    text-align: ${align};
    font-size: 13px;
    color: #111;
    padding: 16px;
  }
  h2 { margin: 0 0 8px; }
  h3 { margin: 6px 0; }
  .meta { margin-bottom: 8px; }
  .meta div { margin-bottom: 2px; }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
  }
  th, td {
    border: 1px solid #ddd;
    padding: 6px 8px;
    font-size: 12px;
    vertical-align: top;
  }
  th {
    background: #f3f4f6;
    text-align: ${align};
  }
  .totals-box {
    margin-top: 10px;
    font-weight: bold;
    page-break-inside: avoid;
  }
  
  }
</style>
</head>
<body>`;

  // الهيدر: تاجر + سائق + تاريخ طباعة
  html += `<h2>${escapeHtml(labels.title)}</h2>`;
  html += `<div class="meta">`;
  html += `<div><strong>${escapeHtml(labels.merchantLabel)}:</strong> ${escapeHtml(merchantHeaderName || "-")}</div>`;
  if (driverHeaderName) {
    html += `<div><strong>${escapeHtml(labels.driverLabel)}:</strong> ${escapeHtml(driverHeaderName)}</div>`;
  }
  html += `<div><strong>${escapeHtml(labels.dateGenerated)}:</strong> ${escapeHtml(nowUtcLabel)}</div>`;
  html += `</div>`;

  // تسعيرة السائق (إن وُجد فلتر سائق)
  if (driverDoc) {
    const hasDeliveryPrice =
      typeof driverDoc.pricePerKmDelivery === "number" &&
      driverDoc.pricePerKmDelivery > 0;

    if (hasDeliveryPrice) {
      const includeToMerchant = !!driverDoc.includeToMerchantSegment;
      const useSameForBoth = driverDoc.useSamePriceForBoth !== false;
      const freeKm =
        typeof driverDoc.freeKm === "number" ? driverDoc.freeKm : 0;

      const baseFee = BASE_DELIVERY_FEE.toFixed(2);
      const deliveryP = driverDoc.pricePerKmDelivery.toFixed(2);

      let toMerPrice = driverDoc.pricePerKmDelivery;
      if (
        includeToMerchant &&
        !useSameForBoth &&
        typeof driverDoc.pricePerKmToMerchant === "number"
      ) {
        toMerPrice = driverDoc.pricePerKmToMerchant;
      }
      const toMerStr = toMerPrice.toFixed(2);

      html += `<div style="margin-bottom: 8px;">`;
      html += `<strong>${escapeHtml(labels.driverPricingTitle)}:</strong><br/>`;
      html += `${escapeHtml(labels.baseFeeLabel)}: ${baseFee} €<br/>`;
      html += `${escapeHtml(labels.perKmToCustomerLabel)}: ${deliveryP} €/km`;
      if (includeToMerchant) {
        html += `<br/>${escapeHtml(labels.perKmToMerchantLabel)}: ${toMerStr} €/km`;
      }
      if (freeKm > 0) {
        const freeLabel = t("printFreeKmLabel").replace("{KM}", String(freeKm));
        html += `<br/>${escapeHtml(freeLabel)}`;
      }
      html += `</div>`;
    }
  }

  // جدول الطلبات
  html += `<table><thead><tr>
    <th>${escapeHtml(labels.colMerchant)}</th>
    <th>${escapeHtml(labels.colDriver)}</th>
    <th>${escapeHtml(labels.colOrderId)}</th>
    <th>${escapeHtml(labels.colStatus)}</th>
    <th>${escapeHtml(labels.colCreatedAt)}</th>
    <th>${escapeHtml(labels.colCustomerAddress)}</th>
    <th>${escapeHtml(labels.colDistDriverToMerchant)}</th>
    <th>${escapeHtml(labels.colDistMerchantToCustomer)}</th>
    <th>${escapeHtml(labels.colDeliveryFee)}</th>
  </tr></thead><tbody>`;

  let totalOrders = completed.length;
  let totalFees = 0;

  completed.forEach((c) => {
    const driverName =
      (cachedDrivers[c.driverId] &&
        ((cachedDrivers[c.driverId].firstName || "") +
          " " +
          (cachedDrivers[c.driverId].lastName || ""))) ||
      ((c.driverFirstName || "") + " " + (c.driverLastName || "")).trim();

    const merchantNameRow = c.merchantName || merchantHeaderName || "";

    const createdDate =
      c.createdAt && c.createdAt.toDate
        ? c.createdAt.toDate()
        : c._date || new Date();
    const createdUtcLabel = createdDate
      .toISOString()
      .replace("T", " ")
      .replace("Z", " UTC");

    const dist = c.distance || c.dist || {};
    const d1 =
      typeof dist.driverToMerchantKm === "number"
        ? dist.driverToMerchantKm.toFixed(2)
        : "";
    const d2 =
      typeof dist.merchantToDropoffKm === "number"
        ? dist.merchantToDropoffKm.toFixed(2)
        : "";

    let fee = 0;
    if (c.cost && typeof c.cost.totalFee === "number") {
      fee = c.cost.totalFee;
    } else if (typeof c.deliveryFee === "number") {
      fee = c.deliveryFee;
    }
    totalFees += fee;
    const feeStr = fee ? fee.toFixed(2) : "";

    // ID مختصر (6 خانات)
    const shortId = getShortId(c.id);

    html += `<tr>
      <td>${escapeHtml(merchantNameRow || "")}</td>
      <td>${escapeHtml(driverName || "")}</td>
      <td>${escapeHtml(shortId || "")}</td>
      <td>${escapeHtml(c.status || "")}</td>
      <td>${escapeHtml(createdUtcLabel)}</td>
      <td>${escapeHtml(c.deliveryAddress || "")}</td>
      <td>${escapeHtml(d1)}</td>
      <td>${escapeHtml(d2)}</td>
      <td>${escapeHtml(feeStr)}</td>
    </tr>`;
  });

  html += `</tbody></table>`;

  // التذييل (مرة واحدة بعد الجدول → يظهر في آخر التقرير)
  html += `<div class="totals-box">
    <div>${escapeHtml(labels.footerTotalOrders)}: ${totalOrders}</div>
    <div>${escapeHtml(labels.footerTotalFees)}: ${totalFees.toFixed(2)} €</div>
  </div>`;

  html += `</body></html>`;

  const w = window.open("", "_blank");
  w.document.write(html);
  w.document.close();
  w.print();
});

/* ========== فلتر السائقين ========== */
function refreshDriverFilterOptions() {
  if (!filterDriver) return;

  const cur = filterDriver.value;

  // 1) نجمع كل الـ driverId من:
  //    - السائقين الأونلاين (cachedDrivers)
  //    - النداءات (lastCallsCache) — تشمل الأوفلاين
  const idsSet = new Set();

  // من السائقين الأونلاين
  Object.keys(cachedDrivers || {}).forEach((id) => idsSet.add(id));

  // من النداءات (calls)
  (lastCallsCache || []).forEach((c) => {
    if (c.driverId) idsSet.add(c.driverId);
  });

  // إعادة بناء عناصر الفلتر
  filterDriver.innerHTML = `<option value="">${t("filterAllDrivers")}</option>`;

  idsSet.forEach((id) => {
    let name = "";

    // لو عندنا بيانات في cachedDrivers (أونلاين أو تم تحميله مسبقاً)
    const d = cachedDrivers[id];
    if (d) {
      name = `${d.firstName || ""} ${d.lastName || ""}`.trim();
    }

    // لو ما عندنا بيانات في drivers collection، نأخذ الاسم من النداءات
    if (!name) {
      const call = (lastCallsCache || []).find((c) => c.driverId === id);
      if (call) {
        name = `${call.driverFirstName || ""} ${call.driverLastName || ""}`.trim();
      }
    }

    // لو لسه بدون اسم، نستخدم الـ id كحل أخير
    if (!name) name = id;

    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = name;
    filterDriver.appendChild(opt);
  });

  // نحافظ على الاختيار السابق إن وجد
  if (cur) filterDriver.value = cur;
}
// نحسب "درجة السعر" للسائق: كلما كانت أقل كان السائق أرخص
function computeDriverPriceScore(driverData) {
  if (!driverData) return Infinity;
  if (typeof driverData.pricePerKmDelivery === "number") {
    return driverData.pricePerKmDelivery;
  }
  return Infinity; // بدون تسعيرة نضعه في الآخر
}

// يبني قائمة السائقين المتاحين داخل البانل (لا يفتح/يغلق)
function buildDriversPickerList() {
  if (!driversPickerList) return;

  driversPickerList.innerHTML = "";

  // نستخدم driverMarkers لضمان أن السائق له ماركر (أونلاين فعلاً)
  const items = [];
  Object.keys(driverMarkers).forEach((id) => {
    const d = cachedDrivers[id] || {};
    if (d.busy) return; // نأخذ فقط المتاحين
    items.push({
      id,
      data: d,
      priceScore: computeDriverPriceScore(d)
    });
  });

  // ترتيب من الأقل سعراً للأغلى
  items.sort((a, b) => a.priceScore - b.priceScore);

  // عنوان البانل حسب اللغة الحالية
  const titleEl = document.getElementById("driversPickerTitle");
  if (titleEl) {
    let titleText;
    switch (currentLang) {
      case "en":
        titleText = "Available drivers (cheapest first)";
        break;
      case "de":
        titleText = "Verfügbare Fahrer (günstigste zuerst)";
        break;
      case "tr":
        titleText = "Müsait sürücüler (en ucuzdan)";
        break;
      default:
        titleText = "السائقون المتاحون (من الأقل سعراً)";
    }
    titleEl.textContent = titleText;
  }

  if (!items.length) {
    const empty = document.createElement("div");
    empty.className = "small";
    empty.style.padding = "4px 2px";
    let msg;
    switch (currentLang) {
      case "en":
        msg = "No available drivers at the moment.";
        break;
      case "de":
        msg = "Zurzeit keine verfügbaren Fahrer.";
        break;
      case "tr":
        msg = "Şu anda müsait sürücü yok.";
        break;
      default:
        msg = "لا يوجد سائقون متاحون حالياً.";
    }
    empty.textContent = msg;
    driversPickerList.appendChild(empty);
    return;
  }

  items.forEach((item) => {
    const d = item.data;
    const name = (
      ((d.firstName || "") + " " + (d.lastName || "")).trim() || "سائق"
    );

    let priceLabel = "";
    if (typeof d.pricePerKmDelivery === "number") {
      let p = d.pricePerKmDelivery.toFixed(2);
      if (currentLang === "de" || currentLang === "tr") {
        p = p.replace(".", ",");
      }
      priceLabel = p + " €/km";
    } else {
      switch (currentLang) {
        case "en":
          priceLabel = "no pricing";
          break;
        case "de":
          priceLabel = "kein Tarif";
          break;
        case "tr":
          priceLabel = "tarife yok";
          break;
        default:
          priceLabel = "بدون تسعيرة";
      }
    }

    const itemEl = document.createElement("div");
    itemEl.className = "selected-driver-item";
    itemEl.innerHTML = `
      <div class="selected-driver-name">${escapeHtml(name)}</div>
      <div class="selected-driver-price">${escapeHtml(priceLabel)}</div>
    `;
    itemEl.addEventListener("click", () => {
      focusDriverOnMap(item.id);
    });
    driversPickerList.appendChild(itemEl);
  });
}

// فتح/إغلاق البانل
function openDriversPicker() {
  if (!driversPickerPanel) return;
  buildDriversPickerList();
  driversPickerPanel.classList.add("visible");
}

function closeDriversPicker() {
  if (!driversPickerPanel) return;
  driversPickerPanel.classList.remove("visible");
}

// تركيز الخريطة وفتح فقاعة السائق الموجودة مسبقاً
function focusDriverOnMap(driverId) {
  const state = driverMarkers[driverId];
  if (!state || !state.marker) return;

  const pos = state.marker.getPosition();
  if (pos && map) {
    map.panTo(pos);
    if (map.getZoom() < 15) {
      map.setZoom(15);
    }
  }

  // فتح الـ InfoWindow الافتراضي للسائق
  state.info.open(map, state.marker);

  // تفعيل زر النداء داخل الفقاعة (نفس منطق الضغط على الماركر)
  setTimeout(() => {
    const btn = document.getElementById(`callBtn_${driverId}`);
    if (btn) {
      btn.onclick = () => createCallForDriver(driverId);
    }
  }, 80);
}

/* ========== طباعة نداء مفرد (call) ========== */
window.printOrder = async function (callId) {
  if (!currentMerchantId) return alert(t("alertMerchantNotSet"));
  const doc = await db
    .collection("merchants")
    .doc(currentMerchantId)
    .collection("calls")
    .doc(callId)
    .get();
  if (!doc.exists) return alert(t("alertOrderNotFound"));
  const o = { id: doc.id, ...doc.data() };

  const shortId = getShortId(o.id);
  const docDir = currentLang === "ar" ? "rtl" : "ltr";

  const titlePrefix = t("printSingleOrderTitlePrefix");
  const headingPrefix = t("printSingleOrderHeadingPrefix");

  let html =
    `<html dir="${docDir}"><head><meta charset="utf-8">` +
    `<title>${titlePrefix} #${shortId}</title></head><body>`;

  html += `<h3>${headingPrefix} #${shortId}</h3>`;

  const driverName = (
    (o.driverFirstName || "") +
    " " +
    (o.driverLastName || "")
  ).trim();

  html += `<div>${t("printSingleOrderDriverLabel")}: ${escapeHtml(
    driverName
  )}</div>`;
  html += `<div>${t("printSingleOrderDriverPhoneLabel")}: ${escapeHtml(
    o.driverPhone || "-"
  )}</div>`;
  html += `<div>${t("printSingleOrderCustomerLabel")}: ${escapeHtml(
    o.customerName || "-"
  )}</div>`;
  html += `<div>${t("printSingleOrderAddressLabel")}: ${escapeHtml(
    o.deliveryAddress || "-"
  )}</div>`;
  html += `<div>${t("printSingleOrderCostLabel")}: ${escapeHtml(
    o.deliveryFee != null ? o.deliveryFee : "-"
  )}</div>`;

  html += `</body></html>`;
  const w = window.open("", "_blank");
  w.document.write(html);
  w.document.close();
  w.print();
};

/* ========== إلغاء الطلب (call) من التاجر ========== */
window.cancelOrder = async function (callId) {
  if (!currentMerchantId) {
    return alert(t("alertMerchantNotSet"));
  }

  // نفس نص التنبيه الذي عرفناه في I18N: cancelActiveOrderConfirm
  if (!confirm(t("cancelActiveOrderConfirm"))) return;

  try {
    const callRef = db
      .collection("merchants")
      .doc(currentMerchantId)
      .collection("calls")
      .doc(callId);

    // هنا نستخدم الدالة المشتركة التي تحدث التاجر + السائق معاً
    await cancelCallAndNotifyDriver(callRef);

    closeOrderModal();
  } catch (err) {
    alert(t("alertCancelOrderErrorPrefix") + err.message);
  }
};

/* ========== small helpers ========== */
sortActive.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
sortCompleted.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
filterDriver.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
sortActive.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
sortCompleted.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
filterDriver.addEventListener("change", () =>
  renderMerchantCalls(lastCallsCache)
);
// إغلاق قائمة السائقين عند الضغط خارجها
document.addEventListener("click", (event) => {
  if (!driversPickerPanel) return;

  // لو ليست مفتوحة، لا نفعل شيئاً
  if (!driversPickerPanel.classList.contains("visible")) return;

  const target = event.target;

  // إذا كان الضغط داخل البانل نفسه → لا تغلق
  if (driversPickerPanel.contains(target)) return;

  // إذا كان الضغط على زر السهم الذي يفتح/يغلق القائمة → لا نغلق هنا
  if (openDriversPickerBtn && openDriversPickerBtn.contains(target)) return;

  // في كل الحالات الأخرى (أي مكان خارج البانل) → أغلق
  closeDriversPicker();
});

// ⬇⬇ ضع هذا القطع هنا ⬇⬇
if (openDriversPickerBtn) {
  openDriversPickerBtn.addEventListener("click", () => {
    if (driversPickerPanel && driversPickerPanel.classList.contains("visible")) {
      closeDriversPicker();
    } else {
      openDriversPicker();
    }
  });
}

if (driversPickerCloseBtn) {
  driversPickerCloseBtn.addEventListener("click", closeDriversPicker);
}
// ⬆⬆ نهاية الكود الجديد ⬆⬆

/* ========== i18n: تطبيق اللغة على النصوص الثابتة ========== */
function applyLanguageToStaticUI() {
  // ...
}

/* ========== i18n: تطبيق اللغة على النصوص الثابتة ========== */
function applyLanguageToStaticUI() {
  document.title = t("pageTitle");
  const mainHeaderEl = document.getElementById("mainHeader");
  if (mainHeaderEl) mainHeaderEl.textContent = t("mainHeader");

  const langLabel = document.getElementById("langLabel");
  if (langLabel) langLabel.textContent = t("languageLabel");

  if (registerTab) registerTab.textContent = t("tabRegister");
  if (loginTab) loginTab.textContent = t("tabLogin");

  const regTitle = document.querySelector("#merchantForm h3");
  if (regTitle) regTitle.textContent = t("registerTitle");
  const storeNameEl = document.getElementById("storeName");
  if (storeNameEl) storeNameEl.placeholder = t("storeNamePlaceholder");
  const storeAddressEl = document.getElementById("storeAddress");
  if (storeAddressEl) storeAddressEl.placeholder = t("storeAddressPlaceholder");
  const storeCityEl = document.getElementById("storeCity");
  if (storeCityEl) storeCityEl.placeholder = t("storeCityPlaceholder");
  const storePhoneEl = document.getElementById("storePhone");
  if (storePhoneEl) storePhoneEl.placeholder = t("storePhonePlaceholder");
  const contactNameEl = document.getElementById("contactName");
  if (contactNameEl) contactNameEl.placeholder = t("contactNamePlaceholder");
  const contactPhoneEl = document.getElementById("contactPhone");
  if (contactPhoneEl) contactPhoneEl.placeholder = t("contactPhonePlaceholder");
  const contactEmailEl = document.getElementById("contactEmail");
  if (contactEmailEl) contactEmailEl.placeholder = t("contactEmailPlaceholder");
  const merchantPasswordEl = document.getElementById("merchantPassword");
  if (merchantPasswordEl) merchantPasswordEl.placeholder = t("merchantPasswordPlaceholder");
  const regSubmitBtn = merchantForm && merchantForm.querySelector('button[type="submit"]');
  if (regSubmitBtn) regSubmitBtn.textContent = t("registerSubmit");

  const loginTitle = document.querySelector("#loginForm h3");
  if (loginTitle) loginTitle.textContent = t("loginTitle");
  const loginEmailEl = document.getElementById("loginEmail");
  if (loginEmailEl) loginEmailEl.placeholder = t("loginEmailPlaceholder");
  const loginPasswordEl = document.getElementById("loginPassword");
  if (loginPasswordEl) loginPasswordEl.placeholder = t("loginPasswordPlaceholder");
  const loginSubmitBtn = loginForm && loginForm.querySelector('button[type="submit"]');
  if (loginSubmitBtn) loginSubmitBtn.textContent = t("loginSubmit");

  if (merchantOnlineToggle) {
    merchantOnlineToggle.textContent = merchantCurrentOnline ? t("topbarOnline") : t("topbarOffline");
  }
  if (merchantEarningsTopEl) {
    const currentHtml = merchantEarningsTopEl.innerHTML;
    const valueMatch = currentHtml.match(/<strong>(.*?)<\/strong>/);
    const val = valueMatch ? valueMatch[1] : "0 €";
    merchantEarningsTopEl.innerHTML = `${t("topbarTotalDelivery")}<br><strong>${val}</strong>`;
  }
  if (onlineDriversBadge) {
    const label = onlineDriversBadge.querySelector(".label");
    if (label) label.textContent = t("onlineDriversLabel");
  }

  const activeTitle = document.getElementById("activeOrdersTitle");
  if (activeTitle) activeTitle.textContent = t("activeOrdersTitle");
  const completedTitle = document.getElementById("completedOrdersTitle");
  if (completedTitle) completedTitle.textContent = t("completedOrdersTitle");

  if (filterDriver && filterDriver.options.length > 0) {
    filterDriver.options[0].textContent = t("filterAllDrivers");
  }

  if (sortActive && sortActive.options.length === 4) {
    sortActive.options[0].textContent = t("sortDateDesc");
    sortActive.options[1].textContent = t("sortDateAsc");
    sortActive.options[2].textContent = t("sortDriverAsc");
    sortActive.options[3].textContent = t("sortDriverDesc");
  }
  if (sortCompleted && sortCompleted.options.length === 4) {
    sortCompleted.options[0].textContent = t("sortDateDesc");
    sortCompleted.options[1].textContent = t("sortDateAsc");
    sortCompleted.options[2].textContent = t("sortDriverAsc");
    sortCompleted.options[3].textContent = t("sortDriverDesc");
  }
  // عنوان مودال تفاصيل الطلب + زر إغلاق في الهيدر
  const orderDetailsHeader = document.querySelector("#orderModal h3");
  if (orderDetailsHeader) {
    orderDetailsHeader.textContent = t("orderDetailsModalTitle");
  }

  if (exportCsvBtn) exportCsvBtn.textContent = t("exportCsv");
  if (printBtn) printBtn.textContent = t("print");
  if (logoutBtn) logoutBtn.textContent = t("logout");

  renderMerchantCalls(lastCallsCache || []);
}
const LTR_LANGS = ["en", "de", "tr"];

function updateDirection() {
  const isLtr = LTR_LANGS.includes(currentLang);
  document.documentElement.dir = isLtr ? "ltr" : "rtl";
  document.body.classList.toggle("ltr-layout", isLtr);
  document.body.classList.toggle("rtl-layout", !isLtr);
}

function initLanguage() {
  const select = document.getElementById("langSelect");
  const saved = localStorage.getItem("merchantLang");

  if (saved && I18N[saved]) {
    currentLang = saved;
  } else {
    currentLang = "ar";
  }

  document.documentElement.lang = currentLang;
  if (select) select.value = currentLang;

  // اضبط الاتجاه أول مرة
  updateDirection();
  applyLanguageToStaticUI();

  if (select) {
    select.addEventListener("change", () => {
      const val = select.value;
      if (I18N[val]) {
        currentLang = val;
        document.documentElement.lang = val;
        localStorage.setItem("merchantLang", val);
        updateDirection();          // غيّر RTL/LTR
        applyLanguageToStaticUI();  // حدّث النصوص
      }
    });
  }
}

/* ========== Clean up when leave ========== */
window.addEventListener("beforeunload", () => {
  if (ordersListenerUnsub) ordersListenerUnsub();
  if (driversListenerUnsub) driversListenerUnsub();
  if (merchantCallsListenerUnsub) merchantCallsListenerUnsub();
});

/* تشغيل i18n بعد تحميل السكربت */
initLanguage();
</script>
</body>
</html>
